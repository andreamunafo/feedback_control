<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.2.475">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>feedback_control - Nyquist Stability Criterion</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1.6em;
  vertical-align: middle;
}
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { color: #008000; } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { color: #008000; font-weight: bold; } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
</style>


<script src="site_libs/quarto-nav/quarto-nav.js"></script>
<script src="site_libs/quarto-nav/headroom.min.js"></script>
<script src="site_libs/clipboard/clipboard.min.js"></script>
<script src="site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="site_libs/quarto-search/fuse.min.js"></script>
<script src="site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="./">
<script src="site_libs/quarto-html/quarto.js"></script>
<script src="site_libs/quarto-html/popper.min.js"></script>
<script src="site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="site_libs/quarto-html/anchor.min.js"></script>
<link href="site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="site_libs/bootstrap/bootstrap.min.js"></script>
<link href="site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 20,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit"
  }
}</script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" integrity="sha512-c3Nl8+7g4LMSTdrm621y7kf9v3SDPnhxLNhcjFJbKECVnmZHTdo+IRO05sNLTH/D3vA6u1X32ehoLC7WFVdheg==" crossorigin="anonymous"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.5.1/jquery.min.js" integrity="sha512-bLT0Qm9VnAYZDflyKcBaQ2gg0hSYNQrJ8RilYldYQ1FxQYoCLtUjuuRuZo+fjqhx/qtq/1itJ0C2ejDxltZVFg==" crossorigin="anonymous"></script>
<script type="application/javascript">define('jquery', [],function() {return window.jQuery;})</script>

  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<link rel="stylesheet" href="styles.css">
<meta property="og:title" content="feedback_control - Nyquist Stability Criterion">
<meta property="og:description" content="Note: to use FuncAnimation please uncomment line: %matplotlib notebook in each cell. It is currently commented to avoid errors in github CI.">
<meta property="og:site-name" content="feedback_control">
<meta name="twitter:title" content="feedback_control - Nyquist Stability Criterion">
<meta name="twitter:description" content="Note: to use FuncAnimation please uncomment line: %matplotlib notebook in each cell. It is currently commented to avoid errors in github CI.">
<meta name="twitter:card" content="summary">
</head>

<body class="nav-sidebar floating nav-fixed">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg navbar-dark ">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container">
    <a class="navbar-brand" href="./index.html">
    <span class="navbar-title">feedback_control</span>
    </a>
  </div>
          <div id="quarto-search" class="" title="Search"></div>
      </div> <!-- /container-fluid -->
    </nav>
  <nav class="quarto-secondary-nav" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
    <div class="container-fluid d-flex justify-content-between">
      <h1 class="quarto-secondary-nav-title">Nyquist Stability Criterion</h1>
      <button type="button" class="quarto-btn-toggle btn" aria-label="Show secondary navigation">
        <i class="bi bi-chevron-right"></i>
      </button>
    </div>
  </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
  <nav id="quarto-sidebar" class="sidebar collapse sidebar-navigation floating overflow-auto">
    <div class="sidebar-menu-container"> 
    <ul class="list-unstyled mt-1">
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./index.html" class="sidebar-item-text sidebar-link">Feedback Control</a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./syllabus.html" class="sidebar-item-text sidebar-link">Syllabus - Principles of Automatic Control / Fondamenti di Automatica 2023</a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./getting_started_with_python_and_jupyter_notebook.html" class="sidebar-item-text sidebar-link">Getting Started with Python and Jupyter Notebooks</a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./intro_to_control_theory.html" class="sidebar-item-text sidebar-link">Introduction to Control Theory: The Control Problem</a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./transfer_functions.html" class="sidebar-item-text sidebar-link">Transfer Functions</a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./block_diagrams.html" class="sidebar-item-text sidebar-link">Block Diagrams</a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./system_response.html" class="sidebar-item-text sidebar-link">System Response</a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./intro_to_freq_response_and_bode_plots.html" class="sidebar-item-text sidebar-link">Introduction to Frequency Response Methods: Bode Plots</a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./final_value_theorem_and_steady_state_error.html" class="sidebar-item-text sidebar-link">Final Value Theorem and Steady State Error</a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./main_types_of_loops_and_transfer_functions.html" class="sidebar-item-text sidebar-link">Main types of loops and transfer functions</a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./routh_hurwitz_criterion.html" class="sidebar-item-text sidebar-link">Routh-Hurwitz Criterion</a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./part_1_recap.html" class="sidebar-item-text sidebar-link">Part 1 Recap</a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./nyquist_stability_criterion.html" class="sidebar-item-text sidebar-link active">Nyquist Stability Criterion</a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./stability_margins.html" class="sidebar-item-text sidebar-link">Stability Margins</a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./loop-shaping.html" class="sidebar-item-text sidebar-link">Controller design: Loop analysis and shaping</a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./root_locus.html" class="sidebar-item-text sidebar-link">Root Locus</a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./lead_lag_compensators.html" class="sidebar-item-text sidebar-link">Phase Lead/Phase Lag Compensators</a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./pid_control.html" class="sidebar-item-text sidebar-link">PID Control</a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./part_2_recap.html" class="sidebar-item-text sidebar-link">Part 2 Recap</a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./murray_hopper.html" class="sidebar-item-text sidebar-link">Grace Murray Hopper (1906-1992): A legacy of innovation and service</a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./a_assignment.html" class="sidebar-item-text sidebar-link">Assignment Part 1</a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./b_assignment.html" class="sidebar-item-text sidebar-link">Assignment Part 2</a>
  </div>
</li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-1" aria-expanded="true">workspace</a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-1" aria-expanded="true">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-1" class="collapse list-unstyled sidebar-section depth1 show">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./workspace/simple_pendulum.html" class="sidebar-item-text sidebar-link">Simulating a simple pendulum</a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./workspace/dc_motor.html" class="sidebar-item-text sidebar-link">DC Motor</a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./workspace/workspace.html" class="sidebar-item-text sidebar-link">Workspace</a>
  </div>
</li>
      </ul>
  </li>
    </ul>
    </div>
</nav>
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#open-and-close-loop-analysis" id="toc-open-and-close-loop-analysis" class="nav-link active" data-scroll-target="#open-and-close-loop-analysis">Open and Close Loop Analysis</a>
  <ul class="collapse">
  <li><a href="#how-to-generate-the-nyquist-plot" id="toc-how-to-generate-the-nyquist-plot" class="nav-link" data-scroll-target="#how-to-generate-the-nyquist-plot">How to generate the Nyquist Plot</a></li>
  <li><a href="#the-nyquist-plot" id="toc-the-nyquist-plot" class="nav-link" data-scroll-target="#the-nyquist-plot">The Nyquist plot</a></li>
  <li><a href="#open-loop-stable" id="toc-open-loop-stable" class="nav-link" data-scroll-target="#open-loop-stable">Open loop stable</a></li>
  <li><a href="#open-loop-unstable" id="toc-open-loop-unstable" class="nav-link" data-scroll-target="#open-loop-unstable">Open loop unstable</a></li>
  </ul></li>
  <li><a href="#estimating-nyquist-plots" id="toc-estimating-nyquist-plots" class="nav-link" data-scroll-target="#estimating-nyquist-plots">Estimating Nyquist Plots</a>
  <ul class="collapse">
  <li><a href="#steps-to-plot-a-nyquist-plot" id="toc-steps-to-plot-a-nyquist-plot" class="nav-link" data-scroll-target="#steps-to-plot-a-nyquist-plot">Steps to plot a Nyquist plot</a></li>
  <li><a href="#poles-on-the-imaginary-axis" id="toc-poles-on-the-imaginary-axis" class="nav-link" data-scroll-target="#poles-on-the-imaginary-axis">Poles on the imaginary axis</a></li>
  <li><a href="#nyquist-plot-final-comments" id="toc-nyquist-plot-final-comments" class="nav-link" data-scroll-target="#nyquist-plot-final-comments">Nyquist plot: final comments</a></li>
  </ul></li>
  </ul>
<div class="toc-actions"><div><i class="bi bi-github"></i></div><div class="action-links"><p><a href="https://github.com/andreamunafo/feedback_control/issues/new" class="toc-action">Report an issue</a></p></div></div></nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title d-none d-lg-block">Nyquist Stability Criterion</h1>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  

</header>

<!-- WARNING: THIS FILE WAS AUTOGENERATED! DO NOT EDIT! -->
<p>Note: to use <code>FuncAnimation</code> please uncomment line: <code>%matplotlib notebook</code> in each cell. It is currently commented to avoid errors in github CI.</p>
<section id="open-and-close-loop-analysis" class="level2">
<h2 class="anchored" data-anchor-id="open-and-close-loop-analysis">Open and Close Loop Analysis</h2>
<p>Let‚Äôs consider a typical open loop control system, with plant <span class="math inline">\(G(s)\)</span> and controller <span class="math inline">\(H(s)\)</span>:</p>


<img src="img/typical-control-system-1.png" alt="typical-control-system" style="width: 500px;">


<ul>
<li>We typically know both <span class="math inline">\(G(s)\)</span> and <span class="math inline">\(H(s)\)</span></li>
<li>The open loop transfer function is <span class="math inline">\(G(s)H(s)\)</span></li>
</ul>
<p>When we close the loop:</p>


<img src="img/typical-control-system-2.png" alt="typical-control-system" style="width: 500px;">


<ul>
<li>This changes the transfer function for the entire system, which becomes:</li>
</ul>
<p><span class="math display">\[
\frac{G(s)}{1+G(s)H(s)}
\]</span></p>
<p>We can then differentiate two cases:</p>
<p><strong>Open Loop case</strong></p>
<p>To find out if the open loop system is stable: - analyse the poles of <span class="math inline">\(G(s)H(s)\)</span> (when this transfer function goes to infinity) - if there is a pole with <span class="math inline">\(Re &gt; 0\)</span>, then the open loop transfer function is unstable</p>
<p><strong>Closed Loop case</strong></p>
<p>To find out if the closed loop system is stable:</p>
<p><span class="math display">\[
\frac{G(s)}{1+G(s)H(s)}
\]</span> - analyse the denominator: <span class="math inline">\(1+G(s)H(s) = 0\)</span> (so that the closed loop transfer function goes to infinity) - zeros (roots of the numerator) of <span class="math inline">\(1+G(s)H(s) = 0\)</span> causes the closed loop transfer function to go to infinity - if there is a root with <span class="math inline">\(Re &gt; 0\)</span>, then the closed loop transfer function is unstable</p>
<p><strong>Note</strong> we are assuming that <span class="math inline">\(G(s)\)</span> and <span class="math inline">\(H(s)\)</span> are known, so poles and zeros of <span class="math inline">\(G(s)H(s)\)</span> are known. We can analyse this function and make a determination on whether the system is open loop stable or not.</p>
<p>At the same time, note that we would like to understand how the closed loop system behaves.</p>
<p><strong>Goal</strong> - When we want to study the stability of the closed loop system: - We want to find the roots of <span class="math inline">\(1+ùê∫(ùë†)ùêª(ùë†)=0\)</span>, - or take the open loop transfer function <span class="math inline">\(G(s)H(s)\)</span>, add 1 and find its zeros.</p>
<p><strong>Why is this difficult</strong> - The system can be high order (e.g.&nbsp;order 50), - Finding zeros would only give us stability information, - Other information could be useful (e.g.&nbsp;stability margins).</p>
<p>Let‚Äôs understand this a little better plotting poles and zeros of a transfer function.</p>
<p>We use the Python Control Library, and define our transfer function that we call <code>sys</code>:</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb1"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a>sys <span class="op">=</span> control.tf([<span class="dv">1</span>, <span class="dv">3</span>, <span class="dv">5</span>, <span class="dv">7</span>], [<span class="dv">2</span>, <span class="dv">4</span>, <span class="dv">6</span>, <span class="dv">8</span>, <span class="dv">2</span>])</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="cell">
<div class="sourceCode cell-code" id="cb2"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(sys)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>
     s^3 + 3 s^2 + 5 s + 7
-------------------------------
2 s^4 + 4 s^3 + 6 s^2 + 8 s + 2
</code></pre>
</div>
</div>
<p>Now we plot the poles and zeros for the open loop system <span class="math inline">\(G(s)H(s)\)</span>. And for the stability we are interested in the location of the poles, plotted in red in the picture.</p>
<p>We can use the <a href="https://python-control.readthedocs.io/en/latest/generated/control.pzmap.html">pzmap</a> function of the Python Control Library to plot poles and zeros.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb4"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a>fig <span class="op">=</span> plt.figure(figsize<span class="op">=</span>(<span class="dv">10</span>, <span class="dv">5</span>))</span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a><span class="co"># Calls function pzmap which calculates poles and zeros</span></span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a>control.pzmap(sys, title<span class="op">=</span><span class="st">'Pole Zero Map for the Open Loop System GH'</span>)<span class="op">;</span></span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a>       </span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a><span class="co"># What is really happening is that pzmap is plotting the roots of the denominator (poles) </span></span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true" tabindex="-1"></a><span class="co"># and the roots of the numerator (zeros). We can show this plotting the roots explicitely:</span></span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-9"><a href="#cb4-9" aria-hidden="true" tabindex="-1"></a><span class="co"># zeros - roots of the numerator</span></span>
<span id="cb4-10"><a href="#cb4-10" aria-hidden="true" tabindex="-1"></a>plt.plot(np.real(np.roots([<span class="dv">1</span>, <span class="dv">3</span>, <span class="dv">5</span>, <span class="dv">7</span>])), np.imag(np.roots([<span class="dv">1</span>, <span class="dv">3</span>, <span class="dv">5</span>, <span class="dv">7</span>])),<span class="st">'b.'</span>)<span class="op">;</span></span>
<span id="cb4-11"><a href="#cb4-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-12"><a href="#cb4-12" aria-hidden="true" tabindex="-1"></a><span class="co"># poles - roots of the denominator</span></span>
<span id="cb4-13"><a href="#cb4-13" aria-hidden="true" tabindex="-1"></a>plt.plot(np.real(np.roots([<span class="dv">2</span>, <span class="dv">4</span>, <span class="dv">6</span>, <span class="dv">8</span>, <span class="dv">2</span>])), np.imag(np.roots([<span class="dv">2</span>, <span class="dv">4</span>, <span class="dv">6</span>, <span class="dv">8</span>, <span class="dv">2</span>])),<span class="st">'rx'</span>)<span class="op">;</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<p><img src="11_Nyquist_stability_criterion_files/figure-html/cell-6-output-1.png" class="img-fluid"></p>
</div>
</div>
<p>And now let‚Äôs plot poles and zeros of the closed loop system.</p>
<p><strong>Note</strong>: - we are now interested in the location of the zeros, plotted in red in the picture; we are interested in <span class="math inline">\(1+G(s)H(s)\)</span>.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb5"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a>fig <span class="op">=</span> plt.figure(figsize<span class="op">=</span>(<span class="dv">10</span>, <span class="dv">5</span>))</span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a>control.pzmap(sys<span class="op">+</span><span class="dv">1</span>, title<span class="op">=</span><span class="st">'Pole Zero Map for the Closed Loop System 1+GH'</span>)<span class="op">;</span></span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a><span class="co"># zeros - roots of the numerator -  these are the poles of the Closed loop transfer function</span></span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true" tabindex="-1"></a>plt.plot(np.real(np.roots(np.array([<span class="dv">2</span>, <span class="dv">4</span>, <span class="dv">6</span>, <span class="dv">8</span>, <span class="dv">2</span>])<span class="op">+</span>np.array([<span class="dv">0</span>, <span class="dv">1</span>, <span class="dv">3</span>, <span class="dv">5</span>, <span class="dv">7</span>]))), </span>
<span id="cb5-8"><a href="#cb5-8" aria-hidden="true" tabindex="-1"></a>         np.imag(np.roots(np.array([<span class="dv">2</span>, <span class="dv">4</span>, <span class="dv">6</span>, <span class="dv">8</span>, <span class="dv">2</span>])<span class="op">+</span>np.array([<span class="dv">0</span>, <span class="dv">1</span>, <span class="dv">3</span>, <span class="dv">5</span>, <span class="dv">7</span>]))),<span class="st">'r.'</span>) </span>
<span id="cb5-9"><a href="#cb5-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-10"><a href="#cb5-10" aria-hidden="true" tabindex="-1"></a><span class="co"># poles - roots of the denominator</span></span>
<span id="cb5-11"><a href="#cb5-11" aria-hidden="true" tabindex="-1"></a>plt.plot(np.real(np.roots([<span class="dv">2</span>, <span class="dv">4</span>, <span class="dv">6</span>, <span class="dv">8</span>, <span class="dv">2</span>])), np.imag(np.roots([<span class="dv">2</span>, <span class="dv">4</span>, <span class="dv">6</span>, <span class="dv">8</span>, <span class="dv">2</span>])),<span class="st">'bx'</span>)<span class="op">;</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<p><img src="11_Nyquist_stability_criterion_files/figure-html/cell-7-output-1.png" class="img-fluid"></p>
</div>
</div>
<ul>
<li><strong>There is not a clear relationship between the poles of <span class="math inline">\(G(s)H(s)\)</span> and the zeros of <span class="math inline">\(1+G(s)H(s)\)</span>,</strong></li>
<li>When we add 1 this can really move the location of the roots substantially</li>
</ul>
<p>Let‚Äôs instead plot the Nyquist diagram. For now we just call the <code>nyquist_plot</code> function from the Python Control Library:</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb6"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a>fig <span class="op">=</span> plt.figure(figsize<span class="op">=</span>(<span class="dv">10</span>, <span class="dv">5</span>))</span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a><span class="co"># nyquist_plot to plot the Nyquist plot</span></span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a>control.nyquist_plot([sys, <span class="dv">1</span><span class="op">+</span>sys])<span class="op">;</span></span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true" tabindex="-1"></a>plt.legend([<span class="st">'sys'</span>, <span class="st">'sys'</span>, <span class="st">'-1'</span>, <span class="st">'sys+1'</span>, <span class="st">'sys+1'</span>], loc<span class="op">=</span><span class="st">'upper right'</span>)<span class="op">;</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<p><img src="11_Nyquist_stability_criterion_files/figure-html/cell-8-output-1.png" class="img-fluid"></p>
</div>
</div>
<p>And on the Nyquist plot it is simple to see that we are really only adding 1 and shifting it accordingly. - Adding 1 and calculate the how this affects zeros/poles is difficult - Adding 1 to a Nyquist plot is easy to do</p>
<p>If we know how to understand the stability from the Nyquist plot then everthing becomes easier</p>
<section id="how-to-generate-the-nyquist-plot" class="level3">
<h3 class="anchored" data-anchor-id="how-to-generate-the-nyquist-plot">How to generate the Nyquist Plot</h3>
<ul>
<li>Once we know how to generate a Nyquist plot, it is easy to understand how it relates to stability</li>
<li>Key is the Cauchy‚Äôs Argument Principle</li>
</ul>
<section id="cauchys-argument-principle" class="level4">
<h4 class="anchored" data-anchor-id="cauchys-argument-principle">Cauchy‚Äôs Argument Principle</h4>
<p>Let‚Äôs take an arbitraty transfer function:</p>
<p><span class="math display">\[
G(s) = \frac{s+3}{s+2}
\]</span></p>
<ul>
<li>Pole <span class="math inline">\(s=-2\)</span></li>
<li>Zero <span class="math inline">\(s=-3\)</span></li>
</ul>
<hr>
<p>We can plot poles and zeros in the s-plane:</p>


<img src="img/nyquist_zeros_poles.png" alt="nyquist_zeros_poles" style="width: 300px;">


<p>If we take one point in the s-plane, for example: <span class="math inline">\(s=-2+1j\)</span>, we get another complex number when we plug it in <span class="math inline">\(G(s)\)</span>:</p>
<p><span class="math display">\[
\frac{s+3}{s+2} = \frac{(-2+1j)+3}{(-2+1j)+2} = \frac{1+1j}{j} = \frac{1+1j}{j}\frac{-j}{-j} = 1 -j
\]</span></p>
<p>And we can plot this new complex number on another plane (that we can call <span class="math inline">\(\Omega\)</span>-plane):</p>


<img src="img/nyquist_w_plane.png" alt="nyquist_w_plane" style="width: 300px;">


<p>Our transfer function is mapping a point from the s-plane into a new point into the new plane <span class="math inline">\(\Omega\)</span> - As we pick more and more points in the s-plane, forming a continuous line in the s-plane (<em>contour</em>), they will form a continuous line in the <span class="math inline">\(\Omega\)</span>-plane - And if we pick points on a <strong>contour</strong> in the s-plane (a line that closes up on itself), it becomes a closed line in the <span class="math inline">\(\Omega\)</span>-plane (we call it a <strong>plot</strong>) - The plot contains the magnite and phase information for each of the system‚Äôs poles and zeros.</p>
<hr>
<p>Let‚Äôs verify this in Python:</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb7"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a>fig, axs <span class="op">=</span> plt.subplots(<span class="dv">1</span>, <span class="dv">2</span>, figsize<span class="op">=</span>(<span class="dv">15</span>, <span class="dv">10</span>))</span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a>     </span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a><span class="co">########################################</span></span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a><span class="co"># This is only to add some more context to the plots (axis, grids and scales the axis)</span></span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="bu">len</span>(axs)):</span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true" tabindex="-1"></a>    axs[i].plot([<span class="op">-</span><span class="dv">10</span>, <span class="dv">10</span>], [<span class="dv">0</span>, <span class="dv">0</span>], color<span class="op">=</span><span class="st">'black'</span>, linewidth<span class="op">=</span><span class="dv">3</span>, linestyle<span class="op">=</span><span class="st">'--'</span>) <span class="co"># axis</span></span>
<span id="cb7-7"><a href="#cb7-7" aria-hidden="true" tabindex="-1"></a>    axs[i].plot([<span class="dv">0</span>, <span class="dv">0</span>], [<span class="op">-</span><span class="dv">10</span>, <span class="dv">10</span>], color<span class="op">=</span><span class="st">'black'</span>, linewidth<span class="op">=</span><span class="dv">3</span>, linestyle<span class="op">=</span><span class="st">'--'</span>) <span class="co"># axis</span></span>
<span id="cb7-8"><a href="#cb7-8" aria-hidden="true" tabindex="-1"></a>    axs[i].axis([<span class="op">-</span><span class="dv">4</span>, <span class="dv">3</span>, <span class="op">-</span><span class="dv">3</span>, <span class="dv">3</span>]) <span class="co"># scales the axis</span></span>
<span id="cb7-9"><a href="#cb7-9" aria-hidden="true" tabindex="-1"></a>    axs[i].grid() <span class="co"># add grid</span></span>
<span id="cb7-10"><a href="#cb7-10" aria-hidden="true" tabindex="-1"></a>    axs[i].set_aspect(<span class="st">'equal'</span>, <span class="st">'box'</span>)</span>
<span id="cb7-11"><a href="#cb7-11" aria-hidden="true" tabindex="-1"></a>    axs[i].set_xticks([<span class="op">-</span><span class="dv">3</span>, <span class="op">-</span><span class="dv">2</span>, <span class="op">-</span><span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>])</span>
<span id="cb7-12"><a href="#cb7-12" aria-hidden="true" tabindex="-1"></a>    axs[i].set_xlabel(<span class="st">'Real'</span>)</span>
<span id="cb7-13"><a href="#cb7-13" aria-hidden="true" tabindex="-1"></a>    axs[i].set_ylabel(<span class="st">'Imag'</span>)<span class="op">;</span>    </span>
<span id="cb7-14"><a href="#cb7-14" aria-hidden="true" tabindex="-1"></a>axs[<span class="dv">0</span>].set_title(<span class="st">'s-plane'</span>)</span>
<span id="cb7-15"><a href="#cb7-15" aria-hidden="true" tabindex="-1"></a>axs[<span class="dv">1</span>].set_title(<span class="st">'$\Omega$-plane'</span>)</span>
<span id="cb7-16"><a href="#cb7-16" aria-hidden="true" tabindex="-1"></a><span class="co">########################################        </span></span>
<span id="cb7-17"><a href="#cb7-17" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb7-18"><a href="#cb7-18" aria-hidden="true" tabindex="-1"></a><span class="co"># plot our poles and zeros in the s-plane    </span></span>
<span id="cb7-19"><a href="#cb7-19" aria-hidden="true" tabindex="-1"></a>axs[<span class="dv">0</span>].plot(<span class="op">-</span><span class="dv">3</span>, <span class="dv">0</span>, color<span class="op">=</span><span class="st">'blue'</span>, marker<span class="op">=</span><span class="st">'o'</span>, markersize<span class="op">=</span><span class="dv">12</span>)</span>
<span id="cb7-20"><a href="#cb7-20" aria-hidden="true" tabindex="-1"></a>axs[<span class="dv">0</span>].plot(<span class="op">-</span><span class="dv">2</span>, <span class="dv">0</span>, color<span class="op">=</span><span class="st">'red'</span>, marker<span class="op">=</span><span class="st">'x'</span>, markersize<span class="op">=</span><span class="dv">12</span>)</span>
<span id="cb7-21"><a href="#cb7-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-22"><a href="#cb7-22" aria-hidden="true" tabindex="-1"></a><span class="co"># This is the interesting part:  </span></span>
<span id="cb7-23"><a href="#cb7-23" aria-hidden="true" tabindex="-1"></a><span class="co">#    Map between s-plane and Omega plane.</span></span>
<span id="cb7-24"><a href="#cb7-24" aria-hidden="true" tabindex="-1"></a><span class="co">#    Thefor loop is simply doing the same operation for all points selected in the</span></span>
<span id="cb7-25"><a href="#cb7-25" aria-hidden="true" tabindex="-1"></a><span class="co">#    s-plane (s_point). This is what we have done manually above.</span></span>
<span id="cb7-26"><a href="#cb7-26" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> xi <span class="kw">in</span> np.arange(<span class="dv">0</span>, <span class="fl">6.28</span>, <span class="fl">0.1</span>):</span>
<span id="cb7-27"><a href="#cb7-27" aria-hidden="true" tabindex="-1"></a>    s_point <span class="op">=</span> np.sin(xi), <span class="dv">3</span><span class="op">*</span>np.cos(xi) <span class="co"># pick one s-point</span></span>
<span id="cb7-28"><a href="#cb7-28" aria-hidden="true" tabindex="-1"></a>    axs[<span class="dv">0</span>].plot(s_point[<span class="dv">0</span>],s_point[<span class="dv">1</span>], <span class="co"># plot the s-point in the s-plane</span></span>
<span id="cb7-29"><a href="#cb7-29" aria-hidden="true" tabindex="-1"></a>                marker<span class="op">=</span><span class="st">'.'</span>, color<span class="op">=</span><span class="st">'m'</span>, markersize<span class="op">=</span><span class="dv">10</span>)</span>
<span id="cb7-30"><a href="#cb7-30" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb7-31"><a href="#cb7-31" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Map one s_point to a W_point</span></span>
<span id="cb7-32"><a href="#cb7-32" aria-hidden="true" tabindex="-1"></a>    W_point <span class="op">=</span> (<span class="bu">complex</span>(s_point[<span class="dv">0</span>],s_point[<span class="dv">1</span>]) <span class="op">+</span> <span class="dv">3</span>)<span class="op">/</span>(<span class="bu">complex</span>(s_point[<span class="dv">0</span>],s_point[<span class="dv">1</span>]) <span class="op">+</span> <span class="dv">2</span>)    <span class="co"># This is our transfer function</span></span>
<span id="cb7-33"><a href="#cb7-33" aria-hidden="true" tabindex="-1"></a>    axs[<span class="dv">1</span>].plot(np.real(W_point), np.imag(W_point), marker<span class="op">=</span><span class="st">'.'</span>, color<span class="op">=</span><span class="st">'r'</span>, markersize<span class="op">=</span><span class="dv">10</span>)  <span class="co"># plot the point</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<p><img src="11_Nyquist_stability_criterion_files/figure-html/cell-9-output-1.png" class="img-fluid"></p>
</div>
</div>
<ul>
<li>The contour in the <span class="math inline">\(\Omega\)</span>-plane is the codomain of the Transfer function and for this reason it contains information on the magnitude and phase of the zeros and poles of the transfer function.</li>
<li>This is useful to calculate the stability of the transfer function</li>
</ul>
<hr>
<p>For simplicity let‚Äôs now consider a simpler transfer function, with only one zero:</p>
<p><span class="math display">\[
G(s)=s+2
\]</span></p>
<ul>
<li>If we take the a point on the s-plane: <span class="math inline">\(s=-1+j\)</span>,</li>
<li>it becomes the point: <span class="math inline">\((-1+j)+2=1+j\)</span> in the <span class="math inline">\(\Omega\)</span>-plane.</li>
</ul>


<img src="img/nyquist_zero_map_s_plane.png" alt="nyquist_zero_map_s_plane" style="width: 300px;">


<img src="img/nyquist_zero_map_w_plane.png" alt="nyquist_zero_map_w_plane" style="width: 300px;">


<ul>
<li>It is important to note that the new point in the <span class="math inline">\(\Omega\)</span>-plane and the phasor between the zero and the point we chose in the s-plane <strong>is the same phasor</strong></li>
<li>This extends to multiple poles and zeros</li>
<li>This means that it is possible to plot the mapping between the two planes graphically</li>
</ul>
<p>To do this:</p>
<ul>
<li><ol type="1">
<li>Pick the point in the s-plane that you want to map over to the <span class="math inline">\(\Omega\)</span>-plane</li>
</ol></li>
<li><ol start="2" type="1">
<li>Draw all the phasors from zeros and poles to the point</li>
</ol></li>
<li><ol start="3" type="1">
<li>Calculate the magnitude multiplying the magnitudes of the zeros and dividing by the magnitude of the poles</li>
</ol>
<ul>
<li>This resulting magnitude is the length of the phasor in <span class="math inline">\(\Omega\)</span>-plane</li>
</ul></li>
<li><ol start="4" type="1">
<li>Calculate the phase adding all the zero phases and subtracting all the pole phases</li>
</ol></li>
</ul>
<p><span class="math display">\[
G(s)H(s) = \frac{(s-\beta_1)(s-\beta_2)...}{(s-\alpha_1)(s-\alpha_2)...}
\]</span></p>


<img src="img/nyquist_mulitple_pz_map_s_plane_10.png" alt="nyquist_mulitple_pz_map_s_plane_10" style="height: 400px;">


<img src="img/nyquist_mulitple_omega_plot_5.png" alt="nyquist_mulitple_omega_plot_5" style="height: 400px;">


<p>This is called a <strong>Polar plot</strong>, they tell us about the magnitude and phase contribution of a system at various frequency.</p>
<hr>
<ul>
<li>Let‚Äôs understand now what happens when we move along an arbitrary contour:</li>
</ul>


<img src="img/nyquist_mulitple_pz_map_s_plane_10-contour-1.png" alt="nyquist_mulitple_pz_map_s_plane_10" style="height: 400px;">


<ul>
<li>For each point along the contour we apply the same reasoning:
<ol type="1">
<li>Calculate the magnitude multiplying the magnitudes of the zeros and dividing by the magnitude of the poles</li>
<li>Calculate the phase adding all the zero phases and subtracting all the pole phases</li>
</ol></li>
<li>Note that, as we move along the contour:
<ul>
<li>the zero <span class="math inline">\(\beta_1\)</span> will contribute a net angle of <span class="math inline">\(-2\pi\)</span></li>
<li>the zero <span class="math inline">\(\beta_2\)</span> will contribute a net angle of <span class="math inline">\(0\)</span> (as we move, for each positive angle there is a negative angle). This is true for every other pole or zero out of the contour.</li>
</ul></li>
<li>Using this insight we can say from a qualitative standpoint:
<ul>
<li>The resulting contour is the <span class="math inline">\(\Omega\)</span>-plane will encircle the origin once and only one, in the clockwise direction because the angle is <span class="math inline">\(-2\pi\)</span>.</li>
<li>We are not interested in the specific shape, but we know that will encircle the origin</li>
</ul></li>
<li>What happens if there is a pole inside the contour?</li>
</ul>


<img src="img/nyquist_mulitple_pz_map_s_plane_10-pole-contour.png" alt="nyquist_mulitple_pz_map_s_plane_10" style="height: 400px;">


<ul>
<li>As we move along the contour:
<ul>
<li>the pole inside the contour will contribute a total angle of <span class="math inline">\(-2\pi\)</span></li>
<li><strong>but</strong> a pole is at the denominator of <span class="math inline">\(G(s)H(s)\)</span> and hence this contributes a further negative phase: hence the total angle is <span class="math inline">\(2\pi\)</span></li>
<li>we still encircle the origin of the <span class="math inline">\(\Omega\)</span>-plane once but now in the counter-clockwise direction</li>
</ul></li>
</ul>
<hr>
<p>The following Python code, demonstrates how the mapping works for the following cases: - one pole encircled by the contour in the s-plane - one zero encircled by the contour in the s-plane - one pole not-encircled - more complex transfer functions: - no point goes around a pole or a zero - points go around a pole or a zero</p>
<p>Comment and uncomment the various parts to see how points in the s-plane are mapped into points in the <span class="math inline">\(\Omega\)</span>-plane.</p>
<p>And of course, you can change the code below to experiment yourself!</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb8"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="co"># %matplotlib notebook</span></span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a>fig, axs <span class="op">=</span> plt.subplots(<span class="dv">1</span>, <span class="dv">2</span>, figsize<span class="op">=</span>(<span class="dv">10</span>, <span class="dv">10</span>))<span class="op">;</span></span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a>line_0, <span class="op">=</span> axs[<span class="dv">0</span>].plot([])     <span class="co"># A tuple unpacking to unpack the only plot</span></span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a>line_1, <span class="op">=</span> axs[<span class="dv">1</span>].plot([])     <span class="co"># A tuple unpacking to unpack the only plot</span></span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true" tabindex="-1"></a>axs[<span class="dv">0</span>].grid()</span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true" tabindex="-1"></a>axs[<span class="dv">1</span>].grid()</span>
<span id="cb8-7"><a href="#cb8-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-8"><a href="#cb8-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-9"><a href="#cb8-9" aria-hidden="true" tabindex="-1"></a><span class="co">################################</span></span>
<span id="cb8-10"><a href="#cb8-10" aria-hidden="true" tabindex="-1"></a><span class="co"># The first three contours have been demonstrated in class for cases 1, 2, 3 below</span></span>
<span id="cb8-11"><a href="#cb8-11" aria-hidden="true" tabindex="-1"></a><span class="co"># 1. First contour: no point goes around a pole or a zero</span></span>
<span id="cb8-12"><a href="#cb8-12" aria-hidden="true" tabindex="-1"></a><span class="co"># contour = 1</span></span>
<span id="cb8-13"><a href="#cb8-13" aria-hidden="true" tabindex="-1"></a><span class="co"># xoff = -2 #-0.75  # X-offset of the contour</span></span>
<span id="cb8-14"><a href="#cb8-14" aria-hidden="true" tabindex="-1"></a><span class="co"># yoff = 0; #%0.75;  # Y-offset of the contour</span></span>
<span id="cb8-15"><a href="#cb8-15" aria-hidden="true" tabindex="-1"></a><span class="co"># angles = np.linspace(2*np.pi, 0, 160);     # Generate angles around the circle; 160 is tje Number of points around the circular contour</span></span>
<span id="cb8-16"><a href="#cb8-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-17"><a href="#cb8-17" aria-hidden="true" tabindex="-1"></a><span class="co"># 2. Second contour: points go around a zero</span></span>
<span id="cb8-18"><a href="#cb8-18" aria-hidden="true" tabindex="-1"></a><span class="co"># contour = 2</span></span>
<span id="cb8-19"><a href="#cb8-19" aria-hidden="true" tabindex="-1"></a><span class="co"># xoff = 0.5  # X-offset of the contour</span></span>
<span id="cb8-20"><a href="#cb8-20" aria-hidden="true" tabindex="-1"></a><span class="co"># yoff = 0;   # Y-offset of the contour</span></span>
<span id="cb8-21"><a href="#cb8-21" aria-hidden="true" tabindex="-1"></a><span class="co"># angles = np.linspace(np.pi, -np.pi, 160);     # Generate angles around the circle; 160 is tje Number of points around the circular contour</span></span>
<span id="cb8-22"><a href="#cb8-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-23"><a href="#cb8-23" aria-hidden="true" tabindex="-1"></a><span class="co"># 3. Third contour: no point goes around a pole or a zero</span></span>
<span id="cb8-24"><a href="#cb8-24" aria-hidden="true" tabindex="-1"></a><span class="co"># contour = 3</span></span>
<span id="cb8-25"><a href="#cb8-25" aria-hidden="true" tabindex="-1"></a><span class="co"># xoff = -3  # X-offset of the contour</span></span>
<span id="cb8-26"><a href="#cb8-26" aria-hidden="true" tabindex="-1"></a><span class="co"># yoff = 2.5;   # Y-offset of the contour</span></span>
<span id="cb8-27"><a href="#cb8-27" aria-hidden="true" tabindex="-1"></a><span class="co"># angles = np.linspace(np.pi, -np.pi, 160);     # Generate angles around the circle; 160 is tje Number of points around the circular contour</span></span>
<span id="cb8-28"><a href="#cb8-28" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-29"><a href="#cb8-29" aria-hidden="true" tabindex="-1"></a><span class="co">################################</span></span>
<span id="cb8-30"><a href="#cb8-30" aria-hidden="true" tabindex="-1"></a><span class="co"># Contours 4 and 5 have been demonstrated in class for simpler transfer functions, for cases 4, 5 and 6</span></span>
<span id="cb8-31"><a href="#cb8-31" aria-hidden="true" tabindex="-1"></a><span class="co"># 4. Fourth contour: goes around a zero (ex.)</span></span>
<span id="cb8-32"><a href="#cb8-32" aria-hidden="true" tabindex="-1"></a>contour <span class="op">=</span> <span class="dv">4</span></span>
<span id="cb8-33"><a href="#cb8-33" aria-hidden="true" tabindex="-1"></a>xoff <span class="op">=</span> <span class="op">-</span><span class="dv">3</span>   <span class="co"># X-offset of the contour</span></span>
<span id="cb8-34"><a href="#cb8-34" aria-hidden="true" tabindex="-1"></a>yoff <span class="op">=</span> <span class="dv">0</span><span class="op">;</span>   <span class="co"># Y-offset of the contour</span></span>
<span id="cb8-35"><a href="#cb8-35" aria-hidden="true" tabindex="-1"></a>angles <span class="op">=</span> np.linspace(np.pi, <span class="op">-</span>np.pi, <span class="dv">160</span>)<span class="op">;</span>     <span class="co"># Generate angles around the circle; 160 is tje Number of points around the circular contour</span></span>
<span id="cb8-36"><a href="#cb8-36" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-37"><a href="#cb8-37" aria-hidden="true" tabindex="-1"></a><span class="co"># 5. Fifth contour: does not go around a zero (ex.)</span></span>
<span id="cb8-38"><a href="#cb8-38" aria-hidden="true" tabindex="-1"></a><span class="co"># contour = 4</span></span>
<span id="cb8-39"><a href="#cb8-39" aria-hidden="true" tabindex="-1"></a><span class="co"># xoff = 0    # X-offset of the contour</span></span>
<span id="cb8-40"><a href="#cb8-40" aria-hidden="true" tabindex="-1"></a><span class="co"># yoff = 0;   # Y-offset of the contour</span></span>
<span id="cb8-41"><a href="#cb8-41" aria-hidden="true" tabindex="-1"></a><span class="co"># angles = np.linspace(np.pi, -np.pi, 160);     # Generate angles around the circle; 160 is tje Number of points around the circular contour</span></span>
<span id="cb8-42"><a href="#cb8-42" aria-hidden="true" tabindex="-1"></a><span class="co">################################</span></span>
<span id="cb8-43"><a href="#cb8-43" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-44"><a href="#cb8-44" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-45"><a href="#cb8-45" aria-hidden="true" tabindex="-1"></a><span class="co"># define the points in the countour based on the parameters of the countours defined above    </span></span>
<span id="cb8-46"><a href="#cb8-46" aria-hidden="true" tabindex="-1"></a>pt <span class="op">=</span> [np.cos(angles)<span class="op">+</span>xoff, np.sin(angles)<span class="op">+</span>yoff]<span class="op">;</span> </span>
<span id="cb8-47"><a href="#cb8-47" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-48"><a href="#cb8-48" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> animate_plot(<span class="bu">bin</span>):    </span>
<span id="cb8-49"><a href="#cb8-49" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Set 's' to the next point on the contour</span></span>
<span id="cb8-50"><a href="#cb8-50" aria-hidden="true" tabindex="-1"></a>    s <span class="op">=</span> <span class="bu">complex</span>(pt[<span class="dv">0</span>][<span class="bu">bin</span>], pt[<span class="dv">1</span>][<span class="bu">bin</span>])<span class="op">;</span></span>
<span id="cb8-51"><a href="#cb8-51" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-52"><a href="#cb8-52" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Plot the next point on the contour in the s-plane    </span></span>
<span id="cb8-53"><a href="#cb8-53" aria-hidden="true" tabindex="-1"></a>    line_0 <span class="op">=</span> axs[<span class="dv">0</span>].plot(np.real(s), np.imag(s), color<span class="op">=</span><span class="st">'red'</span>, marker<span class="op">=</span><span class="st">'.'</span>, markersize<span class="op">=</span><span class="dv">15</span>)<span class="op">;</span></span>
<span id="cb8-54"><a href="#cb8-54" aria-hidden="true" tabindex="-1"></a>    axs[<span class="dv">0</span>].set_title(<span class="st">'S-plane Contour'</span>)<span class="op">;</span></span>
<span id="cb8-55"><a href="#cb8-55" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-56"><a href="#cb8-56" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Define the system transfer function, uncomment the one you're running</span></span>
<span id="cb8-57"><a href="#cb8-57" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-58"><a href="#cb8-58" aria-hidden="true" tabindex="-1"></a>    <span class="co">##################################################</span></span>
<span id="cb8-59"><a href="#cb8-59" aria-hidden="true" tabindex="-1"></a>    <span class="co"># CASE 1: 2 poles and 1 zero (!)</span></span>
<span id="cb8-60"><a href="#cb8-60" aria-hidden="true" tabindex="-1"></a><span class="co">#     tnf = s/(s**2 + 6*s + 18)</span></span>
<span id="cb8-61"><a href="#cb8-61" aria-hidden="true" tabindex="-1"></a><span class="co">#     axs[0].plot([-3], [3], color='blue', marker='x', markersize=10);</span></span>
<span id="cb8-62"><a href="#cb8-62" aria-hidden="true" tabindex="-1"></a><span class="co">#     axs[0].plot([-3], [-3], color='blue', marker='x', markersize=10);</span></span>
<span id="cb8-63"><a href="#cb8-63" aria-hidden="true" tabindex="-1"></a><span class="co">#     axs[0].plot([0], [0], color='blue', marker='o', markersize=10);</span></span>
<span id="cb8-64"><a href="#cb8-64" aria-hidden="true" tabindex="-1"></a><span class="co">#     axs[0].set_xlim([-5, 2])</span></span>
<span id="cb8-65"><a href="#cb8-65" aria-hidden="true" tabindex="-1"></a><span class="co">#     axs[0].set_ylim([-5, 5])    </span></span>
<span id="cb8-66"><a href="#cb8-66" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb8-67"><a href="#cb8-67" aria-hidden="true" tabindex="-1"></a>    <span class="co"># CASE 2: 2 poles and 2 zeros</span></span>
<span id="cb8-68"><a href="#cb8-68" aria-hidden="true" tabindex="-1"></a>    <span class="co"># tnf = (s**2 + 1.5*s + 0.8125)/((s + 1)*(s + 0.8))</span></span>
<span id="cb8-69"><a href="#cb8-69" aria-hidden="true" tabindex="-1"></a>    <span class="co"># axs[0].plot([-1, -.8] , [0, 0], color='blue', marker='x', markersize=10);</span></span>
<span id="cb8-70"><a href="#cb8-70" aria-hidden="true" tabindex="-1"></a>    <span class="co"># axs[0].plot([-0.75, -0.75], [.5, -.5], color='blue', marker='o', markersize=10);</span></span>
<span id="cb8-71"><a href="#cb8-71" aria-hidden="true" tabindex="-1"></a>    <span class="co"># axs[0].set_xlim([-3, 2])</span></span>
<span id="cb8-72"><a href="#cb8-72" aria-hidden="true" tabindex="-1"></a>    <span class="co"># axs[0].set_ylim([-2, 2]);</span></span>
<span id="cb8-73"><a href="#cb8-73" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-74"><a href="#cb8-74" aria-hidden="true" tabindex="-1"></a>    <span class="co"># CASE 3: 2 poles only</span></span>
<span id="cb8-75"><a href="#cb8-75" aria-hidden="true" tabindex="-1"></a>    <span class="co"># tnf = 1/((s + 1)*(s + 0.8)); </span></span>
<span id="cb8-76"><a href="#cb8-76" aria-hidden="true" tabindex="-1"></a>    <span class="co"># axs[0].plot([-1, -.8] , [0 0], color='blue', marker='x', markersize=10);</span></span>
<span id="cb8-77"><a href="#cb8-77" aria-hidden="true" tabindex="-1"></a>    <span class="co"># axs[0].set_xlim([-3, 2])</span></span>
<span id="cb8-78"><a href="#cb8-78" aria-hidden="true" tabindex="-1"></a>    <span class="co"># axs[0].set_ylim([-2, 2]);</span></span>
<span id="cb8-79"><a href="#cb8-79" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb8-80"><a href="#cb8-80" aria-hidden="true" tabindex="-1"></a>    <span class="co">##################################################</span></span>
<span id="cb8-81"><a href="#cb8-81" aria-hidden="true" tabindex="-1"></a>    <span class="co"># CASE 4: 1 zero </span></span>
<span id="cb8-82"><a href="#cb8-82" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Demonstrated with the fourth contour to show how the mapped contour moves around the origin</span></span>
<span id="cb8-83"><a href="#cb8-83" aria-hidden="true" tabindex="-1"></a>    <span class="co"># when the s-plane contour goes around the zero</span></span>
<span id="cb8-84"><a href="#cb8-84" aria-hidden="true" tabindex="-1"></a>    tnf <span class="op">=</span> (s <span class="op">+</span> <span class="dv">3</span>)<span class="op">;</span> </span>
<span id="cb8-85"><a href="#cb8-85" aria-hidden="true" tabindex="-1"></a>    axs[<span class="dv">0</span>].plot([<span class="op">-</span><span class="dv">3</span>] , [<span class="dv">0</span>], color<span class="op">=</span><span class="st">'blue'</span>, marker<span class="op">=</span><span class="st">'.'</span>, markersize<span class="op">=</span><span class="dv">10</span>)<span class="op">;</span></span>
<span id="cb8-86"><a href="#cb8-86" aria-hidden="true" tabindex="-1"></a>    axs[<span class="dv">0</span>].set_xlim([<span class="op">-</span><span class="dv">4</span>, <span class="dv">2</span>])</span>
<span id="cb8-87"><a href="#cb8-87" aria-hidden="true" tabindex="-1"></a>    axs[<span class="dv">0</span>].set_ylim([<span class="op">-</span><span class="dv">2</span>, <span class="dv">2</span>])<span class="op">;</span>   </span>
<span id="cb8-88"><a href="#cb8-88" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-89"><a href="#cb8-89" aria-hidden="true" tabindex="-1"></a>    <span class="co"># CASE 5: 1 pole </span></span>
<span id="cb8-90"><a href="#cb8-90" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Demonstrated with the fourth contour to show how the mapped contour moves around the origin</span></span>
<span id="cb8-91"><a href="#cb8-91" aria-hidden="true" tabindex="-1"></a>    <span class="co"># when the s-plane contour goes around the pole</span></span>
<span id="cb8-92"><a href="#cb8-92" aria-hidden="true" tabindex="-1"></a><span class="co">#     tnf = 1/((s + 3)); </span></span>
<span id="cb8-93"><a href="#cb8-93" aria-hidden="true" tabindex="-1"></a><span class="co">#     axs[0].plot([-3] , [0], color='blue', marker='x', markersize=10);</span></span>
<span id="cb8-94"><a href="#cb8-94" aria-hidden="true" tabindex="-1"></a><span class="co">#     axs[0].set_xlim([-4, 2])</span></span>
<span id="cb8-95"><a href="#cb8-95" aria-hidden="true" tabindex="-1"></a><span class="co">#     axs[0].set_ylim([-2, 2]);</span></span>
<span id="cb8-96"><a href="#cb8-96" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb8-97"><a href="#cb8-97" aria-hidden="true" tabindex="-1"></a>    <span class="co"># CASE 6: 1 pole</span></span>
<span id="cb8-98"><a href="#cb8-98" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Demonstrated with the fifth contour to show how the mapped contour moves around the origin</span></span>
<span id="cb8-99"><a href="#cb8-99" aria-hidden="true" tabindex="-1"></a>    <span class="co"># when the s-plane contour DOES NOT go around the pole</span></span>
<span id="cb8-100"><a href="#cb8-100" aria-hidden="true" tabindex="-1"></a><span class="co">#     tnf = 1/((s + 1)); </span></span>
<span id="cb8-101"><a href="#cb8-101" aria-hidden="true" tabindex="-1"></a><span class="co">#     axs[0].plot([-1] , [0], color='blue', marker='x', markersize=10);</span></span>
<span id="cb8-102"><a href="#cb8-102" aria-hidden="true" tabindex="-1"></a><span class="co">#     axs[0].set_xlim([-3, 2])</span></span>
<span id="cb8-103"><a href="#cb8-103" aria-hidden="true" tabindex="-1"></a><span class="co">#     axs[0].set_ylim([-2, 2]);</span></span>
<span id="cb8-104"><a href="#cb8-104" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb8-105"><a href="#cb8-105" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb8-106"><a href="#cb8-106" aria-hidden="true" tabindex="-1"></a>    <span class="co">#####</span></span>
<span id="cb8-107"><a href="#cb8-107" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Plot the mapping from the TF in the w-plane    </span></span>
<span id="cb8-108"><a href="#cb8-108" aria-hidden="true" tabindex="-1"></a>    line_1 <span class="op">=</span> axs[<span class="dv">1</span>].plot(np.real(tnf), np.imag(tnf), color<span class="op">=</span><span class="st">'g'</span>, marker<span class="op">=</span><span class="st">'.'</span>, markersize<span class="op">=</span><span class="dv">15</span>)<span class="op">;</span></span>
<span id="cb8-109"><a href="#cb8-109" aria-hidden="true" tabindex="-1"></a>    axs[<span class="dv">1</span>].plot(<span class="dv">0</span>, <span class="dv">0</span>, marker<span class="op">=</span><span class="st">'.'</span>, color<span class="op">=</span><span class="st">'k'</span>, markersize<span class="op">=</span><span class="dv">15</span>)<span class="op">;</span></span>
<span id="cb8-110"><a href="#cb8-110" aria-hidden="true" tabindex="-1"></a>    axs[<span class="dv">1</span>].set_title(<span class="st">'$\Omega$-plane Plot'</span>)<span class="op">;</span></span>
<span id="cb8-111"><a href="#cb8-111" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Sets the axis limits    </span></span>
<span id="cb8-112"><a href="#cb8-112" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> contour <span class="op">==</span> <span class="dv">1</span> <span class="kw">or</span> contour <span class="op">==</span> <span class="dv">2</span>:</span>
<span id="cb8-113"><a href="#cb8-113" aria-hidden="true" tabindex="-1"></a>        axs[<span class="dv">1</span>].set_xlim([<span class="op">-</span><span class="fl">.5</span>, <span class="fl">.5</span>])</span>
<span id="cb8-114"><a href="#cb8-114" aria-hidden="true" tabindex="-1"></a>        axs[<span class="dv">1</span>].set_ylim([<span class="op">-</span><span class="fl">.5</span>, <span class="fl">.5</span>])<span class="op">;</span>    </span>
<span id="cb8-115"><a href="#cb8-115" aria-hidden="true" tabindex="-1"></a>    <span class="cf">elif</span> contour <span class="op">==</span> <span class="dv">4</span> <span class="kw">or</span> contour <span class="op">==</span> <span class="dv">5</span>:</span>
<span id="cb8-116"><a href="#cb8-116" aria-hidden="true" tabindex="-1"></a>        axs[<span class="dv">1</span>].set_xlim([<span class="op">-</span><span class="dv">2</span>, <span class="dv">4</span>])<span class="op">;</span></span>
<span id="cb8-117"><a href="#cb8-117" aria-hidden="true" tabindex="-1"></a>        axs[<span class="dv">1</span>].set_ylim([<span class="op">-</span><span class="dv">3</span>, <span class="dv">2</span>])<span class="op">;</span></span>
<span id="cb8-118"><a href="#cb8-118" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span>:</span>
<span id="cb8-119"><a href="#cb8-119" aria-hidden="true" tabindex="-1"></a>        axs[<span class="dv">1</span>].set_xlim([<span class="op">-</span><span class="dv">3</span>, <span class="dv">2</span>])</span>
<span id="cb8-120"><a href="#cb8-120" aria-hidden="true" tabindex="-1"></a>        axs[<span class="dv">1</span>].set_ylim([<span class="op">-</span><span class="dv">3</span>, <span class="dv">2</span>])<span class="op">;</span>       </span>
<span id="cb8-121"><a href="#cb8-121" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-122"><a href="#cb8-122" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> line_0, line_1</span>
<span id="cb8-123"><a href="#cb8-123" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-124"><a href="#cb8-124" aria-hidden="true" tabindex="-1"></a>anim <span class="op">=</span> FuncAnimation(fig, animate_plot, frames<span class="op">=</span><span class="bu">len</span>(angles), interval<span class="op">=</span><span class="dv">20</span>)</span>
<span id="cb8-125"><a href="#cb8-125" aria-hidden="true" tabindex="-1"></a>anim<span class="op">;</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<script type="application/javascript">
/* Put everything inside the global mpl namespace */
/* global mpl */
window.mpl = {};

mpl.get_websocket_type = function () {
    if (typeof WebSocket !== 'undefined') {
        return WebSocket;
    } else if (typeof MozWebSocket !== 'undefined') {
        return MozWebSocket;
    } else {
        alert(
            'Your browser does not have WebSocket support. ' +
                'Please try Chrome, Safari or Firefox ‚â• 6. ' +
                'Firefox 4 and 5 are also supported but you ' +
                'have to enable WebSockets in about:config.'
        );
    }
};

mpl.figure = function (figure_id, websocket, ondownload, parent_element) {
    this.id = figure_id;

    this.ws = websocket;

    this.supports_binary = this.ws.binaryType !== undefined;

    if (!this.supports_binary) {
        var warnings = document.getElementById('mpl-warnings');
        if (warnings) {
            warnings.style.display = 'block';
            warnings.textContent =
                'This browser does not support binary websocket messages. ' +
                'Performance may be slow.';
        }
    }

    this.imageObj = new Image();

    this.context = undefined;
    this.message = undefined;
    this.canvas = undefined;
    this.rubberband_canvas = undefined;
    this.rubberband_context = undefined;
    this.format_dropdown = undefined;

    this.image_mode = 'full';

    this.root = document.createElement('div');
    this.root.setAttribute('style', 'display: inline-block');
    this._root_extra_style(this.root);

    parent_element.appendChild(this.root);

    this._init_header(this);
    this._init_canvas(this);
    this._init_toolbar(this);

    var fig = this;

    this.waiting = false;

    this.ws.onopen = function () {
        fig.send_message('supports_binary', { value: fig.supports_binary });
        fig.send_message('send_image_mode', {});
        if (fig.ratio !== 1) {
            fig.send_message('set_device_pixel_ratio', {
                device_pixel_ratio: fig.ratio,
            });
        }
        fig.send_message('refresh', {});
    };

    this.imageObj.onload = function () {
        if (fig.image_mode === 'full') {
            // Full images could contain transparency (where diff images
            // almost always do), so we need to clear the canvas so that
            // there is no ghosting.
            fig.context.clearRect(0, 0, fig.canvas.width, fig.canvas.height);
        }
        fig.context.drawImage(fig.imageObj, 0, 0);
    };

    this.imageObj.onunload = function () {
        fig.ws.close();
    };

    this.ws.onmessage = this._make_on_message_function(this);

    this.ondownload = ondownload;
};

mpl.figure.prototype._init_header = function () {
    var titlebar = document.createElement('div');
    titlebar.classList =
        'ui-dialog-titlebar ui-widget-header ui-corner-all ui-helper-clearfix';
    var titletext = document.createElement('div');
    titletext.classList = 'ui-dialog-title';
    titletext.setAttribute(
        'style',
        'width: 100%; text-align: center; padding: 3px;'
    );
    titlebar.appendChild(titletext);
    this.root.appendChild(titlebar);
    this.header = titletext;
};

mpl.figure.prototype._canvas_extra_style = function (_canvas_div) {};

mpl.figure.prototype._root_extra_style = function (_canvas_div) {};

mpl.figure.prototype._init_canvas = function () {
    var fig = this;

    var canvas_div = (this.canvas_div = document.createElement('div'));
    canvas_div.setAttribute(
        'style',
        'border: 1px solid #ddd;' +
            'box-sizing: content-box;' +
            'clear: both;' +
            'min-height: 1px;' +
            'min-width: 1px;' +
            'outline: 0;' +
            'overflow: hidden;' +
            'position: relative;' +
            'resize: both;'
    );

    function on_keyboard_event_closure(name) {
        return function (event) {
            return fig.key_event(event, name);
        };
    }

    canvas_div.addEventListener(
        'keydown',
        on_keyboard_event_closure('key_press')
    );
    canvas_div.addEventListener(
        'keyup',
        on_keyboard_event_closure('key_release')
    );

    this._canvas_extra_style(canvas_div);
    this.root.appendChild(canvas_div);

    var canvas = (this.canvas = document.createElement('canvas'));
    canvas.classList.add('mpl-canvas');
    canvas.setAttribute('style', 'box-sizing: content-box;');

    this.context = canvas.getContext('2d');

    var backingStore =
        this.context.backingStorePixelRatio ||
        this.context.webkitBackingStorePixelRatio ||
        this.context.mozBackingStorePixelRatio ||
        this.context.msBackingStorePixelRatio ||
        this.context.oBackingStorePixelRatio ||
        this.context.backingStorePixelRatio ||
        1;

    this.ratio = (window.devicePixelRatio || 1) / backingStore;

    var rubberband_canvas = (this.rubberband_canvas = document.createElement(
        'canvas'
    ));
    rubberband_canvas.setAttribute(
        'style',
        'box-sizing: content-box; position: absolute; left: 0; top: 0; z-index: 1;'
    );

    // Apply a ponyfill if ResizeObserver is not implemented by browser.
    if (this.ResizeObserver === undefined) {
        if (window.ResizeObserver !== undefined) {
            this.ResizeObserver = window.ResizeObserver;
        } else {
            var obs = _JSXTOOLS_RESIZE_OBSERVER({});
            this.ResizeObserver = obs.ResizeObserver;
        }
    }

    this.resizeObserverInstance = new this.ResizeObserver(function (entries) {
        var nentries = entries.length;
        for (var i = 0; i < nentries; i++) {
            var entry = entries[i];
            var width, height;
            if (entry.contentBoxSize) {
                if (entry.contentBoxSize instanceof Array) {
                    // Chrome 84 implements new version of spec.
                    width = entry.contentBoxSize[0].inlineSize;
                    height = entry.contentBoxSize[0].blockSize;
                } else {
                    // Firefox implements old version of spec.
                    width = entry.contentBoxSize.inlineSize;
                    height = entry.contentBoxSize.blockSize;
                }
            } else {
                // Chrome <84 implements even older version of spec.
                width = entry.contentRect.width;
                height = entry.contentRect.height;
            }

            // Keep the size of the canvas and rubber band canvas in sync with
            // the canvas container.
            if (entry.devicePixelContentBoxSize) {
                // Chrome 84 implements new version of spec.
                canvas.setAttribute(
                    'width',
                    entry.devicePixelContentBoxSize[0].inlineSize
                );
                canvas.setAttribute(
                    'height',
                    entry.devicePixelContentBoxSize[0].blockSize
                );
            } else {
                canvas.setAttribute('width', width * fig.ratio);
                canvas.setAttribute('height', height * fig.ratio);
            }
            canvas.setAttribute(
                'style',
                'width: ' + width + 'px; height: ' + height + 'px;'
            );

            rubberband_canvas.setAttribute('width', width);
            rubberband_canvas.setAttribute('height', height);

            // And update the size in Python. We ignore the initial 0/0 size
            // that occurs as the element is placed into the DOM, which should
            // otherwise not happen due to the minimum size styling.
            if (fig.ws.readyState == 1 && width != 0 && height != 0) {
                fig.request_resize(width, height);
            }
        }
    });
    this.resizeObserverInstance.observe(canvas_div);

    function on_mouse_event_closure(name) {
        return function (event) {
            return fig.mouse_event(event, name);
        };
    }

    rubberband_canvas.addEventListener(
        'mousedown',
        on_mouse_event_closure('button_press')
    );
    rubberband_canvas.addEventListener(
        'mouseup',
        on_mouse_event_closure('button_release')
    );
    rubberband_canvas.addEventListener(
        'dblclick',
        on_mouse_event_closure('dblclick')
    );
    // Throttle sequential mouse events to 1 every 20ms.
    rubberband_canvas.addEventListener(
        'mousemove',
        on_mouse_event_closure('motion_notify')
    );

    rubberband_canvas.addEventListener(
        'mouseenter',
        on_mouse_event_closure('figure_enter')
    );
    rubberband_canvas.addEventListener(
        'mouseleave',
        on_mouse_event_closure('figure_leave')
    );

    canvas_div.addEventListener('wheel', function (event) {
        if (event.deltaY < 0) {
            event.step = 1;
        } else {
            event.step = -1;
        }
        on_mouse_event_closure('scroll')(event);
    });

    canvas_div.appendChild(canvas);
    canvas_div.appendChild(rubberband_canvas);

    this.rubberband_context = rubberband_canvas.getContext('2d');
    this.rubberband_context.strokeStyle = '#000000';

    this._resize_canvas = function (width, height, forward) {
        if (forward) {
            canvas_div.style.width = width + 'px';
            canvas_div.style.height = height + 'px';
        }
    };

    // Disable right mouse context menu.
    this.rubberband_canvas.addEventListener('contextmenu', function (_e) {
        event.preventDefault();
        return false;
    });

    function set_focus() {
        canvas.focus();
        canvas_div.focus();
    }

    window.setTimeout(set_focus, 100);
};

mpl.figure.prototype._init_toolbar = function () {
    var fig = this;

    var toolbar = document.createElement('div');
    toolbar.classList = 'mpl-toolbar';
    this.root.appendChild(toolbar);

    function on_click_closure(name) {
        return function (_event) {
            return fig.toolbar_button_onclick(name);
        };
    }

    function on_mouseover_closure(tooltip) {
        return function (event) {
            if (!event.currentTarget.disabled) {
                return fig.toolbar_button_onmouseover(tooltip);
            }
        };
    }

    fig.buttons = {};
    var buttonGroup = document.createElement('div');
    buttonGroup.classList = 'mpl-button-group';
    for (var toolbar_ind in mpl.toolbar_items) {
        var name = mpl.toolbar_items[toolbar_ind][0];
        var tooltip = mpl.toolbar_items[toolbar_ind][1];
        var image = mpl.toolbar_items[toolbar_ind][2];
        var method_name = mpl.toolbar_items[toolbar_ind][3];

        if (!name) {
            /* Instead of a spacer, we start a new button group. */
            if (buttonGroup.hasChildNodes()) {
                toolbar.appendChild(buttonGroup);
            }
            buttonGroup = document.createElement('div');
            buttonGroup.classList = 'mpl-button-group';
            continue;
        }

        var button = (fig.buttons[name] = document.createElement('button'));
        button.classList = 'mpl-widget';
        button.setAttribute('role', 'button');
        button.setAttribute('aria-disabled', 'false');
        button.addEventListener('click', on_click_closure(method_name));
        button.addEventListener('mouseover', on_mouseover_closure(tooltip));

        var icon_img = document.createElement('img');
        icon_img.src = '_images/' + image + '.png';
        icon_img.srcset = '_images/' + image + '_large.png 2x';
        icon_img.alt = tooltip;
        button.appendChild(icon_img);

        buttonGroup.appendChild(button);
    }

    if (buttonGroup.hasChildNodes()) {
        toolbar.appendChild(buttonGroup);
    }

    var fmt_picker = document.createElement('select');
    fmt_picker.classList = 'mpl-widget';
    toolbar.appendChild(fmt_picker);
    this.format_dropdown = fmt_picker;

    for (var ind in mpl.extensions) {
        var fmt = mpl.extensions[ind];
        var option = document.createElement('option');
        option.selected = fmt === mpl.default_extension;
        option.innerHTML = fmt;
        fmt_picker.appendChild(option);
    }

    var status_bar = document.createElement('span');
    status_bar.classList = 'mpl-message';
    toolbar.appendChild(status_bar);
    this.message = status_bar;
};

mpl.figure.prototype.request_resize = function (x_pixels, y_pixels) {
    // Request matplotlib to resize the figure. Matplotlib will then trigger a resize in the client,
    // which will in turn request a refresh of the image.
    this.send_message('resize', { width: x_pixels, height: y_pixels });
};

mpl.figure.prototype.send_message = function (type, properties) {
    properties['type'] = type;
    properties['figure_id'] = this.id;
    this.ws.send(JSON.stringify(properties));
};

mpl.figure.prototype.send_draw_message = function () {
    if (!this.waiting) {
        this.waiting = true;
        this.ws.send(JSON.stringify({ type: 'draw', figure_id: this.id }));
    }
};

mpl.figure.prototype.handle_save = function (fig, _msg) {
    var format_dropdown = fig.format_dropdown;
    var format = format_dropdown.options[format_dropdown.selectedIndex].value;
    fig.ondownload(fig, format);
};

mpl.figure.prototype.handle_resize = function (fig, msg) {
    var size = msg['size'];
    if (size[0] !== fig.canvas.width || size[1] !== fig.canvas.height) {
        fig._resize_canvas(size[0], size[1], msg['forward']);
        fig.send_message('refresh', {});
    }
};

mpl.figure.prototype.handle_rubberband = function (fig, msg) {
    var x0 = msg['x0'] / fig.ratio;
    var y0 = (fig.canvas.height - msg['y0']) / fig.ratio;
    var x1 = msg['x1'] / fig.ratio;
    var y1 = (fig.canvas.height - msg['y1']) / fig.ratio;
    x0 = Math.floor(x0) + 0.5;
    y0 = Math.floor(y0) + 0.5;
    x1 = Math.floor(x1) + 0.5;
    y1 = Math.floor(y1) + 0.5;
    var min_x = Math.min(x0, x1);
    var min_y = Math.min(y0, y1);
    var width = Math.abs(x1 - x0);
    var height = Math.abs(y1 - y0);

    fig.rubberband_context.clearRect(
        0,
        0,
        fig.canvas.width / fig.ratio,
        fig.canvas.height / fig.ratio
    );

    fig.rubberband_context.strokeRect(min_x, min_y, width, height);
};

mpl.figure.prototype.handle_figure_label = function (fig, msg) {
    // Updates the figure title.
    fig.header.textContent = msg['label'];
};

mpl.figure.prototype.handle_cursor = function (fig, msg) {
    fig.rubberband_canvas.style.cursor = msg['cursor'];
};

mpl.figure.prototype.handle_message = function (fig, msg) {
    fig.message.textContent = msg['message'];
};

mpl.figure.prototype.handle_draw = function (fig, _msg) {
    // Request the server to send over a new figure.
    fig.send_draw_message();
};

mpl.figure.prototype.handle_image_mode = function (fig, msg) {
    fig.image_mode = msg['mode'];
};

mpl.figure.prototype.handle_history_buttons = function (fig, msg) {
    for (var key in msg) {
        if (!(key in fig.buttons)) {
            continue;
        }
        fig.buttons[key].disabled = !msg[key];
        fig.buttons[key].setAttribute('aria-disabled', !msg[key]);
    }
};

mpl.figure.prototype.handle_navigate_mode = function (fig, msg) {
    if (msg['mode'] === 'PAN') {
        fig.buttons['Pan'].classList.add('active');
        fig.buttons['Zoom'].classList.remove('active');
    } else if (msg['mode'] === 'ZOOM') {
        fig.buttons['Pan'].classList.remove('active');
        fig.buttons['Zoom'].classList.add('active');
    } else {
        fig.buttons['Pan'].classList.remove('active');
        fig.buttons['Zoom'].classList.remove('active');
    }
};

mpl.figure.prototype.updated_canvas_event = function () {
    // Called whenever the canvas gets updated.
    this.send_message('ack', {});
};

// A function to construct a web socket function for onmessage handling.
// Called in the figure constructor.
mpl.figure.prototype._make_on_message_function = function (fig) {
    return function socket_on_message(evt) {
        if (evt.data instanceof Blob) {
            var img = evt.data;
            if (img.type !== 'image/png') {
                /* FIXME: We get "Resource interpreted as Image but
                 * transferred with MIME type text/plain:" errors on
                 * Chrome.  But how to set the MIME type?  It doesn't seem
                 * to be part of the websocket stream */
                img.type = 'image/png';
            }

            /* Free the memory for the previous frames */
            if (fig.imageObj.src) {
                (window.URL || window.webkitURL).revokeObjectURL(
                    fig.imageObj.src
                );
            }

            fig.imageObj.src = (window.URL || window.webkitURL).createObjectURL(
                img
            );
            fig.updated_canvas_event();
            fig.waiting = false;
            return;
        } else if (
            typeof evt.data === 'string' &&
            evt.data.slice(0, 21) === 'data:image/png;base64'
        ) {
            fig.imageObj.src = evt.data;
            fig.updated_canvas_event();
            fig.waiting = false;
            return;
        }

        var msg = JSON.parse(evt.data);
        var msg_type = msg['type'];

        // Call the  "handle_{type}" callback, which takes
        // the figure and JSON message as its only arguments.
        try {
            var callback = fig['handle_' + msg_type];
        } catch (e) {
            console.log(
                "No handler for the '" + msg_type + "' message type: ",
                msg
            );
            return;
        }

        if (callback) {
            try {
                // console.log("Handling '" + msg_type + "' message: ", msg);
                callback(fig, msg);
            } catch (e) {
                console.log(
                    "Exception inside the 'handler_" + msg_type + "' callback:",
                    e,
                    e.stack,
                    msg
                );
            }
        }
    };
};

// from https://stackoverflow.com/questions/1114465/getting-mouse-location-in-canvas
mpl.findpos = function (e) {
    //this section is from http://www.quirksmode.org/js/events_properties.html
    var targ;
    if (!e) {
        e = window.event;
    }
    if (e.target) {
        targ = e.target;
    } else if (e.srcElement) {
        targ = e.srcElement;
    }
    if (targ.nodeType === 3) {
        // defeat Safari bug
        targ = targ.parentNode;
    }

    // pageX,Y are the mouse positions relative to the document
    var boundingRect = targ.getBoundingClientRect();
    var x = e.pageX - (boundingRect.left + document.body.scrollLeft);
    var y = e.pageY - (boundingRect.top + document.body.scrollTop);

    return { x: x, y: y };
};

/*
 * return a copy of an object with only non-object keys
 * we need this to avoid circular references
 * https://stackoverflow.com/a/24161582/3208463
 */
function simpleKeys(original) {
    return Object.keys(original).reduce(function (obj, key) {
        if (typeof original[key] !== 'object') {
            obj[key] = original[key];
        }
        return obj;
    }, {});
}

mpl.figure.prototype.mouse_event = function (event, name) {
    var canvas_pos = mpl.findpos(event);

    if (name === 'button_press') {
        this.canvas.focus();
        this.canvas_div.focus();
    }

    var x = canvas_pos.x * this.ratio;
    var y = canvas_pos.y * this.ratio;

    this.send_message(name, {
        x: x,
        y: y,
        button: event.button,
        step: event.step,
        guiEvent: simpleKeys(event),
    });

    /* This prevents the web browser from automatically changing to
     * the text insertion cursor when the button is pressed.  We want
     * to control all of the cursor setting manually through the
     * 'cursor' event from matplotlib */
    event.preventDefault();
    return false;
};

mpl.figure.prototype._key_event_extra = function (_event, _name) {
    // Handle any extra behaviour associated with a key event
};

mpl.figure.prototype.key_event = function (event, name) {
    // Prevent repeat events
    if (name === 'key_press') {
        if (event.key === this._key) {
            return;
        } else {
            this._key = event.key;
        }
    }
    if (name === 'key_release') {
        this._key = null;
    }

    var value = '';
    if (event.ctrlKey && event.key !== 'Control') {
        value += 'ctrl+';
    }
    else if (event.altKey && event.key !== 'Alt') {
        value += 'alt+';
    }
    else if (event.shiftKey && event.key !== 'Shift') {
        value += 'shift+';
    }

    value += 'k' + event.key;

    this._key_event_extra(event, name);

    this.send_message(name, { key: value, guiEvent: simpleKeys(event) });
    return false;
};

mpl.figure.prototype.toolbar_button_onclick = function (name) {
    if (name === 'download') {
        this.handle_save(this, null);
    } else {
        this.send_message('toolbar_button', { name: name });
    }
};

mpl.figure.prototype.toolbar_button_onmouseover = function (tooltip) {
    this.message.textContent = tooltip;
};

///////////////// REMAINING CONTENT GENERATED BY embed_js.py /////////////////
// prettier-ignore
var _JSXTOOLS_RESIZE_OBSERVER=function(A){var t,i=new WeakMap,n=new WeakMap,a=new WeakMap,r=new WeakMap,o=new Set;function s(e){if(!(this instanceof s))throw new TypeError("Constructor requires 'new' operator");i.set(this,e)}function h(){throw new TypeError("Function is not a constructor")}function c(e,t,i,n){e=0 in arguments?Number(arguments[0]):0,t=1 in arguments?Number(arguments[1]):0,i=2 in arguments?Number(arguments[2]):0,n=3 in arguments?Number(arguments[3]):0,this.right=(this.x=this.left=e)+(this.width=i),this.bottom=(this.y=this.top=t)+(this.height=n),Object.freeze(this)}function d(){t=requestAnimationFrame(d);var s=new WeakMap,p=new Set;o.forEach((function(t){r.get(t).forEach((function(i){var r=t instanceof window.SVGElement,o=a.get(t),d=r?0:parseFloat(o.paddingTop),f=r?0:parseFloat(o.paddingRight),l=r?0:parseFloat(o.paddingBottom),u=r?0:parseFloat(o.paddingLeft),g=r?0:parseFloat(o.borderTopWidth),m=r?0:parseFloat(o.borderRightWidth),w=r?0:parseFloat(o.borderBottomWidth),b=u+f,F=d+l,v=(r?0:parseFloat(o.borderLeftWidth))+m,W=g+w,y=r?0:t.offsetHeight-W-t.clientHeight,E=r?0:t.offsetWidth-v-t.clientWidth,R=b+v,z=F+W,M=r?t.width:parseFloat(o.width)-R-E,O=r?t.height:parseFloat(o.height)-z-y;if(n.has(t)){var k=n.get(t);if(k[0]===M&&k[1]===O)return}n.set(t,[M,O]);var S=Object.create(h.prototype);S.target=t,S.contentRect=new c(u,d,M,O),s.has(i)||(s.set(i,[]),p.add(i)),s.get(i).push(S)}))})),p.forEach((function(e){i.get(e).call(e,s.get(e),e)}))}return s.prototype.observe=function(i){if(i instanceof window.Element){r.has(i)||(r.set(i,new Set),o.add(i),a.set(i,window.getComputedStyle(i)));var n=r.get(i);n.has(this)||n.add(this),cancelAnimationFrame(t),t=requestAnimationFrame(d)}},s.prototype.unobserve=function(i){if(i instanceof window.Element&&r.has(i)){var n=r.get(i);n.has(this)&&(n.delete(this),n.size||(r.delete(i),o.delete(i))),n.size||r.delete(i),o.size||cancelAnimationFrame(t)}},A.DOMRectReadOnly=c,A.ResizeObserver=s,A.ResizeObserverEntry=h,A}; // eslint-disable-line
mpl.toolbar_items = [["Home", "Reset original view", "fa fa-home icon-home", "home"], ["Back", "Back to previous view", "fa fa-arrow-left icon-arrow-left", "back"], ["Forward", "Forward to next view", "fa fa-arrow-right icon-arrow-right", "forward"], ["", "", "", ""], ["Pan", "Left button pans, Right button zooms\nx/y fixes axis, CTRL fixes aspect", "fa fa-arrows icon-move", "pan"], ["Zoom", "Zoom to rectangle\nx/y fixes axis", "fa fa-square-o icon-check-empty", "zoom"], ["", "", "", ""], ["Download", "Download plot", "fa fa-floppy-o icon-save", "download"]];

mpl.extensions = ["eps", "jpeg", "pgf", "pdf", "png", "ps", "raw", "svg", "tif"];

mpl.default_extension = "png";/* global mpl */

var comm_websocket_adapter = function (comm) {
    // Create a "websocket"-like object which calls the given IPython comm
    // object with the appropriate methods. Currently this is a non binary
    // socket, so there is still some room for performance tuning.
    var ws = {};

    ws.binaryType = comm.kernel.ws.binaryType;
    ws.readyState = comm.kernel.ws.readyState;
    function updateReadyState(_event) {
        if (comm.kernel.ws) {
            ws.readyState = comm.kernel.ws.readyState;
        } else {
            ws.readyState = 3; // Closed state.
        }
    }
    comm.kernel.ws.addEventListener('open', updateReadyState);
    comm.kernel.ws.addEventListener('close', updateReadyState);
    comm.kernel.ws.addEventListener('error', updateReadyState);

    ws.close = function () {
        comm.close();
    };
    ws.send = function (m) {
        //console.log('sending', m);
        comm.send(m);
    };
    // Register the callback with on_msg.
    comm.on_msg(function (msg) {
        //console.log('receiving', msg['content']['data'], msg);
        var data = msg['content']['data'];
        if (data['blob'] !== undefined) {
            data = {
                data: new Blob(msg['buffers'], { type: data['blob'] }),
            };
        }
        // Pass the mpl event to the overridden (by mpl) onmessage function.
        ws.onmessage(data);
    });
    return ws;
};

mpl.mpl_figure_comm = function (comm, msg) {
    // This is the function which gets called when the mpl process
    // starts-up an IPython Comm through the "matplotlib" channel.

    var id = msg.content.data.id;
    // Get hold of the div created by the display call when the Comm
    // socket was opened in Python.
    var element = document.getElementById(id);
    var ws_proxy = comm_websocket_adapter(comm);

    function ondownload(figure, _format) {
        window.open(figure.canvas.toDataURL());
    }

    var fig = new mpl.figure(id, ws_proxy, ondownload, element);

    // Call onopen now - mpl needs it, as it is assuming we've passed it a real
    // web socket which is closed, not our websocket->open comm proxy.
    ws_proxy.onopen();

    fig.parent_element = element;
    fig.cell_info = mpl.find_output_cell("<div id='" + id + "'></div>");
    if (!fig.cell_info) {
        console.error('Failed to find cell for figure', id, fig);
        return;
    }
    fig.cell_info[0].output_area.element.on(
        'cleared',
        { fig: fig },
        fig._remove_fig_handler
    );
};

mpl.figure.prototype.handle_close = function (fig, msg) {
    var width = fig.canvas.width / fig.ratio;
    fig.cell_info[0].output_area.element.off(
        'cleared',
        fig._remove_fig_handler
    );
    fig.resizeObserverInstance.unobserve(fig.canvas_div);

    // Update the output cell to use the data from the current canvas.
    fig.push_to_output();
    var dataURL = fig.canvas.toDataURL();
    // Re-enable the keyboard manager in IPython - without this line, in FF,
    // the notebook keyboard shortcuts fail.
    IPython.keyboard_manager.enable();
    fig.parent_element.innerHTML =
        '<img src="' + dataURL + '" width="' + width + '">';
    fig.close_ws(fig, msg);
};

mpl.figure.prototype.close_ws = function (fig, msg) {
    fig.send_message('closing', msg);
    // fig.ws.close()
};

mpl.figure.prototype.push_to_output = function (_remove_interactive) {
    // Turn the data on the canvas into data in the output cell.
    var width = this.canvas.width / this.ratio;
    var dataURL = this.canvas.toDataURL();
    this.cell_info[1]['text/html'] =
        '<img src="' + dataURL + '" width="' + width + '">';
};

mpl.figure.prototype.updated_canvas_event = function () {
    // Tell IPython that the notebook contents must change.
    IPython.notebook.set_dirty(true);
    this.send_message('ack', {});
    var fig = this;
    // Wait a second, then push the new image to the DOM so
    // that it is saved nicely (might be nice to debounce this).
    setTimeout(function () {
        fig.push_to_output();
    }, 1000);
};

mpl.figure.prototype._init_toolbar = function () {
    var fig = this;

    var toolbar = document.createElement('div');
    toolbar.classList = 'btn-toolbar';
    this.root.appendChild(toolbar);

    function on_click_closure(name) {
        return function (_event) {
            return fig.toolbar_button_onclick(name);
        };
    }

    function on_mouseover_closure(tooltip) {
        return function (event) {
            if (!event.currentTarget.disabled) {
                return fig.toolbar_button_onmouseover(tooltip);
            }
        };
    }

    fig.buttons = {};
    var buttonGroup = document.createElement('div');
    buttonGroup.classList = 'btn-group';
    var button;
    for (var toolbar_ind in mpl.toolbar_items) {
        var name = mpl.toolbar_items[toolbar_ind][0];
        var tooltip = mpl.toolbar_items[toolbar_ind][1];
        var image = mpl.toolbar_items[toolbar_ind][2];
        var method_name = mpl.toolbar_items[toolbar_ind][3];

        if (!name) {
            /* Instead of a spacer, we start a new button group. */
            if (buttonGroup.hasChildNodes()) {
                toolbar.appendChild(buttonGroup);
            }
            buttonGroup = document.createElement('div');
            buttonGroup.classList = 'btn-group';
            continue;
        }

        button = fig.buttons[name] = document.createElement('button');
        button.classList = 'btn btn-default';
        button.href = '#';
        button.title = name;
        button.innerHTML = '<i class="fa ' + image + ' fa-lg"></i>';
        button.addEventListener('click', on_click_closure(method_name));
        button.addEventListener('mouseover', on_mouseover_closure(tooltip));
        buttonGroup.appendChild(button);
    }

    if (buttonGroup.hasChildNodes()) {
        toolbar.appendChild(buttonGroup);
    }

    // Add the status bar.
    var status_bar = document.createElement('span');
    status_bar.classList = 'mpl-message pull-right';
    toolbar.appendChild(status_bar);
    this.message = status_bar;

    // Add the close button to the window.
    var buttongrp = document.createElement('div');
    buttongrp.classList = 'btn-group inline pull-right';
    button = document.createElement('button');
    button.classList = 'btn btn-mini btn-primary';
    button.href = '#';
    button.title = 'Stop Interaction';
    button.innerHTML = '<i class="fa fa-power-off icon-remove icon-large"></i>';
    button.addEventListener('click', function (_evt) {
        fig.handle_close(fig, {});
    });
    button.addEventListener(
        'mouseover',
        on_mouseover_closure('Stop Interaction')
    );
    buttongrp.appendChild(button);
    var titlebar = this.root.querySelector('.ui-dialog-titlebar');
    titlebar.insertBefore(buttongrp, titlebar.firstChild);
};

mpl.figure.prototype._remove_fig_handler = function (event) {
    var fig = event.data.fig;
    if (event.target !== this) {
        // Ignore bubbled events from children.
        return;
    }
    fig.close_ws(fig, {});
};

mpl.figure.prototype._root_extra_style = function (el) {
    el.style.boxSizing = 'content-box'; // override notebook setting of border-box.
};

mpl.figure.prototype._canvas_extra_style = function (el) {
    // this is important to make the div 'focusable
    el.setAttribute('tabindex', 0);
    // reach out to IPython and tell the keyboard manager to turn it's self
    // off when our div gets focus

    // location in version 3
    if (IPython.notebook.keyboard_manager) {
        IPython.notebook.keyboard_manager.register_events(el);
    } else {
        // location in version 2
        IPython.keyboard_manager.register_events(el);
    }
};

mpl.figure.prototype._key_event_extra = function (event, _name) {
    // Check for shift+enter
    if (event.shiftKey && event.which === 13) {
        this.canvas_div.blur();
        // select the cell after this one
        var index = IPython.notebook.find_cell_index(this.cell_info[0]);
        IPython.notebook.select(index + 1);
    }
};

mpl.figure.prototype.handle_save = function (fig, _msg) {
    fig.ondownload(fig, null);
};

mpl.find_output_cell = function (html_output) {
    // Return the cell and output element which can be found *uniquely* in the notebook.
    // Note - this is a bit hacky, but it is done because the "notebook_saving.Notebook"
    // IPython event is triggered only after the cells have been serialised, which for
    // our purposes (turning an active figure into a static one), is too late.
    var cells = IPython.notebook.get_cells();
    var ncells = cells.length;
    for (var i = 0; i < ncells; i++) {
        var cell = cells[i];
        if (cell.cell_type === 'code') {
            for (var j = 0; j < cell.output_area.outputs.length; j++) {
                var data = cell.output_area.outputs[j];
                if (data.data) {
                    // IPython >= 3 moved mimebundle to data attribute of output
                    data = data.data;
                }
                if (data['text/html'] === html_output) {
                    return [cell, data, j];
                }
            }
        }
    }
};

// Register the function which deals with the matplotlib target/channel.
// The kernel may be null if the page has been refreshed.
if (IPython.notebook.kernel !== null) {
    IPython.notebook.kernel.comm_manager.register_target(
        'matplotlib',
        mpl.mpl_figure_comm
    );
}

</script>
</div>
<div class="cell-output cell-output-display">
<img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAA+gAAAPoCAYAAABNo9TkAAAAAXNSR0IArs4c6QAAAERlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAA6ABAAMAAAABAAEAAKACAAQAAAABAAAD6KADAAQAAAABAAAD6AAAAAAYK4+nAABAAElEQVR4AezdCZwU5Zn48WdgOGZ28OIaiQhoIhFRUcxGJAqYAJHEVTHZ7G4QQxIS1hhD+LuJqMlGoyEfdQka48VKFEl2zcYzK7vCJhwajIkIIp7RcKg4cnjAyDEM9L+eMjX09PTxvn3VW1W/ymcy3VVPV73v923pebreoyblbcKGAAIIIIAAAggggAACCCCAAAKhCnQK9epcHAEEEEAAAQQQQAABBBBAAAEEfAESdN4ICCCAAAIIIIAAAggggAACCDggQILuQCNQBAQQQAABBBBAAAEEEEAAAQRI0HkPIIAAAggggAACCCCAAAIIIOCAAAm6A41AERBAAAEEEEAAAQQQQAABBBAgQec9gAACCCCAAAIIIIAAAggggIADAiToDjQCRUAAAQQQQAABBBBAAAEEEECABJ33AAIIIIAAAggggAACCCCAAAIOCJCgO9AIFAEBBBBAAAEEEEAAAQQQQAABEnTeAwgggAACCCCAAAIIIIAAAgg4IECC7kAjUAQEEEAAAQQQQAABBBBAAAEESNB5DyCAAAIIIIAAAggggAACCCDggAAJugONQBEQQAABBBBAAAEEEEAAAQQQIEHnPYAAAggggAACCCCAAAIIIICAAwIk6A40AkVAAAEEEEAAAQQQQAABBBBAgASd9wACCCCAAAIIIIAAAggggAACDgiQoDvQCBQBAQQQQAABBBBAAAEEEEAAARJ03gMIIIAAAggggAACCCCAAAIIOCBAgu5AI1AEBBBAAAEEEEAAAQQQQAABBEjQeQ8ggAACCCCAAAIIIIAAAggg4IAACboDjUAREEAAAQQQQAABBBBAAAEEECBB5z2AAAIIIIAAAggggAACCCCAgAMCJOgONAJFQAABBBBAAAEEEEAAAQQQQIAEnfcAAggggAACCCCAAAIIIIAAAg4IkKA70AgUAQEEEEAAAQQQQAABBBBAAAESdN4DCCCAAAIIIIAAAggggAACCDggQILuQCNQBAQQQAABBBBAAAEEEEAAAQRI0HkPIIAAAggggAACCCCAAAIIIOCAAAm6A41AERBAAAEEEEAAAQQQQAABBBAgQec9gAACCCCAAAIIIIAAAggggIADAiToDjQCRUAAAQQQQAABBBBAAAEEEECABJ33AAIIIIAAAggggAACCCCAAAIOCJCgO9AIFAEBBBBAAAEEEEAAAQQQQAABEnTeAwgggAACCCCAAAIIIIAAAgg4IECC7kAjUAQEEEAAAQQQQAABBBBAAAEESNB5DyCAAAIIIIAAAggggAACCCDggAAJugONQBEQQAABBBBAAAEEEEAAAQQQIEHnPYAAAggggAACCCCAAAIIIICAAwIk6A40AkVAAAEEEEAAAQQQQAABBBBAgASd9wACCCCAAAIIIIAAAggggAACDgiQoDvQCBQBAQQQQAABBBBAAAEEEEAAARJ03gMIIIAAAggggAACCCCAAAIIOCBAgu5AI1AEBBBAAAEEEEAAAQQQQAABBEjQeQ8ggAACCCCAAAIIIIAAAggg4IAACboDjUAREEAAAQQQQAABBBBAAAEEECBB5z2AAAIIIIAAAggggAACCCCAgAMCJOgONAJFQAABBBBAAAEEEEAAAQQQQIAEnfcAAggggAACCCCAAAIIIIAAAg4IkKA70AgUAQEEEEAAAQQQQAABBBBAAAESdN4DCCCAAAIIIIAAAggggAACCDggQILuQCNQBAQQQAABBBBAAAEEEEAAAQRI0HkPIIAAAggggAACCCCAAAIIIOCAAAm6A41AERBAAAEEEEAAAQQQQAABBBAgQec9gAACCCCAAAIIIIAAAggggIADAiToDjQCRUAAAQQQQAABBBBAAAEEEECABJ33AAIIIIAAAggggAACCCCAAAIOCJCgO9AIFAEBBBBAAAEEEEAAAQQQQAABEnTeAwgggAACCCCAAAIIIIAAAgg4IECC7kAjUAQEEEAAAQQQQAABBBBAAAEESNB5DyCAAAIIIIAAAggggAACCCDggAAJugONQBEQQAABBBBAAAEEEEAAAQQQIEHnPYAAAggggAACCCCAAAIIIICAAwIk6A40AkVAAAEEEEAAAQQQQAABBBBAgASd9wACCCCAAAIIIIAAAggggAACDgiQoDvQCBQBAQQQQAABBBBAAAEEEEAAARJ03gMIIIAAAggggAACCCCAAAIIOCBAgu5AI1AEBBBAAAEEEEAAAQQQQAABBEjQeQ8ggAACCCCAAAIIIIAAAggg4IAACboDjUAREEAAAQQQQAABBBBAAAEEECBB5z2AAAIIIIAAAggggAACCCCAgAMCJOgONAJFQAABBBBAAAEEEEAAAQQQQIAEnfcAAggggAACCCCAAAIIIIAAAg4IkKA70AgUAQEEEEAAAQQQQAABBBBAAAESdN4DCCCAAAIIIIAAAggggAACCDggQILuQCNQBAQQQAABBBBAAAEEEEAAAQRI0HkPIIAAAggggAACCCCAAAIIIOCAAAm6A41AERBAAAEEEEAAAQQQQAABBBAgQec9gAACCCCAAAIIIIAAAggggIADAiToDjQCRUAAAQQQQAABBBBAAAEEEECABJ33AAIIIIAAAggggAACCCCAAAIOCJCgO9AIFAEBBBBAAAEEEEAAAQQQQAABEnTeAwgggAACCCCAAAIIIIAAAgg4IECC7kAjUAQEEEAAAQQQQAABBBBAAAEESNB5DyCAAAIIIIAAAggggAACCCDggAAJugONQBEQQAABBBBAAAEEEEAAAQQQIEHnPYAAAggggAACCCCAAAIIIICAAwIk6A40AkVAAAEEEEAAAQQQQAABBBBAgASd9wACCCCAAAIIIIAAAggggAACDgiQoDvQCBQBAQQQQAABBBBAAAEEEEAAARJ03gMIIIAAAggggAACCCCAAAIIOCBAgu5AI1AEBBBAAAEEEEAAAQQQQAABBEjQeQ8ggAACCCCAAAIIIIAAAggg4IAACboDjUAREEAAAQQQQAABBBBAAAEEECBB5z2AAAIIIIAAAggggAACCCCAgAMCJOgONAJFQAABBBBAAAEEEEAAAQQQQIAEnfcAAggggAACCCCAAAIIIIAAAg4IkKA70AgUAQEEEEAAAQQQQAABBBBAAAESdN4DCCCAAAIIIIAAAggggAACCDggQILuQCNQBAQQQAABBBBAAAEEEEAAAQRI0HkPIBAhgSeffFLOO+88OfLII6Vbt27St29fGTFihPy///f/yl6Lmpoa+cEPflD285b7hNu3b5drr71WTjnlFDnooIN8l4EDB8qXv/xlefrpp8t9uXbnu+WWW+Suu+5qt48nCCCAAAL2AosWLZLPfvaz0rt3b//fcf2c03/HX3rpJfuTFXiF/rutn3Hr168vEBne4aCMWk79qa2tlSOOOEKmTJkib7zxRlvBgrhi6rJixQr/c/7dd99tOx8PEEAgfAES9PDbgBIgYCTwyCOPyGmnnSaakF533XWif8zceOONMnLkSLn33nuNzhG3oFdffVVOOukk+fGPfyxjxoyR//iP//BdrrrqKnnrrbdk+PDh8t5771Ws2iToFaPlxAggkCCByy+/XMaPH+9/yXrHHXf4/45feeWV8oc//EGGDRsm999/f4I02lf15z//uTzxxBOyePFimTp1qv85d/rpp8v777/fPrCIZ5qg6+clCXoReLwEgQoK1Fbw3JwaAQTKKKBJ+aBBg+TRRx/1v0kPTv0P//APfsIePE/K73379vm9CbZu3er/8TJ06NC2qo8aNUouvPBC+Z//+R/p0qVL2/64Pdi5c6fU19fHrVrUBwEEEiSwYMECmTVrltx0003yzW9+s63m+u/4pEmTZNy4cfLFL35RVq9eLYMHD247npQH+tmmPcR00y+i9bPvhz/8oTz44IO+S1IcqCcCSRLgDnqSWpu6Rlpg27Zt0qtXr3bJeVChTp3M/lMePXq06If9Y489JqeeeqrU1dXJhz70Ifne977nf+gH58v2e8uWLXLRRRfJkCFDpKGhQfr06SNnnnmmf670eO1mp93xbrjhBpk9e7b/pYLGa1d8vRuSuT311FPyd3/3d3LYYYdJ9+7d/Tviv/rVrzLDOjzXP06effZZmTlzpl+nDgHejrPOOqtdAvv444/LJz/5SenRo4e/X3skaM+E9C3oLrhkyRL553/+Z9+8Z8+eMnHiRNm0aVNb6ECvG/1zzz0ny5Yt8+urddZ9wbZx40b/j0t10uEIxx57rPzbv/2b7N+/PwiRpUuX+q/V3+lbYKhlCbYvfelLvrvWWf9g1TpoXdgQQACBKAvoHdy//du/bZecB/XRLyD1jvru3bsLfhGtQ7L03+FVq1b5/17rkKeDDz7Y/3dYP7/yba+88orfdfwjH/mI/9mgn4tnn322/xmT+brgOvrv/z/+4z/619DhZtodP7PH1p///Gf5p3/6J//zMvgc+NnPfpZ5Sqvn+tmt24YNG3K+zuSzTuvxL//yL/459Mt/tdOfzM+jnBfhAAIIVEzA7K/6il2eEyOAgKmAJrg6Bv2SSy7xf+/du9f0pe3impqaRO+66x2Jhx56SD73uc/JNddcI9/61rfaxWU+efvtt/1d//qv/+ontdrt7qijjhJN+rN9oOsfIdolb86cOfKLX/zC7443YcKEdn/AaBKsXfS1e91tt93ml0e7M37hC1+Q9OQ0syz6XLv463buuef6vwv9nybS+oWC/gF15513+t0ENcnVP8KyDRH46le/6t99/+Uvf+n/Yah11Ls5wfbAAw/49dcu9tr9UH90n276x6Am/1pGvdPx8MMPy6c+9Sm59NJL5eKLLw5OYf27paXF/zJD66Ftp3/YsiGAAAJRFdAkU5Nj/Xc416ZfCutnzf/93//lCmm3X+dp+fCHPyy//vWv/fHV+mWudp/P95mpX77qF7E6XOp///d/RT+/dMz3xz/+8Zxj4M8//3w55phj5L777pPLLrtM9LPi29/+dltZnn/+efnYxz4ma9eu9b+c/e///m/5zGc+43+Gl/Jvt3rppmP1s22mn3X6GRf0WNAhBMHn2Mknn5zttOxDAIFqCqTYEEAgEgJeV+7UJz7xiZT374P/43XdTnlJYMrrGpjasWOHUR28LoP+a73krl28N64t5d2FT3l/LLXt1+t4yXjb88wHra2tKe8PnpR3Fzfl/UHUdnjdunX+NY4//viUxgTbH//4R3+/N0482JX66Ec/mvISXP88bTu9B95EQanDDz885XXlS9/d7vGnP/1p/3zenZV2+3M98e46pLy72e2stHxej4KUN/FOyruz7b/U++LBP6/XW6DdqbwhBv7+N998s23/cccdl1LTzM37Y82P9b5QaXfIuyOf8u5QpLxJj/z93hcUfpz+Tt8CQy1LsHld9v3YefPmBbv4jQACCERawBsD7f+75t0lz1sP7wvqVNeuXfPG6OeVfm55SXK7OO8LYn+/15W+bX/w77z+W5tt088G7wvRlHdHvcP5guvoZ0L6pp8ZXi+wts8S70sB/7PF+1I4PSzlfUnrx3lferfbn/kkKKPX88z/jNTPeS/JT3mJecr7cjnlfdnuvySIC+pi+lmnL77++ut9m+C1mWXgOQIIhCPAHfRqfhvCtRAoQUC/3deu6X/605/8b/nPOeccefnll/0u3l4yLDoWWzftQu39cdH2o+PV0je9a6xdytM37YKnr1u+fHn67g6P9S63fruuXdH17oKO7/7tb38rL7zwQodYvVPQuXPntv0nnHCC/zjolqd3AV588cW2MXTpZdY77V4inPPORdtJDR/oZDra+0B7C2h3+2DT8l1wwQXy+uuvd7hWplFm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FeKjWYoLwA1N8S56XIguPqSawIwZIcTRA/ERg/U49P23vw21YQn1gHtz7fnPnnkm/NejjgpTJk8Otb9qbDk2Z04Ie+65JTiPZUgECBAgQIAAAQIECBDIgYAAPQedoAodEIiBdm1RuaGpv7Z42n3XXRf++NWvDrUJ90MPeU6AAAECBAgQIECAAIHcCZiDnrsuUSECBAgQIECAAAECBAgQqKKAAL2Kva7NBAgQIECAAAECBAgQIJA7AQF67rpEhQgQIECAAAECBAgQIECgigIC9Cr2ujYTIECAAAECBAgQIECAQO4EBOi56xIVIkCAAAECBAgQIECAAIEqCgjQq9jr2kyAAAECBAgQIECAAAECuRMQoOeuS1SIAAECBAgQIECAAAECBKooIECvYq9rMwECBAgQIECAAAECBAjkTkCAnrsuUSECBAgQIECAAAECBAgQqKKAAL2Kva7NBAgQIECAAAECBAgQIJA7AQF67rpEhQgQIECAAAECBAgQIECgigIC9Cr2ujYTIECAAAECBAgQIECAQO4EBOi56xIVIkCAAAECBAgQIECAAIEqCgjQq9jr2kyAAAECBAgQIECAAAECuRMQoOeuS1SIAAECBAgQIECAAAECBKooIECvYq9rMwECBAgQIECAAAECBAjkTkCAnrsuUSECBAgQIECAAAECBAgQqKKAAL2Kva7NBAgQIECAAAECBAgQIJA7AQF67rpEhQgQIECAAAECBAgQIECgigIC9Cr2ujYTIECAAAECBAgQIECAQO4EBOi56xIVIkCAAAECBAgQIECAAIEqCgjQq9jr2kyAAAECBAgQIECAAAECuRMQoOeuS1SIAAECBAgQIECAAAECBKooIECvYq9rMwECBAgQIECAAAECBAjkTkCAnrsuUSECBAgQIECAAAECBAgQqKKAAL2Kva7NBAgQIECAAAECBAgQIJA7AQF67rpEhQgQIECAAAECBAgQIECgigIC9Cr2ujYTIECAAIEOCNx3333hjDPOCHPnzg3Tp08P++67b/jQhz4UNmzY0IHSFUGAAAECBKonMKV6TdZiAgQIECBAoBMCv/zlL0N/f3/43Oc+F1760peGn/3sZ2Hp0qXh2WefDZdddlknLqEMAgQIECBQKQEBeqW6W2MJECBAgEDnBI477rgQH420zz77hLvvvjtcccUVAvQGiq8ECBAgQCBBQICegCUrAQIECBAg0FzgqaeeCjvvvHPTTC+88EKIj0Z6+umn6083btwY4qOsqdG2xteytjO2q9HGxldtLYdAoz8bX8vRqq1b0Whf4+vWOcrzThXaWLTeEqAXrcfUlwABAgQI5FTgnnvuCZ/85CfD5Zdf3rSGK1asCBdddNFWeVavXh222267rd4v2xurVq0qW5PGbI+2jklT6ANV6dcqtPO5554r9GexjJUXoJexV7WJAAECBAiMQ+DCCy8cNYAeWuTtt98e5s2bN/jWb3/72/pw95NPPjm84x3vGHx/tCfnn39+OPfccwcPxTvos2fPDgsXLgy77LLL4PtlexLvVMVf+BctWhSmTp1atuYNa4+2DuMozYuq9GtV2hk/mI899lhpPp9laYgAvSw9qR0ECBAgQKBDAmeffXY45ZRTmpa29957Dx6PwXkMro888sjw+c9/fvD9sZ5MmzYtxMfIFIPWsgeusc1Vaae2jvyEl+d1VT7DVWhnFb7nFu1fngC9aD2mvgQIECBAoMsCu+66a4iPLOk3v/lNPTg/7LDDwpe//OUwaZIdXLO4yUOAAAECBEYTEKCPpuI9AgQIECBAoKVAvHN+zDHHhDlz5tRXbX/00UcHz5k1a9bgc08IECBAgACBbAIC9GxOchEgQIAAAQIjBG688cbw61//uv54yUteMuzowMDAsNdeECBAgAABAq0FjENrbSQHAQIECBAgMIrAkiVLQgzER3uMkt1bBAgQIECAQAsBAXoLIIcJECBAgAABAgQIECBAgEAvBATovVB2DQIECBAgQIAAAQIECBAg0EJAgN4CyGECBAgQIECAAAECBAgQINALAQF6L5RdgwABAgQIECBAgAABAgQItBAQoLcAcpgAAQIECBAgQIAAAQIECPRCQIDeC2XXIECAAAECBAgQIECAAAECLQQE6C2AHCZAgAABAgQIECBAgAABAr0QEKD3Qtk1CBAgQIAAAQIECBAgQIBACwEBegsghwkQIECAAAECBAgQIECAQC8EBOi9UHYNAgQIECBAgAABAgQIECDQQkCA3gLIYQIECBAgQIAAAQIECBAg0AsBAXovlF2DAAECBAgQIECAAAECBAi0EBCgtwBymAABAgQIECBAgAABAgQI9EJAgN4LZdcgQIAAAQIECBAgQIAAAQItBAToLYAcJkCAAAECBAgQIECAAAECvRAQoPdC2TUIECBAgAABAgQIECBAgEALAQF6CyCHCRAgQIAAAQIECBAgQIBALwQE6L1Qdg0CBAgQIECAAAECBAgQINBCQIDeAshhAgQIECBAgAABAgQIECDQCwEBei+UXYMAAQIECBAgQIAAAQIECLQQEKC3AHKYAAECBAgQIECAAAECBAj0QkCA3gtl1yBAgAABAgQIECBAgAABAi0EBOgtgBwmQIAAAQIECBAgQIAAAQK9EBCg90LZNQgQIECAAAECBAgQIECAQAsBAXoLIIcJECBAgAABAgQIECBAgEAvBATovVB2DQIECBAgQIAAAQIECBAg0EJAgN4CyGECBAgQIECAAAECBAgQINALAQF6L5RdgwABAgQIECBAgAABAgQItBAQoLcAcpgAAQIECBAgQIAAAQIECPRCQIDeC2XXIECAAAECBAgQIECAAAECLQQE6C2AHCZAgAABAgQIECBAgAABAr0QEKD3Qtk1CBAgQIAAAQIECBAgQIBACwEBegsghwkQIECAAAECBAgQIECAQC8EBOi9UHYNAgQIECBAgAABAgQIECDQQkCA3gLIYQIECBAgQIAAAQIECBAg0AsBAXovlF2DAAECBAgQIECAAAECBAi0EBCgtwBymAABAgQIECBAgAABAgQI9EJAgN4LZdcgQIAAAQIECBAgQIAAAQItBAToLYAcJkCAAAECBAgQIECAAAECvRAQoPdC2TUIECBAgAABAgQIECBAgEALAQF6CyCHCRAgQIAAAQIECBAgQIBALwQE6L1Qdg0CBAgQIECAAAECBAgQINBCQIDeAshhAgQIECBAgAABAgQIECDQCwEBei+UXYMAAQIECBAgQIAAAQIECLQQEKC3AHKYAAECBAgQIECAAAECBAj0QkCA3gtl1yBAgAABAgQIECBAgAABAi0EBOgtgLp1ePny5WH+/Plhu+22CzvuuGOmyyxZsiT09fUNexxxxBGZzpWJAAECBAgQIECAAAECBPItIECfoP7ZsGFDOPnkk8OZZ56ZVIPjjjsuPPjgg4OP6667Lul8mQkQIECAAAECBAgQIEAgnwJT8lmt8tfqoosuqjfyqquuSmrstGnTwqxZs5LOkZkAAQIECBAgQIAAAQIE8i/gDnr++2hYDb/73e+G3XbbLey3335h6dKl4ZFHHhl23AsCBAgQIECAAAECBAgQKKaA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6lPh9ttvD7NmzQqLFi0KzzzzTNPzHCRAgAABAt0SWLhwYfiXf/mXcPfdd4evf/3r4Z577glvetObunU55RIgQIAAgVILTCl163LauOOOOy7ERyPts88+9V9srrjiinDZZZc13h72Nd49//jHPx6WLVsWTjrppPqxlStXht133z189atfDe985zuH5feCAAECBAj0QuCcc84ZvMxee+0VzjvvvPD6178+bNy4MUydOnXwmCcECBAgQIBAawEBemujnuR46qmnws477zzmtdauXRseeuihsHjx4sE806ZNC0cffXS49dZbxwzQX3jhhRAfjRSvE9Pjjz/eeKu0X+Mvh88991x47LHHSv1LYlXaGT+o2lrOf65V6dfG9934B9eyptjGr3zlK2H+/PlNv+9W9WdTVT7r8fOtreX8V16Vfq1KO+OntAo/m4r2r1GAnoMei8MBP/nJT4bLL798zNrE4DymeMd8aIqv77///qFvDXu+YsWKcNFFFw17L77Yb7/9tnrPGwQIECDQfYH4R8Mddtih+xfq4RX++q//uj79Kv5R9Igjjgjf/OY3m17dz6amPA4SIECg5wJl/NnUc8QOXbCv9pf88v4pv0NIWYuJC7iNFgwPPT/OHZ83b97gW3EhnXgXPD6+8IUvDL4/8km8S75gwYL6wjtxEZ5GWrp0aXjggQfC9ddf33hr2NeRdymefPLJEIcgrlu3rnS/IA5reO3F008/HWbPnl332X777UceLs3rqrQzdpi2luZjO6whVenXOIIpLqb2xBNPhB133HGYQd5epP48+93vfle/CxP/YBx/DsY/QMQgva+vb9SmVfVnU1U+67HTtXXUj37h36xKv1alnfEDWaSfTYX/B5SxAe6gZ4TKku3ss88Op5xyStOse++99+DxGJzHxXWOPPLI8PnPf37w/dGexAXhYop30ocG6I888shWd9WHnh+HwcfHyBR/eSpz0Dq0vbGdVWhrVdoZ+1Zbh37Cy/O8Kv06aVL+12dN/Xm26667hviIo7MOOOCA+h9Hb7vttvrPt9E+oVX/2VSVz3rse20d7V9A8d+rSr9WpZ3xE1mEn03F/5eTrQUC9GxOmXI1fkHJkvk3v/lNPTg/7LDDwpe//OWW/yjilmwxSF+1alU45JBD6peI27LddNNN4SMf+UiWS8pDgAABAgQyCaT8PBtZYGNg3tD1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" width="1000">
</div>
</div>
</section>
<section id="notes" class="level4">
<h4 class="anchored" data-anchor-id="notes">Notes</h4>
<ul>
<li>When we select a contour choosing points in the s-plane that never go around a pole or a zero, then the phase never goes around 360 degree. In the example above, the phase stays within approximately 150 and 210 degrees (<code>countour 1</code> in the code cell above, <code>case 1</code>)</li>
<li>When we go around a zero in a clockwise direction we would <em>add</em> 360 degree of phase as we move around the zero, and the point in the <span class="math inline">\(\Omega\)</span>-plane rotates 360 degree in the <em>clockwise</em> direction (see <code>contour 2</code> in the code cell above, <code>case 1</code>)</li>
<li>When we go around a pole in a clockwise direction we would <em>subtract</em> 360 degree of phase as we move around the pole, and the point in the <span class="math inline">\(\Omega\)</span>-plane rotates 360 degree in the <em>counter-clockwise</em> direction (see <code>contour 3</code> in the code cell above, <code>case 1</code>)</li>
</ul>
<p>What is happening becomes clearer when we plot what happens for a single pole: - moving around the pole in a clockwise direction, and the resulting plot circles the origin once in the counter-clockwise direction since we are subtracting 360 degree of phase</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb9"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="co"># %matplotlib notebook</span></span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a>fig, axs <span class="op">=</span> plt.subplots(<span class="dv">1</span>, <span class="dv">2</span>, figsize<span class="op">=</span>(<span class="dv">10</span>, <span class="dv">5</span>))<span class="op">;</span></span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a>line_0, <span class="op">=</span> axs[<span class="dv">0</span>].plot([])     <span class="co"># A tuple unpacking to unpack the only plot</span></span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a>line_1, <span class="op">=</span> axs[<span class="dv">1</span>].plot([])     <span class="co"># A tuple unpacking to unpack the only plot</span></span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true" tabindex="-1"></a>axs[<span class="dv">0</span>].grid()</span>
<span id="cb9-6"><a href="#cb9-6" aria-hidden="true" tabindex="-1"></a>axs[<span class="dv">1</span>].grid()</span>
<span id="cb9-7"><a href="#cb9-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-8"><a href="#cb9-8" aria-hidden="true" tabindex="-1"></a>xoff <span class="op">=</span> <span class="op">-</span><span class="fl">0.75</span>  <span class="co"># X-offset of the contour</span></span>
<span id="cb9-9"><a href="#cb9-9" aria-hidden="true" tabindex="-1"></a>yoff <span class="op">=</span> <span class="dv">0</span><span class="op">;</span>     <span class="co"># Y-offset of the contour</span></span>
<span id="cb9-10"><a href="#cb9-10" aria-hidden="true" tabindex="-1"></a>angles <span class="op">=</span> np.linspace(<span class="dv">2</span><span class="op">*</span>np.pi, <span class="dv">0</span>, <span class="dv">160</span>)<span class="op">;</span>  <span class="co"># Generate angles around the circle; 160 is tje Number of points around the circular contour</span></span>
<span id="cb9-11"><a href="#cb9-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-12"><a href="#cb9-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-13"><a href="#cb9-13" aria-hidden="true" tabindex="-1"></a>pt <span class="op">=</span> [np.cos(angles)<span class="op">+</span>xoff, np.sin(angles)<span class="op">+</span>yoff]<span class="op">;</span> </span>
<span id="cb9-14"><a href="#cb9-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-15"><a href="#cb9-15" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> animate_plot(<span class="bu">bin</span>):    </span>
<span id="cb9-16"><a href="#cb9-16" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Set 's' to the next point on the contour</span></span>
<span id="cb9-17"><a href="#cb9-17" aria-hidden="true" tabindex="-1"></a>    s <span class="op">=</span> <span class="bu">complex</span>(pt[<span class="dv">0</span>][<span class="bu">bin</span>], pt[<span class="dv">1</span>][<span class="bu">bin</span>])<span class="op">;</span></span>
<span id="cb9-18"><a href="#cb9-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-19"><a href="#cb9-19" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Plot the next point on the contour in the s-plane    </span></span>
<span id="cb9-20"><a href="#cb9-20" aria-hidden="true" tabindex="-1"></a>    line_0 <span class="op">=</span> axs[<span class="dv">0</span>].plot(np.real(s), np.imag(s), color<span class="op">=</span><span class="st">'red'</span>, marker<span class="op">=</span><span class="st">'.'</span>, markersize<span class="op">=</span><span class="dv">15</span>)<span class="op">;</span></span>
<span id="cb9-21"><a href="#cb9-21" aria-hidden="true" tabindex="-1"></a>    axs[<span class="dv">0</span>].set_title(<span class="st">'S-plane Contour'</span>)<span class="op">;</span></span>
<span id="cb9-22"><a href="#cb9-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-23"><a href="#cb9-23" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Define the system transfer function</span></span>
<span id="cb9-24"><a href="#cb9-24" aria-hidden="true" tabindex="-1"></a>   </span>
<span id="cb9-25"><a href="#cb9-25" aria-hidden="true" tabindex="-1"></a>    <span class="co">#  1 pole</span></span>
<span id="cb9-26"><a href="#cb9-26" aria-hidden="true" tabindex="-1"></a>    tnf <span class="op">=</span> <span class="dv">1</span><span class="op">/</span>((s <span class="op">+</span> <span class="dv">1</span>))<span class="op">;</span> </span>
<span id="cb9-27"><a href="#cb9-27" aria-hidden="true" tabindex="-1"></a>    axs[<span class="dv">0</span>].plot([<span class="op">-</span><span class="dv">1</span>] , [<span class="dv">0</span>], color<span class="op">=</span><span class="st">'blue'</span>, marker<span class="op">=</span><span class="st">'x'</span>, markersize<span class="op">=</span><span class="dv">10</span>)<span class="op">;</span></span>
<span id="cb9-28"><a href="#cb9-28" aria-hidden="true" tabindex="-1"></a>    axs[<span class="dv">0</span>].set_xlim([<span class="op">-</span><span class="dv">3</span>, <span class="dv">2</span>])</span>
<span id="cb9-29"><a href="#cb9-29" aria-hidden="true" tabindex="-1"></a>    axs[<span class="dv">0</span>].set_ylim([<span class="op">-</span><span class="dv">2</span>, <span class="dv">2</span>])<span class="op">;</span></span>
<span id="cb9-30"><a href="#cb9-30" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-31"><a href="#cb9-31" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-32"><a href="#cb9-32" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Plot the mapping from the TF in the w-plane    </span></span>
<span id="cb9-33"><a href="#cb9-33" aria-hidden="true" tabindex="-1"></a>    line_1 <span class="op">=</span> axs[<span class="dv">1</span>].plot(np.real(tnf), np.imag(tnf), color<span class="op">=</span><span class="st">'g'</span>, marker<span class="op">=</span><span class="st">'.'</span>, markersize<span class="op">=</span><span class="dv">15</span>)<span class="op">;</span></span>
<span id="cb9-34"><a href="#cb9-34" aria-hidden="true" tabindex="-1"></a>    axs[<span class="dv">1</span>].plot(<span class="dv">0</span>, <span class="dv">0</span>, marker<span class="op">=</span><span class="st">'.'</span>, color<span class="op">=</span><span class="st">'k'</span>, markersize<span class="op">=</span><span class="dv">15</span>)<span class="op">;</span></span>
<span id="cb9-35"><a href="#cb9-35" aria-hidden="true" tabindex="-1"></a>    axs[<span class="dv">1</span>].set_title(<span class="st">'$\Omega$-plane Plot'</span>)<span class="op">;</span>        </span>
<span id="cb9-36"><a href="#cb9-36" aria-hidden="true" tabindex="-1"></a>    axs[<span class="dv">1</span>].set_xlim([<span class="op">-</span><span class="dv">3</span>, <span class="dv">2</span>])</span>
<span id="cb9-37"><a href="#cb9-37" aria-hidden="true" tabindex="-1"></a>    axs[<span class="dv">1</span>].set_ylim([<span class="op">-</span><span class="dv">3</span>, <span class="dv">2</span>])<span class="op">;</span></span>
<span id="cb9-38"><a href="#cb9-38" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-39"><a href="#cb9-39" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> line_0, line_1</span>
<span id="cb9-40"><a href="#cb9-40" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-41"><a href="#cb9-41" aria-hidden="true" tabindex="-1"></a>anim <span class="op">=</span> FuncAnimation(fig, animate_plot, frames<span class="op">=</span><span class="bu">len</span>(angles), interval<span class="op">=</span><span class="dv">20</span>)</span>
<span id="cb9-42"><a href="#cb9-42" aria-hidden="true" tabindex="-1"></a>anim<span class="op">;</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<script type="application/javascript">
/* Put everything inside the global mpl namespace */
/* global mpl */
window.mpl = {};

mpl.get_websocket_type = function () {
    if (typeof WebSocket !== 'undefined') {
        return WebSocket;
    } else if (typeof MozWebSocket !== 'undefined') {
        return MozWebSocket;
    } else {
        alert(
            'Your browser does not have WebSocket support. ' +
                'Please try Chrome, Safari or Firefox ‚â• 6. ' +
                'Firefox 4 and 5 are also supported but you ' +
                'have to enable WebSockets in about:config.'
        );
    }
};

mpl.figure = function (figure_id, websocket, ondownload, parent_element) {
    this.id = figure_id;

    this.ws = websocket;

    this.supports_binary = this.ws.binaryType !== undefined;

    if (!this.supports_binary) {
        var warnings = document.getElementById('mpl-warnings');
        if (warnings) {
            warnings.style.display = 'block';
            warnings.textContent =
                'This browser does not support binary websocket messages. ' +
                'Performance may be slow.';
        }
    }

    this.imageObj = new Image();

    this.context = undefined;
    this.message = undefined;
    this.canvas = undefined;
    this.rubberband_canvas = undefined;
    this.rubberband_context = undefined;
    this.format_dropdown = undefined;

    this.image_mode = 'full';

    this.root = document.createElement('div');
    this.root.setAttribute('style', 'display: inline-block');
    this._root_extra_style(this.root);

    parent_element.appendChild(this.root);

    this._init_header(this);
    this._init_canvas(this);
    this._init_toolbar(this);

    var fig = this;

    this.waiting = false;

    this.ws.onopen = function () {
        fig.send_message('supports_binary', { value: fig.supports_binary });
        fig.send_message('send_image_mode', {});
        if (fig.ratio !== 1) {
            fig.send_message('set_device_pixel_ratio', {
                device_pixel_ratio: fig.ratio,
            });
        }
        fig.send_message('refresh', {});
    };

    this.imageObj.onload = function () {
        if (fig.image_mode === 'full') {
            // Full images could contain transparency (where diff images
            // almost always do), so we need to clear the canvas so that
            // there is no ghosting.
            fig.context.clearRect(0, 0, fig.canvas.width, fig.canvas.height);
        }
        fig.context.drawImage(fig.imageObj, 0, 0);
    };

    this.imageObj.onunload = function () {
        fig.ws.close();
    };

    this.ws.onmessage = this._make_on_message_function(this);

    this.ondownload = ondownload;
};

mpl.figure.prototype._init_header = function () {
    var titlebar = document.createElement('div');
    titlebar.classList =
        'ui-dialog-titlebar ui-widget-header ui-corner-all ui-helper-clearfix';
    var titletext = document.createElement('div');
    titletext.classList = 'ui-dialog-title';
    titletext.setAttribute(
        'style',
        'width: 100%; text-align: center; padding: 3px;'
    );
    titlebar.appendChild(titletext);
    this.root.appendChild(titlebar);
    this.header = titletext;
};

mpl.figure.prototype._canvas_extra_style = function (_canvas_div) {};

mpl.figure.prototype._root_extra_style = function (_canvas_div) {};

mpl.figure.prototype._init_canvas = function () {
    var fig = this;

    var canvas_div = (this.canvas_div = document.createElement('div'));
    canvas_div.setAttribute(
        'style',
        'border: 1px solid #ddd;' +
            'box-sizing: content-box;' +
            'clear: both;' +
            'min-height: 1px;' +
            'min-width: 1px;' +
            'outline: 0;' +
            'overflow: hidden;' +
            'position: relative;' +
            'resize: both;'
    );

    function on_keyboard_event_closure(name) {
        return function (event) {
            return fig.key_event(event, name);
        };
    }

    canvas_div.addEventListener(
        'keydown',
        on_keyboard_event_closure('key_press')
    );
    canvas_div.addEventListener(
        'keyup',
        on_keyboard_event_closure('key_release')
    );

    this._canvas_extra_style(canvas_div);
    this.root.appendChild(canvas_div);

    var canvas = (this.canvas = document.createElement('canvas'));
    canvas.classList.add('mpl-canvas');
    canvas.setAttribute('style', 'box-sizing: content-box;');

    this.context = canvas.getContext('2d');

    var backingStore =
        this.context.backingStorePixelRatio ||
        this.context.webkitBackingStorePixelRatio ||
        this.context.mozBackingStorePixelRatio ||
        this.context.msBackingStorePixelRatio ||
        this.context.oBackingStorePixelRatio ||
        this.context.backingStorePixelRatio ||
        1;

    this.ratio = (window.devicePixelRatio || 1) / backingStore;

    var rubberband_canvas = (this.rubberband_canvas = document.createElement(
        'canvas'
    ));
    rubberband_canvas.setAttribute(
        'style',
        'box-sizing: content-box; position: absolute; left: 0; top: 0; z-index: 1;'
    );

    // Apply a ponyfill if ResizeObserver is not implemented by browser.
    if (this.ResizeObserver === undefined) {
        if (window.ResizeObserver !== undefined) {
            this.ResizeObserver = window.ResizeObserver;
        } else {
            var obs = _JSXTOOLS_RESIZE_OBSERVER({});
            this.ResizeObserver = obs.ResizeObserver;
        }
    }

    this.resizeObserverInstance = new this.ResizeObserver(function (entries) {
        var nentries = entries.length;
        for (var i = 0; i < nentries; i++) {
            var entry = entries[i];
            var width, height;
            if (entry.contentBoxSize) {
                if (entry.contentBoxSize instanceof Array) {
                    // Chrome 84 implements new version of spec.
                    width = entry.contentBoxSize[0].inlineSize;
                    height = entry.contentBoxSize[0].blockSize;
                } else {
                    // Firefox implements old version of spec.
                    width = entry.contentBoxSize.inlineSize;
                    height = entry.contentBoxSize.blockSize;
                }
            } else {
                // Chrome <84 implements even older version of spec.
                width = entry.contentRect.width;
                height = entry.contentRect.height;
            }

            // Keep the size of the canvas and rubber band canvas in sync with
            // the canvas container.
            if (entry.devicePixelContentBoxSize) {
                // Chrome 84 implements new version of spec.
                canvas.setAttribute(
                    'width',
                    entry.devicePixelContentBoxSize[0].inlineSize
                );
                canvas.setAttribute(
                    'height',
                    entry.devicePixelContentBoxSize[0].blockSize
                );
            } else {
                canvas.setAttribute('width', width * fig.ratio);
                canvas.setAttribute('height', height * fig.ratio);
            }
            canvas.setAttribute(
                'style',
                'width: ' + width + 'px; height: ' + height + 'px;'
            );

            rubberband_canvas.setAttribute('width', width);
            rubberband_canvas.setAttribute('height', height);

            // And update the size in Python. We ignore the initial 0/0 size
            // that occurs as the element is placed into the DOM, which should
            // otherwise not happen due to the minimum size styling.
            if (fig.ws.readyState == 1 && width != 0 && height != 0) {
                fig.request_resize(width, height);
            }
        }
    });
    this.resizeObserverInstance.observe(canvas_div);

    function on_mouse_event_closure(name) {
        return function (event) {
            return fig.mouse_event(event, name);
        };
    }

    rubberband_canvas.addEventListener(
        'mousedown',
        on_mouse_event_closure('button_press')
    );
    rubberband_canvas.addEventListener(
        'mouseup',
        on_mouse_event_closure('button_release')
    );
    rubberband_canvas.addEventListener(
        'dblclick',
        on_mouse_event_closure('dblclick')
    );
    // Throttle sequential mouse events to 1 every 20ms.
    rubberband_canvas.addEventListener(
        'mousemove',
        on_mouse_event_closure('motion_notify')
    );

    rubberband_canvas.addEventListener(
        'mouseenter',
        on_mouse_event_closure('figure_enter')
    );
    rubberband_canvas.addEventListener(
        'mouseleave',
        on_mouse_event_closure('figure_leave')
    );

    canvas_div.addEventListener('wheel', function (event) {
        if (event.deltaY < 0) {
            event.step = 1;
        } else {
            event.step = -1;
        }
        on_mouse_event_closure('scroll')(event);
    });

    canvas_div.appendChild(canvas);
    canvas_div.appendChild(rubberband_canvas);

    this.rubberband_context = rubberband_canvas.getContext('2d');
    this.rubberband_context.strokeStyle = '#000000';

    this._resize_canvas = function (width, height, forward) {
        if (forward) {
            canvas_div.style.width = width + 'px';
            canvas_div.style.height = height + 'px';
        }
    };

    // Disable right mouse context menu.
    this.rubberband_canvas.addEventListener('contextmenu', function (_e) {
        event.preventDefault();
        return false;
    });

    function set_focus() {
        canvas.focus();
        canvas_div.focus();
    }

    window.setTimeout(set_focus, 100);
};

mpl.figure.prototype._init_toolbar = function () {
    var fig = this;

    var toolbar = document.createElement('div');
    toolbar.classList = 'mpl-toolbar';
    this.root.appendChild(toolbar);

    function on_click_closure(name) {
        return function (_event) {
            return fig.toolbar_button_onclick(name);
        };
    }

    function on_mouseover_closure(tooltip) {
        return function (event) {
            if (!event.currentTarget.disabled) {
                return fig.toolbar_button_onmouseover(tooltip);
            }
        };
    }

    fig.buttons = {};
    var buttonGroup = document.createElement('div');
    buttonGroup.classList = 'mpl-button-group';
    for (var toolbar_ind in mpl.toolbar_items) {
        var name = mpl.toolbar_items[toolbar_ind][0];
        var tooltip = mpl.toolbar_items[toolbar_ind][1];
        var image = mpl.toolbar_items[toolbar_ind][2];
        var method_name = mpl.toolbar_items[toolbar_ind][3];

        if (!name) {
            /* Instead of a spacer, we start a new button group. */
            if (buttonGroup.hasChildNodes()) {
                toolbar.appendChild(buttonGroup);
            }
            buttonGroup = document.createElement('div');
            buttonGroup.classList = 'mpl-button-group';
            continue;
        }

        var button = (fig.buttons[name] = document.createElement('button'));
        button.classList = 'mpl-widget';
        button.setAttribute('role', 'button');
        button.setAttribute('aria-disabled', 'false');
        button.addEventListener('click', on_click_closure(method_name));
        button.addEventListener('mouseover', on_mouseover_closure(tooltip));

        var icon_img = document.createElement('img');
        icon_img.src = '_images/' + image + '.png';
        icon_img.srcset = '_images/' + image + '_large.png 2x';
        icon_img.alt = tooltip;
        button.appendChild(icon_img);

        buttonGroup.appendChild(button);
    }

    if (buttonGroup.hasChildNodes()) {
        toolbar.appendChild(buttonGroup);
    }

    var fmt_picker = document.createElement('select');
    fmt_picker.classList = 'mpl-widget';
    toolbar.appendChild(fmt_picker);
    this.format_dropdown = fmt_picker;

    for (var ind in mpl.extensions) {
        var fmt = mpl.extensions[ind];
        var option = document.createElement('option');
        option.selected = fmt === mpl.default_extension;
        option.innerHTML = fmt;
        fmt_picker.appendChild(option);
    }

    var status_bar = document.createElement('span');
    status_bar.classList = 'mpl-message';
    toolbar.appendChild(status_bar);
    this.message = status_bar;
};

mpl.figure.prototype.request_resize = function (x_pixels, y_pixels) {
    // Request matplotlib to resize the figure. Matplotlib will then trigger a resize in the client,
    // which will in turn request a refresh of the image.
    this.send_message('resize', { width: x_pixels, height: y_pixels });
};

mpl.figure.prototype.send_message = function (type, properties) {
    properties['type'] = type;
    properties['figure_id'] = this.id;
    this.ws.send(JSON.stringify(properties));
};

mpl.figure.prototype.send_draw_message = function () {
    if (!this.waiting) {
        this.waiting = true;
        this.ws.send(JSON.stringify({ type: 'draw', figure_id: this.id }));
    }
};

mpl.figure.prototype.handle_save = function (fig, _msg) {
    var format_dropdown = fig.format_dropdown;
    var format = format_dropdown.options[format_dropdown.selectedIndex].value;
    fig.ondownload(fig, format);
};

mpl.figure.prototype.handle_resize = function (fig, msg) {
    var size = msg['size'];
    if (size[0] !== fig.canvas.width || size[1] !== fig.canvas.height) {
        fig._resize_canvas(size[0], size[1], msg['forward']);
        fig.send_message('refresh', {});
    }
};

mpl.figure.prototype.handle_rubberband = function (fig, msg) {
    var x0 = msg['x0'] / fig.ratio;
    var y0 = (fig.canvas.height - msg['y0']) / fig.ratio;
    var x1 = msg['x1'] / fig.ratio;
    var y1 = (fig.canvas.height - msg['y1']) / fig.ratio;
    x0 = Math.floor(x0) + 0.5;
    y0 = Math.floor(y0) + 0.5;
    x1 = Math.floor(x1) + 0.5;
    y1 = Math.floor(y1) + 0.5;
    var min_x = Math.min(x0, x1);
    var min_y = Math.min(y0, y1);
    var width = Math.abs(x1 - x0);
    var height = Math.abs(y1 - y0);

    fig.rubberband_context.clearRect(
        0,
        0,
        fig.canvas.width / fig.ratio,
        fig.canvas.height / fig.ratio
    );

    fig.rubberband_context.strokeRect(min_x, min_y, width, height);
};

mpl.figure.prototype.handle_figure_label = function (fig, msg) {
    // Updates the figure title.
    fig.header.textContent = msg['label'];
};

mpl.figure.prototype.handle_cursor = function (fig, msg) {
    fig.rubberband_canvas.style.cursor = msg['cursor'];
};

mpl.figure.prototype.handle_message = function (fig, msg) {
    fig.message.textContent = msg['message'];
};

mpl.figure.prototype.handle_draw = function (fig, _msg) {
    // Request the server to send over a new figure.
    fig.send_draw_message();
};

mpl.figure.prototype.handle_image_mode = function (fig, msg) {
    fig.image_mode = msg['mode'];
};

mpl.figure.prototype.handle_history_buttons = function (fig, msg) {
    for (var key in msg) {
        if (!(key in fig.buttons)) {
            continue;
        }
        fig.buttons[key].disabled = !msg[key];
        fig.buttons[key].setAttribute('aria-disabled', !msg[key]);
    }
};

mpl.figure.prototype.handle_navigate_mode = function (fig, msg) {
    if (msg['mode'] === 'PAN') {
        fig.buttons['Pan'].classList.add('active');
        fig.buttons['Zoom'].classList.remove('active');
    } else if (msg['mode'] === 'ZOOM') {
        fig.buttons['Pan'].classList.remove('active');
        fig.buttons['Zoom'].classList.add('active');
    } else {
        fig.buttons['Pan'].classList.remove('active');
        fig.buttons['Zoom'].classList.remove('active');
    }
};

mpl.figure.prototype.updated_canvas_event = function () {
    // Called whenever the canvas gets updated.
    this.send_message('ack', {});
};

// A function to construct a web socket function for onmessage handling.
// Called in the figure constructor.
mpl.figure.prototype._make_on_message_function = function (fig) {
    return function socket_on_message(evt) {
        if (evt.data instanceof Blob) {
            var img = evt.data;
            if (img.type !== 'image/png') {
                /* FIXME: We get "Resource interpreted as Image but
                 * transferred with MIME type text/plain:" errors on
                 * Chrome.  But how to set the MIME type?  It doesn't seem
                 * to be part of the websocket stream */
                img.type = 'image/png';
            }

            /* Free the memory for the previous frames */
            if (fig.imageObj.src) {
                (window.URL || window.webkitURL).revokeObjectURL(
                    fig.imageObj.src
                );
            }

            fig.imageObj.src = (window.URL || window.webkitURL).createObjectURL(
                img
            );
            fig.updated_canvas_event();
            fig.waiting = false;
            return;
        } else if (
            typeof evt.data === 'string' &&
            evt.data.slice(0, 21) === 'data:image/png;base64'
        ) {
            fig.imageObj.src = evt.data;
            fig.updated_canvas_event();
            fig.waiting = false;
            return;
        }

        var msg = JSON.parse(evt.data);
        var msg_type = msg['type'];

        // Call the  "handle_{type}" callback, which takes
        // the figure and JSON message as its only arguments.
        try {
            var callback = fig['handle_' + msg_type];
        } catch (e) {
            console.log(
                "No handler for the '" + msg_type + "' message type: ",
                msg
            );
            return;
        }

        if (callback) {
            try {
                // console.log("Handling '" + msg_type + "' message: ", msg);
                callback(fig, msg);
            } catch (e) {
                console.log(
                    "Exception inside the 'handler_" + msg_type + "' callback:",
                    e,
                    e.stack,
                    msg
                );
            }
        }
    };
};

// from https://stackoverflow.com/questions/1114465/getting-mouse-location-in-canvas
mpl.findpos = function (e) {
    //this section is from http://www.quirksmode.org/js/events_properties.html
    var targ;
    if (!e) {
        e = window.event;
    }
    if (e.target) {
        targ = e.target;
    } else if (e.srcElement) {
        targ = e.srcElement;
    }
    if (targ.nodeType === 3) {
        // defeat Safari bug
        targ = targ.parentNode;
    }

    // pageX,Y are the mouse positions relative to the document
    var boundingRect = targ.getBoundingClientRect();
    var x = e.pageX - (boundingRect.left + document.body.scrollLeft);
    var y = e.pageY - (boundingRect.top + document.body.scrollTop);

    return { x: x, y: y };
};

/*
 * return a copy of an object with only non-object keys
 * we need this to avoid circular references
 * https://stackoverflow.com/a/24161582/3208463
 */
function simpleKeys(original) {
    return Object.keys(original).reduce(function (obj, key) {
        if (typeof original[key] !== 'object') {
            obj[key] = original[key];
        }
        return obj;
    }, {});
}

mpl.figure.prototype.mouse_event = function (event, name) {
    var canvas_pos = mpl.findpos(event);

    if (name === 'button_press') {
        this.canvas.focus();
        this.canvas_div.focus();
    }

    var x = canvas_pos.x * this.ratio;
    var y = canvas_pos.y * this.ratio;

    this.send_message(name, {
        x: x,
        y: y,
        button: event.button,
        step: event.step,
        guiEvent: simpleKeys(event),
    });

    /* This prevents the web browser from automatically changing to
     * the text insertion cursor when the button is pressed.  We want
     * to control all of the cursor setting manually through the
     * 'cursor' event from matplotlib */
    event.preventDefault();
    return false;
};

mpl.figure.prototype._key_event_extra = function (_event, _name) {
    // Handle any extra behaviour associated with a key event
};

mpl.figure.prototype.key_event = function (event, name) {
    // Prevent repeat events
    if (name === 'key_press') {
        if (event.key === this._key) {
            return;
        } else {
            this._key = event.key;
        }
    }
    if (name === 'key_release') {
        this._key = null;
    }

    var value = '';
    if (event.ctrlKey && event.key !== 'Control') {
        value += 'ctrl+';
    }
    else if (event.altKey && event.key !== 'Alt') {
        value += 'alt+';
    }
    else if (event.shiftKey && event.key !== 'Shift') {
        value += 'shift+';
    }

    value += 'k' + event.key;

    this._key_event_extra(event, name);

    this.send_message(name, { key: value, guiEvent: simpleKeys(event) });
    return false;
};

mpl.figure.prototype.toolbar_button_onclick = function (name) {
    if (name === 'download') {
        this.handle_save(this, null);
    } else {
        this.send_message('toolbar_button', { name: name });
    }
};

mpl.figure.prototype.toolbar_button_onmouseover = function (tooltip) {
    this.message.textContent = tooltip;
};

///////////////// REMAINING CONTENT GENERATED BY embed_js.py /////////////////
// prettier-ignore
var _JSXTOOLS_RESIZE_OBSERVER=function(A){var t,i=new WeakMap,n=new WeakMap,a=new WeakMap,r=new WeakMap,o=new Set;function s(e){if(!(this instanceof s))throw new TypeError("Constructor requires 'new' operator");i.set(this,e)}function h(){throw new TypeError("Function is not a constructor")}function c(e,t,i,n){e=0 in arguments?Number(arguments[0]):0,t=1 in arguments?Number(arguments[1]):0,i=2 in arguments?Number(arguments[2]):0,n=3 in arguments?Number(arguments[3]):0,this.right=(this.x=this.left=e)+(this.width=i),this.bottom=(this.y=this.top=t)+(this.height=n),Object.freeze(this)}function d(){t=requestAnimationFrame(d);var s=new WeakMap,p=new Set;o.forEach((function(t){r.get(t).forEach((function(i){var r=t instanceof window.SVGElement,o=a.get(t),d=r?0:parseFloat(o.paddingTop),f=r?0:parseFloat(o.paddingRight),l=r?0:parseFloat(o.paddingBottom),u=r?0:parseFloat(o.paddingLeft),g=r?0:parseFloat(o.borderTopWidth),m=r?0:parseFloat(o.borderRightWidth),w=r?0:parseFloat(o.borderBottomWidth),b=u+f,F=d+l,v=(r?0:parseFloat(o.borderLeftWidth))+m,W=g+w,y=r?0:t.offsetHeight-W-t.clientHeight,E=r?0:t.offsetWidth-v-t.clientWidth,R=b+v,z=F+W,M=r?t.width:parseFloat(o.width)-R-E,O=r?t.height:parseFloat(o.height)-z-y;if(n.has(t)){var k=n.get(t);if(k[0]===M&&k[1]===O)return}n.set(t,[M,O]);var S=Object.create(h.prototype);S.target=t,S.contentRect=new c(u,d,M,O),s.has(i)||(s.set(i,[]),p.add(i)),s.get(i).push(S)}))})),p.forEach((function(e){i.get(e).call(e,s.get(e),e)}))}return s.prototype.observe=function(i){if(i instanceof window.Element){r.has(i)||(r.set(i,new Set),o.add(i),a.set(i,window.getComputedStyle(i)));var n=r.get(i);n.has(this)||n.add(this),cancelAnimationFrame(t),t=requestAnimationFrame(d)}},s.prototype.unobserve=function(i){if(i instanceof window.Element&&r.has(i)){var n=r.get(i);n.has(this)&&(n.delete(this),n.size||(r.delete(i),o.delete(i))),n.size||r.delete(i),o.size||cancelAnimationFrame(t)}},A.DOMRectReadOnly=c,A.ResizeObserver=s,A.ResizeObserverEntry=h,A}; // eslint-disable-line
mpl.toolbar_items = [["Home", "Reset original view", "fa fa-home icon-home", "home"], ["Back", "Back to previous view", "fa fa-arrow-left icon-arrow-left", "back"], ["Forward", "Forward to next view", "fa fa-arrow-right icon-arrow-right", "forward"], ["", "", "", ""], ["Pan", "Left button pans, Right button zooms\nx/y fixes axis, CTRL fixes aspect", "fa fa-arrows icon-move", "pan"], ["Zoom", "Zoom to rectangle\nx/y fixes axis", "fa fa-square-o icon-check-empty", "zoom"], ["", "", "", ""], ["Download", "Download plot", "fa fa-floppy-o icon-save", "download"]];

mpl.extensions = ["eps", "jpeg", "pgf", "pdf", "png", "ps", "raw", "svg", "tif"];

mpl.default_extension = "png";/* global mpl */

var comm_websocket_adapter = function (comm) {
    // Create a "websocket"-like object which calls the given IPython comm
    // object with the appropriate methods. Currently this is a non binary
    // socket, so there is still some room for performance tuning.
    var ws = {};

    ws.binaryType = comm.kernel.ws.binaryType;
    ws.readyState = comm.kernel.ws.readyState;
    function updateReadyState(_event) {
        if (comm.kernel.ws) {
            ws.readyState = comm.kernel.ws.readyState;
        } else {
            ws.readyState = 3; // Closed state.
        }
    }
    comm.kernel.ws.addEventListener('open', updateReadyState);
    comm.kernel.ws.addEventListener('close', updateReadyState);
    comm.kernel.ws.addEventListener('error', updateReadyState);

    ws.close = function () {
        comm.close();
    };
    ws.send = function (m) {
        //console.log('sending', m);
        comm.send(m);
    };
    // Register the callback with on_msg.
    comm.on_msg(function (msg) {
        //console.log('receiving', msg['content']['data'], msg);
        var data = msg['content']['data'];
        if (data['blob'] !== undefined) {
            data = {
                data: new Blob(msg['buffers'], { type: data['blob'] }),
            };
        }
        // Pass the mpl event to the overridden (by mpl) onmessage function.
        ws.onmessage(data);
    });
    return ws;
};

mpl.mpl_figure_comm = function (comm, msg) {
    // This is the function which gets called when the mpl process
    // starts-up an IPython Comm through the "matplotlib" channel.

    var id = msg.content.data.id;
    // Get hold of the div created by the display call when the Comm
    // socket was opened in Python.
    var element = document.getElementById(id);
    var ws_proxy = comm_websocket_adapter(comm);

    function ondownload(figure, _format) {
        window.open(figure.canvas.toDataURL());
    }

    var fig = new mpl.figure(id, ws_proxy, ondownload, element);

    // Call onopen now - mpl needs it, as it is assuming we've passed it a real
    // web socket which is closed, not our websocket->open comm proxy.
    ws_proxy.onopen();

    fig.parent_element = element;
    fig.cell_info = mpl.find_output_cell("<div id='" + id + "'></div>");
    if (!fig.cell_info) {
        console.error('Failed to find cell for figure', id, fig);
        return;
    }
    fig.cell_info[0].output_area.element.on(
        'cleared',
        { fig: fig },
        fig._remove_fig_handler
    );
};

mpl.figure.prototype.handle_close = function (fig, msg) {
    var width = fig.canvas.width / fig.ratio;
    fig.cell_info[0].output_area.element.off(
        'cleared',
        fig._remove_fig_handler
    );
    fig.resizeObserverInstance.unobserve(fig.canvas_div);

    // Update the output cell to use the data from the current canvas.
    fig.push_to_output();
    var dataURL = fig.canvas.toDataURL();
    // Re-enable the keyboard manager in IPython - without this line, in FF,
    // the notebook keyboard shortcuts fail.
    IPython.keyboard_manager.enable();
    fig.parent_element.innerHTML =
        '<img src="' + dataURL + '" width="' + width + '">';
    fig.close_ws(fig, msg);
};

mpl.figure.prototype.close_ws = function (fig, msg) {
    fig.send_message('closing', msg);
    // fig.ws.close()
};

mpl.figure.prototype.push_to_output = function (_remove_interactive) {
    // Turn the data on the canvas into data in the output cell.
    var width = this.canvas.width / this.ratio;
    var dataURL = this.canvas.toDataURL();
    this.cell_info[1]['text/html'] =
        '<img src="' + dataURL + '" width="' + width + '">';
};

mpl.figure.prototype.updated_canvas_event = function () {
    // Tell IPython that the notebook contents must change.
    IPython.notebook.set_dirty(true);
    this.send_message('ack', {});
    var fig = this;
    // Wait a second, then push the new image to the DOM so
    // that it is saved nicely (might be nice to debounce this).
    setTimeout(function () {
        fig.push_to_output();
    }, 1000);
};

mpl.figure.prototype._init_toolbar = function () {
    var fig = this;

    var toolbar = document.createElement('div');
    toolbar.classList = 'btn-toolbar';
    this.root.appendChild(toolbar);

    function on_click_closure(name) {
        return function (_event) {
            return fig.toolbar_button_onclick(name);
        };
    }

    function on_mouseover_closure(tooltip) {
        return function (event) {
            if (!event.currentTarget.disabled) {
                return fig.toolbar_button_onmouseover(tooltip);
            }
        };
    }

    fig.buttons = {};
    var buttonGroup = document.createElement('div');
    buttonGroup.classList = 'btn-group';
    var button;
    for (var toolbar_ind in mpl.toolbar_items) {
        var name = mpl.toolbar_items[toolbar_ind][0];
        var tooltip = mpl.toolbar_items[toolbar_ind][1];
        var image = mpl.toolbar_items[toolbar_ind][2];
        var method_name = mpl.toolbar_items[toolbar_ind][3];

        if (!name) {
            /* Instead of a spacer, we start a new button group. */
            if (buttonGroup.hasChildNodes()) {
                toolbar.appendChild(buttonGroup);
            }
            buttonGroup = document.createElement('div');
            buttonGroup.classList = 'btn-group';
            continue;
        }

        button = fig.buttons[name] = document.createElement('button');
        button.classList = 'btn btn-default';
        button.href = '#';
        button.title = name;
        button.innerHTML = '<i class="fa ' + image + ' fa-lg"></i>';
        button.addEventListener('click', on_click_closure(method_name));
        button.addEventListener('mouseover', on_mouseover_closure(tooltip));
        buttonGroup.appendChild(button);
    }

    if (buttonGroup.hasChildNodes()) {
        toolbar.appendChild(buttonGroup);
    }

    // Add the status bar.
    var status_bar = document.createElement('span');
    status_bar.classList = 'mpl-message pull-right';
    toolbar.appendChild(status_bar);
    this.message = status_bar;

    // Add the close button to the window.
    var buttongrp = document.createElement('div');
    buttongrp.classList = 'btn-group inline pull-right';
    button = document.createElement('button');
    button.classList = 'btn btn-mini btn-primary';
    button.href = '#';
    button.title = 'Stop Interaction';
    button.innerHTML = '<i class="fa fa-power-off icon-remove icon-large"></i>';
    button.addEventListener('click', function (_evt) {
        fig.handle_close(fig, {});
    });
    button.addEventListener(
        'mouseover',
        on_mouseover_closure('Stop Interaction')
    );
    buttongrp.appendChild(button);
    var titlebar = this.root.querySelector('.ui-dialog-titlebar');
    titlebar.insertBefore(buttongrp, titlebar.firstChild);
};

mpl.figure.prototype._remove_fig_handler = function (event) {
    var fig = event.data.fig;
    if (event.target !== this) {
        // Ignore bubbled events from children.
        return;
    }
    fig.close_ws(fig, {});
};

mpl.figure.prototype._root_extra_style = function (el) {
    el.style.boxSizing = 'content-box'; // override notebook setting of border-box.
};

mpl.figure.prototype._canvas_extra_style = function (el) {
    // this is important to make the div 'focusable
    el.setAttribute('tabindex', 0);
    // reach out to IPython and tell the keyboard manager to turn it's self
    // off when our div gets focus

    // location in version 3
    if (IPython.notebook.keyboard_manager) {
        IPython.notebook.keyboard_manager.register_events(el);
    } else {
        // location in version 2
        IPython.keyboard_manager.register_events(el);
    }
};

mpl.figure.prototype._key_event_extra = function (event, _name) {
    // Check for shift+enter
    if (event.shiftKey && event.which === 13) {
        this.canvas_div.blur();
        // select the cell after this one
        var index = IPython.notebook.find_cell_index(this.cell_info[0]);
        IPython.notebook.select(index + 1);
    }
};

mpl.figure.prototype.handle_save = function (fig, _msg) {
    fig.ondownload(fig, null);
};

mpl.find_output_cell = function (html_output) {
    // Return the cell and output element which can be found *uniquely* in the notebook.
    // Note - this is a bit hacky, but it is done because the "notebook_saving.Notebook"
    // IPython event is triggered only after the cells have been serialised, which for
    // our purposes (turning an active figure into a static one), is too late.
    var cells = IPython.notebook.get_cells();
    var ncells = cells.length;
    for (var i = 0; i < ncells; i++) {
        var cell = cells[i];
        if (cell.cell_type === 'code') {
            for (var j = 0; j < cell.output_area.outputs.length; j++) {
                var data = cell.output_area.outputs[j];
                if (data.data) {
                    // IPython >= 3 moved mimebundle to data attribute of output
                    data = data.data;
                }
                if (data['text/html'] === html_output) {
                    return [cell, data, j];
                }
            }
        }
    }
};

// Register the function which deals with the matplotlib target/channel.
// The kernel may be null if the page has been refreshed.
if (IPython.notebook.kernel !== null) {
    IPython.notebook.kernel.comm_manager.register_target(
        'matplotlib',
        mpl.mpl_figure_comm
    );
}

</script>
</div>
<div class="cell-output cell-output-display">
<img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAA+gAAAH0CAYAAACuKActAAAAAXNSR0IArs4c6QAAAERlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAA6ABAAMAAAABAAEAAKACAAQAAAABAAAD6KADAAQAAAABAAAB9AAAAADw81QvAABAAElEQVR4AezdC3wU1dn48SdACESwCBQSlLtVURQQqoAgRBsEKlqxvqitogKtIlpMqS1SLdhSWmsptQoKSqm31r61+teCSqrhoqDl6uUtUkUQlZtyh2ASwv7nmXSWvWdns5udy+/4WXd35szMOd+z7OaZc+ZMTsBIQkIAAQQQQAABBBBAAAEEEEAAgawKNMjq0Tk4AggggAACCCCAAAIIIIAAAgiYAgTofBAQQAABBBBAAAEEEEAAAQQQcIAAAboDGoEiIIAAAggggAACCCCAAAIIIECAzmcAAQQQQAABBBBAAAEEEEAAAQcIEKA7oBEoAgIIIIAAAggggAACCCCAAAIE6HwGEEAAAQQQQAABBBBAAAEEEHCAAAG6AxqBIiCAAAIIIIAAAggggAACCCBAgM5nAAEEEEAAAQQQQAABBBBAAAEHCBCgO6ARKAICCCCAAAIIIIAAAggggAACBOh8BhBAAAEEEEAAAQQQQAABBBBwgAABugMagSIggAACCCCAAAIIIIAAAgggQIDOZwABBBBAAAEEEEAAAQQQQAABBwgQoDugESgCAggggAACCCCAAAIIIIAAAgTofAYQQAABBBBAAAEEEEAAAQQQcIAAAboDGoEiIIAAAggggAACCCCAAAIIIECAzmcAAQQQQAABBBBAAAEEEEAAAQcIEKA7oBEoAgIIIIAAAggggAACCCCAAAIE6HwGEEAAAQQQQAABBBBAAAEEEHCAAAG6AxqBIiCAAAIIIIAAAggggAACCCBAgM5nAAEEEEAAAQQQQAABBBBAAAEHCBCgO6ARKAICCCCAAAIIIIAAAggggAACBOh8BhBAAAEEEEAAAQQQQAABBBBwgAABugMagSIggAACCCCAAAIIIIAAAgggQIDOZwABBBBAAAEEEEAAAQQQQAABBwgQoDugESgCAggggAACCCCAAAIIIIAAAgTofAYQQAABBBBAAAEEEEAAAQQQcIAAAboDGoEiIIAAAggggAACCCCAAAIIIECAzmcAAQQQQAABBBBA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U5Iof2/tn7HlOdtvKk1/1rSUpf/7N768qmkefVNTkdan7Ust+7CpbMOlsktMZVPZJgt9U+WS5y+15UO2+atrzdQoHjmPzzCPR2zjXduLpwYmN4ArXWdeKuj5558fVq9enUx26NAhzJgxIzz++ONJ2ldffRXuuOOO0K1bt3DrrbeWPuKdAAECBAi0mcDGjRuTa883bdqU3A9l3bp1SZ80dOjQFo+et1nhrIgAAQIECGRQwBH0dmi04jV6Ydu2bclrwIABZSUoHXmIifGZsqWbusXphx9+OPz222/hnnvuSU6RjKfGx2V17949zjYQIECAAIE2FejatWt4/fXXQ/Ga8vDLL7+Efv36JY8Rfe211yqevdWmhbMyAgQIECCQQQEBejs0WjzyHV8nGhoH6zFvPIo+d+7c5HWiz7Y0P55WGH9IVTrtvaXP1EM6l5ZbmU1lGy6VXWIqm8o2eXS56KKLwrvvvlu5wilS82iTovotZuXSIo3vmRZobDMtwBST2VS24VLZpT1T3SSuPfWtmwABAgQIECBAgAABAgQI/C3gGnSbAgECBAgQIECAAAECBAgQqAEBAXoNNIIiECBAgAABAgQIECBAgAABAbptgAABAgQIECBAgAABAgQI1ICAAL0GGkERCBAgQIAAAQIECBAgQICAAL2Ot4EJEyaEQYMGhS5duiSPxpk6dWqIz2iv92HXrl1h2rRpYciQISE+Qig+zzfe+f7o0aP1ThMee+yxMHr06NCtW7fQs2fPuvZ48cUXk20k7j8jRowIH3zwQV17xMq///77Yfz48aF///7JUyfeeOONujeJAE888US47LLLkkdinn322WHSpEnJYzThVBbQNzV30S81N2mcom86rqFvOm5RGtM3lSTK3/VN5R61NCVAr6XWaOOyXHvttWHlypXJD8VVq1aF7du3hylTprRxKWpvdVu2bAnHjh0LixYtCps3bw7z5s0LL730Upg1a1btFbaNSxT/SXHzzTeHu+++u43XXFurW7FiRZgxY0aYPXt2+Pzzz8NVV10VbrjhhrB79+7aKmgblyY+B/viiy8OCxYsaOM11/bq1q9fH+69997w0UcfhbVr14Y//vgjjB07NnlueG2XvH1Kp29q7q5fam7SOEXf9JeGvqnxVnF8XN903KLxmL6psUZtjXvMWm21R7uW5q233kqO7Bw5ciR06tSpXctSayt/+umnw8KFC8OOHTtqrWjtUp4lS5YkAeqhQ4faZf3tvdKRI0eGSy65JNkmSmW54IILkv0n/kfaEJIj6KtXr05MeJQL7N+/P8Qj6fHH0dVXX10+01QzAX1TM5IkQb/U3EXfpG9qvlWUp3To0CHom8pNSlP6ppJE+787gt7+bVATJTh48GBYtmxZcvqy4Lx5kxw+fDj06tWr+QwpdScQj9R8+umnyRHQxpWPR0Q3bNjQOMk4gYoC8fskDr5TKvKUJeqbyjjKJvRLZRx1P6FvqvtN4D8D6Jv+M+FJW4AA/aRRZnNBM2fODKeddlo466yzktNz33zzzWxWpIqljqf+z58/P9x1111VXItFZ0XgwIED4c8//wx9+vQpK3Kc3rdvX1maCQJNBQqFQnjwwQfDlVdeGS688MKms03/LaBvan1T0C+17lOPc/VN9djqJ6/O+qaTZ3kyliRAPxmKNbSMuXPnJqeWxlN4Wnp98sknDSV+6KGHkmto16xZEzp27Bhuu+22EHfSPA5pbaJBvGneuHHjkuuup0+fnkeW8G9ccgmRslJx/2o8xP2maVrj+cYJRIH77rsvfPHFF+HVV1+tK5C03zP10jeldYkbTT30S7Ge/8Ymfq7eh6b9kL6p3reIf1b/eu2b/plO2+f6X9uv0hqrKRB3sFtuuaXVVZxzzjkN83v37h3i67zzzgvxGtqBAwcmNzIaNWpUQ568jKS1iT+C4s2KosXLL7+cF4Zm9Ujr0mwBdZYQ95f4z6ymR8u/++67ZkfV64xGdU8gcP/994d4PXW8o/CAAQNOkDtfs9N+z9RL35TWpV76pbj1p7XJ1x6Tvjb6pvRmPvGXQD33TbW6DQjQa7Vl/mW5Sj9q/s3HS0fO403i8jiksdm7d28SnMfHZy1evDicckp+TzZJ45LH7SJtnU499dTksWrxbtyTJ09u+HicnjhxYsO0EQIlgfjdGn8AxRsTvffee8nj+Urz6uX9v3zP5LlvSuNST/1S3C/S2NTLftRaPfVNremYV0lA31RJpTbSBOi10Q5tXoqNGzeG+IrXQZ555pnJ3cnnzJmTPPM7j0fP0wDHIxRjxoxJnhH/zDPPhHhXy9LQt2/f0mhdvsfHiMWbNsX3eB32pk2bEodhw4aF008/vW5M4jXEU6dODZdeemnDGRbRpN7vU/Dzzz+Hbdu2NWwHO3fuTLaReDO0QYMGNaTX20h8xNry5ctDvMdH9+7dG86+6NGjR+jatWu9cbRaX31TZR79UmWXUqq+6S8JfVNpiyh/1zeVe5Sm9E0liRp8L/73xFCHAsVrIAvF07cLxR/Ohc6dOxeKp70XisFFYc+ePXWoUV7l4hHzeBF+xVd5zvqbuv322yu6rFu3ru4wXnjhhcLgwYMLxaMWheIj1wrFR2bVnUHTCsftoNK+E7ebeh4qmcS0+F1jKBfQN5V7lKb0SyWJyu/6puMu+qbjFqUxfVNJovxd31TuUUtTnoNe3DoNBAgQIECAAAECBAgQIECgvQXye2Fte8taPwECBAgQIECAAAECBAgQSCEgQE+BJSsBAgQIECBAgAABAgQIEKiWgAC9WrKWS4AAAQIECBAgQIAAAQIEUggI0FNgyUqAAAECBAgQIECAAAECBKolIECvlqzlEiBAgAABAgQIECBAgACBFAIC9BRYshIgQIAAAQIECBAgQIAAgWoJCNCrJWu5BAgQIECAAAECBAgQIEAghYAAPQWWrAQIECBAgAABAgQIECBAoFoCAvRqyVouAQIECBAgQIAAAQIECBBIISBAT4ElKwECBAgQIECAAAECBAgQqJaAAL1aspZLgAABAgQIECBAgAABAgRSCAjQU2DJSoAAAQIECBAgQIAAAQIEqiUgQK+WrOUSIECAAAECBAgQIECAAIEUAgL0FFiyEiBAgAABAgQIECBAgACBagkI0Ksla7kECBAgQIAAAQIECBAgQCCFgAA9BZasBAgQIECAAAECBAgQIECgWgIC9GrJWi4BAgQIECBAgAABAgQIEEghIEBPgSUrAQIECBAgQIAAAQIECBColoAAvVqylkuAAAECBAgQIECAAAECBFIICNBTYMlKgAABAgQIECBAgAABAgSqJSBAr5as5RIgQIAAAQIECBAgQIAAgRQCAvQUWLISIECAAAECBAgQIECAAIFqCQjQqyVruQQIECBAgAABAgQIECBAIIWAAD0FlqwECBAgQIAAAQIECBAgQKBaAgL0aslaLgECBAgQIECAAAECBAgQSCEgQE+BJSsBAgQIECBAgAABAgQIEKiWgAC9WrKWS4AAAQIECBAgQIAAAQIEUggI0FNgyUqAAAECBAgQIECAAAECBKolIECvlqzlEiBAgAABAgQIECBAgACBFAIC9BRYshIgQIAAAQIECBAgQIAAgWoJCNCrJWu5BAgQIECAAAECBAgQIEAghYAAPQWWrAQIECBAgAABAgQIECBAoFoCAvRqyVouAQIECBAgQIAAAQIECBBIIfB/tDvj3SfoUG0AAAAASUVORK5CYII=" width="1000">
</div>
</div>
<ul>
<li>If we now add a second pole, there will be two rotations around the origin, one for each pole</li>
</ul>
<div class="cell">
<div class="sourceCode cell-code" id="cb10"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="co"># %matplotlib notebook</span></span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a>fig, axs <span class="op">=</span> plt.subplots(<span class="dv">1</span>, <span class="dv">2</span>, figsize<span class="op">=</span>(<span class="dv">10</span>, <span class="dv">5</span>))<span class="op">;</span></span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a>line_0, <span class="op">=</span> axs[<span class="dv">0</span>].plot([])     <span class="co"># A tuple unpacking to unpack the only plot</span></span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a>line_1, <span class="op">=</span> axs[<span class="dv">1</span>].plot([])     <span class="co"># A tuple unpacking to unpack the only plot</span></span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true" tabindex="-1"></a>axs[<span class="dv">0</span>].grid()</span>
<span id="cb10-6"><a href="#cb10-6" aria-hidden="true" tabindex="-1"></a>axs[<span class="dv">1</span>].grid()</span>
<span id="cb10-7"><a href="#cb10-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-8"><a href="#cb10-8" aria-hidden="true" tabindex="-1"></a>xoff <span class="op">=</span> <span class="op">-</span><span class="fl">0.75</span>  <span class="co"># X-offset of the contour</span></span>
<span id="cb10-9"><a href="#cb10-9" aria-hidden="true" tabindex="-1"></a>yoff <span class="op">=</span> <span class="dv">0</span><span class="op">;</span>     <span class="co"># Y-offset of the contour</span></span>
<span id="cb10-10"><a href="#cb10-10" aria-hidden="true" tabindex="-1"></a>angles <span class="op">=</span> np.linspace(<span class="dv">2</span><span class="op">*</span>np.pi, <span class="dv">0</span>, <span class="dv">160</span>)<span class="op">;</span>  <span class="co"># Generate angles around the circle; 160 is tje Number of points around the circular contour</span></span>
<span id="cb10-11"><a href="#cb10-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-12"><a href="#cb10-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-13"><a href="#cb10-13" aria-hidden="true" tabindex="-1"></a>pt <span class="op">=</span> [np.cos(angles)<span class="op">+</span>xoff, np.sin(angles)<span class="op">+</span>yoff]<span class="op">;</span> </span>
<span id="cb10-14"><a href="#cb10-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-15"><a href="#cb10-15" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> animate_plot(<span class="bu">bin</span>):    </span>
<span id="cb10-16"><a href="#cb10-16" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Set 's' to the next point on the contour</span></span>
<span id="cb10-17"><a href="#cb10-17" aria-hidden="true" tabindex="-1"></a>    s <span class="op">=</span> <span class="bu">complex</span>(pt[<span class="dv">0</span>][<span class="bu">bin</span>], pt[<span class="dv">1</span>][<span class="bu">bin</span>])<span class="op">;</span></span>
<span id="cb10-18"><a href="#cb10-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-19"><a href="#cb10-19" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Plot the next point on the contour in the s-plane    </span></span>
<span id="cb10-20"><a href="#cb10-20" aria-hidden="true" tabindex="-1"></a>    line_0 <span class="op">=</span> axs[<span class="dv">0</span>].plot(np.real(s), np.imag(s), color<span class="op">=</span><span class="st">'red'</span>, marker<span class="op">=</span><span class="st">'.'</span>, markersize<span class="op">=</span><span class="dv">15</span>)<span class="op">;</span></span>
<span id="cb10-21"><a href="#cb10-21" aria-hidden="true" tabindex="-1"></a>    axs[<span class="dv">0</span>].set_title(<span class="st">'S-plane Contour'</span>)<span class="op">;</span></span>
<span id="cb10-22"><a href="#cb10-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-23"><a href="#cb10-23" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Define the system transfer function</span></span>
<span id="cb10-24"><a href="#cb10-24" aria-hidden="true" tabindex="-1"></a>   </span>
<span id="cb10-25"><a href="#cb10-25" aria-hidden="true" tabindex="-1"></a>    <span class="co">#  2 poles only</span></span>
<span id="cb10-26"><a href="#cb10-26" aria-hidden="true" tabindex="-1"></a>    tnf <span class="op">=</span> <span class="dv">1</span><span class="op">/</span>((s <span class="op">+</span> <span class="dv">1</span>)<span class="op">*</span>(s <span class="op">+</span> <span class="fl">0.8</span>))<span class="op">;</span> </span>
<span id="cb10-27"><a href="#cb10-27" aria-hidden="true" tabindex="-1"></a>    axs[<span class="dv">0</span>].plot([<span class="op">-</span><span class="dv">1</span>] , [<span class="dv">0</span>], color<span class="op">=</span><span class="st">'blue'</span>, marker<span class="op">=</span><span class="st">'x'</span>, markersize<span class="op">=</span><span class="dv">10</span>)<span class="op">;</span></span>
<span id="cb10-28"><a href="#cb10-28" aria-hidden="true" tabindex="-1"></a>    axs[<span class="dv">0</span>].plot([<span class="op">-</span><span class="fl">.8</span>], [<span class="dv">0</span>], color<span class="op">=</span><span class="st">'blue'</span>, marker<span class="op">=</span><span class="st">'x'</span>, markersize<span class="op">=</span><span class="dv">10</span>)<span class="op">;</span></span>
<span id="cb10-29"><a href="#cb10-29" aria-hidden="true" tabindex="-1"></a>    axs[<span class="dv">0</span>].set_xlim([<span class="op">-</span><span class="dv">3</span>, <span class="dv">2</span>])</span>
<span id="cb10-30"><a href="#cb10-30" aria-hidden="true" tabindex="-1"></a>    axs[<span class="dv">0</span>].set_ylim([<span class="op">-</span><span class="dv">2</span>, <span class="dv">2</span>])<span class="op">;</span></span>
<span id="cb10-31"><a href="#cb10-31" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-32"><a href="#cb10-32" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-33"><a href="#cb10-33" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Plot the mapping from the TF in the w-plane    </span></span>
<span id="cb10-34"><a href="#cb10-34" aria-hidden="true" tabindex="-1"></a>    line_1 <span class="op">=</span> axs[<span class="dv">1</span>].plot(np.real(tnf), np.imag(tnf), color<span class="op">=</span><span class="st">'g'</span>, marker<span class="op">=</span><span class="st">'.'</span>, markersize<span class="op">=</span><span class="dv">15</span>)<span class="op">;</span></span>
<span id="cb10-35"><a href="#cb10-35" aria-hidden="true" tabindex="-1"></a>    axs[<span class="dv">1</span>].plot(<span class="dv">0</span>, <span class="dv">0</span>, marker<span class="op">=</span><span class="st">'.'</span>, color<span class="op">=</span><span class="st">'k'</span>, markersize<span class="op">=</span><span class="dv">15</span>)<span class="op">;</span></span>
<span id="cb10-36"><a href="#cb10-36" aria-hidden="true" tabindex="-1"></a>    axs[<span class="dv">1</span>].set_title(<span class="st">'$\Omega$-plane Plot'</span>)<span class="op">;</span>        </span>
<span id="cb10-37"><a href="#cb10-37" aria-hidden="true" tabindex="-1"></a>    axs[<span class="dv">1</span>].set_xlim([<span class="op">-</span><span class="dv">3</span>, <span class="dv">2</span>])</span>
<span id="cb10-38"><a href="#cb10-38" aria-hidden="true" tabindex="-1"></a>    axs[<span class="dv">1</span>].set_ylim([<span class="op">-</span><span class="dv">3</span>, <span class="dv">2</span>])<span class="op">;</span></span>
<span id="cb10-39"><a href="#cb10-39" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-40"><a href="#cb10-40" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> line_0, line_1</span>
<span id="cb10-41"><a href="#cb10-41" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-42"><a href="#cb10-42" aria-hidden="true" tabindex="-1"></a>anim <span class="op">=</span> FuncAnimation(fig, animate_plot, frames<span class="op">=</span><span class="bu">len</span>(angles), interval<span class="op">=</span><span class="dv">20</span>)</span>
<span id="cb10-43"><a href="#cb10-43" aria-hidden="true" tabindex="-1"></a>anim<span class="op">;</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<script type="application/javascript">
/* Put everything inside the global mpl namespace */
/* global mpl */
window.mpl = {};

mpl.get_websocket_type = function () {
    if (typeof WebSocket !== 'undefined') {
        return WebSocket;
    } else if (typeof MozWebSocket !== 'undefined') {
        return MozWebSocket;
    } else {
        alert(
            'Your browser does not have WebSocket support. ' +
                'Please try Chrome, Safari or Firefox ‚â• 6. ' +
                'Firefox 4 and 5 are also supported but you ' +
                'have to enable WebSockets in about:config.'
        );
    }
};

mpl.figure = function (figure_id, websocket, ondownload, parent_element) {
    this.id = figure_id;

    this.ws = websocket;

    this.supports_binary = this.ws.binaryType !== undefined;

    if (!this.supports_binary) {
        var warnings = document.getElementById('mpl-warnings');
        if (warnings) {
            warnings.style.display = 'block';
            warnings.textContent =
                'This browser does not support binary websocket messages. ' +
                'Performance may be slow.';
        }
    }

    this.imageObj = new Image();

    this.context = undefined;
    this.message = undefined;
    this.canvas = undefined;
    this.rubberband_canvas = undefined;
    this.rubberband_context = undefined;
    this.format_dropdown = undefined;

    this.image_mode = 'full';

    this.root = document.createElement('div');
    this.root.setAttribute('style', 'display: inline-block');
    this._root_extra_style(this.root);

    parent_element.appendChild(this.root);

    this._init_header(this);
    this._init_canvas(this);
    this._init_toolbar(this);

    var fig = this;

    this.waiting = false;

    this.ws.onopen = function () {
        fig.send_message('supports_binary', { value: fig.supports_binary });
        fig.send_message('send_image_mode', {});
        if (fig.ratio !== 1) {
            fig.send_message('set_device_pixel_ratio', {
                device_pixel_ratio: fig.ratio,
            });
        }
        fig.send_message('refresh', {});
    };

    this.imageObj.onload = function () {
        if (fig.image_mode === 'full') {
            // Full images could contain transparency (where diff images
            // almost always do), so we need to clear the canvas so that
            // there is no ghosting.
            fig.context.clearRect(0, 0, fig.canvas.width, fig.canvas.height);
        }
        fig.context.drawImage(fig.imageObj, 0, 0);
    };

    this.imageObj.onunload = function () {
        fig.ws.close();
    };

    this.ws.onmessage = this._make_on_message_function(this);

    this.ondownload = ondownload;
};

mpl.figure.prototype._init_header = function () {
    var titlebar = document.createElement('div');
    titlebar.classList =
        'ui-dialog-titlebar ui-widget-header ui-corner-all ui-helper-clearfix';
    var titletext = document.createElement('div');
    titletext.classList = 'ui-dialog-title';
    titletext.setAttribute(
        'style',
        'width: 100%; text-align: center; padding: 3px;'
    );
    titlebar.appendChild(titletext);
    this.root.appendChild(titlebar);
    this.header = titletext;
};

mpl.figure.prototype._canvas_extra_style = function (_canvas_div) {};

mpl.figure.prototype._root_extra_style = function (_canvas_div) {};

mpl.figure.prototype._init_canvas = function () {
    var fig = this;

    var canvas_div = (this.canvas_div = document.createElement('div'));
    canvas_div.setAttribute(
        'style',
        'border: 1px solid #ddd;' +
            'box-sizing: content-box;' +
            'clear: both;' +
            'min-height: 1px;' +
            'min-width: 1px;' +
            'outline: 0;' +
            'overflow: hidden;' +
            'position: relative;' +
            'resize: both;'
    );

    function on_keyboard_event_closure(name) {
        return function (event) {
            return fig.key_event(event, name);
        };
    }

    canvas_div.addEventListener(
        'keydown',
        on_keyboard_event_closure('key_press')
    );
    canvas_div.addEventListener(
        'keyup',
        on_keyboard_event_closure('key_release')
    );

    this._canvas_extra_style(canvas_div);
    this.root.appendChild(canvas_div);

    var canvas = (this.canvas = document.createElement('canvas'));
    canvas.classList.add('mpl-canvas');
    canvas.setAttribute('style', 'box-sizing: content-box;');

    this.context = canvas.getContext('2d');

    var backingStore =
        this.context.backingStorePixelRatio ||
        this.context.webkitBackingStorePixelRatio ||
        this.context.mozBackingStorePixelRatio ||
        this.context.msBackingStorePixelRatio ||
        this.context.oBackingStorePixelRatio ||
        this.context.backingStorePixelRatio ||
        1;

    this.ratio = (window.devicePixelRatio || 1) / backingStore;

    var rubberband_canvas = (this.rubberband_canvas = document.createElement(
        'canvas'
    ));
    rubberband_canvas.setAttribute(
        'style',
        'box-sizing: content-box; position: absolute; left: 0; top: 0; z-index: 1;'
    );

    // Apply a ponyfill if ResizeObserver is not implemented by browser.
    if (this.ResizeObserver === undefined) {
        if (window.ResizeObserver !== undefined) {
            this.ResizeObserver = window.ResizeObserver;
        } else {
            var obs = _JSXTOOLS_RESIZE_OBSERVER({});
            this.ResizeObserver = obs.ResizeObserver;
        }
    }

    this.resizeObserverInstance = new this.ResizeObserver(function (entries) {
        var nentries = entries.length;
        for (var i = 0; i < nentries; i++) {
            var entry = entries[i];
            var width, height;
            if (entry.contentBoxSize) {
                if (entry.contentBoxSize instanceof Array) {
                    // Chrome 84 implements new version of spec.
                    width = entry.contentBoxSize[0].inlineSize;
                    height = entry.contentBoxSize[0].blockSize;
                } else {
                    // Firefox implements old version of spec.
                    width = entry.contentBoxSize.inlineSize;
                    height = entry.contentBoxSize.blockSize;
                }
            } else {
                // Chrome <84 implements even older version of spec.
                width = entry.contentRect.width;
                height = entry.contentRect.height;
            }

            // Keep the size of the canvas and rubber band canvas in sync with
            // the canvas container.
            if (entry.devicePixelContentBoxSize) {
                // Chrome 84 implements new version of spec.
                canvas.setAttribute(
                    'width',
                    entry.devicePixelContentBoxSize[0].inlineSize
                );
                canvas.setAttribute(
                    'height',
                    entry.devicePixelContentBoxSize[0].blockSize
                );
            } else {
                canvas.setAttribute('width', width * fig.ratio);
                canvas.setAttribute('height', height * fig.ratio);
            }
            canvas.setAttribute(
                'style',
                'width: ' + width + 'px; height: ' + height + 'px;'
            );

            rubberband_canvas.setAttribute('width', width);
            rubberband_canvas.setAttribute('height', height);

            // And update the size in Python. We ignore the initial 0/0 size
            // that occurs as the element is placed into the DOM, which should
            // otherwise not happen due to the minimum size styling.
            if (fig.ws.readyState == 1 && width != 0 && height != 0) {
                fig.request_resize(width, height);
            }
        }
    });
    this.resizeObserverInstance.observe(canvas_div);

    function on_mouse_event_closure(name) {
        return function (event) {
            return fig.mouse_event(event, name);
        };
    }

    rubberband_canvas.addEventListener(
        'mousedown',
        on_mouse_event_closure('button_press')
    );
    rubberband_canvas.addEventListener(
        'mouseup',
        on_mouse_event_closure('button_release')
    );
    rubberband_canvas.addEventListener(
        'dblclick',
        on_mouse_event_closure('dblclick')
    );
    // Throttle sequential mouse events to 1 every 20ms.
    rubberband_canvas.addEventListener(
        'mousemove',
        on_mouse_event_closure('motion_notify')
    );

    rubberband_canvas.addEventListener(
        'mouseenter',
        on_mouse_event_closure('figure_enter')
    );
    rubberband_canvas.addEventListener(
        'mouseleave',
        on_mouse_event_closure('figure_leave')
    );

    canvas_div.addEventListener('wheel', function (event) {
        if (event.deltaY < 0) {
            event.step = 1;
        } else {
            event.step = -1;
        }
        on_mouse_event_closure('scroll')(event);
    });

    canvas_div.appendChild(canvas);
    canvas_div.appendChild(rubberband_canvas);

    this.rubberband_context = rubberband_canvas.getContext('2d');
    this.rubberband_context.strokeStyle = '#000000';

    this._resize_canvas = function (width, height, forward) {
        if (forward) {
            canvas_div.style.width = width + 'px';
            canvas_div.style.height = height + 'px';
        }
    };

    // Disable right mouse context menu.
    this.rubberband_canvas.addEventListener('contextmenu', function (_e) {
        event.preventDefault();
        return false;
    });

    function set_focus() {
        canvas.focus();
        canvas_div.focus();
    }

    window.setTimeout(set_focus, 100);
};

mpl.figure.prototype._init_toolbar = function () {
    var fig = this;

    var toolbar = document.createElement('div');
    toolbar.classList = 'mpl-toolbar';
    this.root.appendChild(toolbar);

    function on_click_closure(name) {
        return function (_event) {
            return fig.toolbar_button_onclick(name);
        };
    }

    function on_mouseover_closure(tooltip) {
        return function (event) {
            if (!event.currentTarget.disabled) {
                return fig.toolbar_button_onmouseover(tooltip);
            }
        };
    }

    fig.buttons = {};
    var buttonGroup = document.createElement('div');
    buttonGroup.classList = 'mpl-button-group';
    for (var toolbar_ind in mpl.toolbar_items) {
        var name = mpl.toolbar_items[toolbar_ind][0];
        var tooltip = mpl.toolbar_items[toolbar_ind][1];
        var image = mpl.toolbar_items[toolbar_ind][2];
        var method_name = mpl.toolbar_items[toolbar_ind][3];

        if (!name) {
            /* Instead of a spacer, we start a new button group. */
            if (buttonGroup.hasChildNodes()) {
                toolbar.appendChild(buttonGroup);
            }
            buttonGroup = document.createElement('div');
            buttonGroup.classList = 'mpl-button-group';
            continue;
        }

        var button = (fig.buttons[name] = document.createElement('button'));
        button.classList = 'mpl-widget';
        button.setAttribute('role', 'button');
        button.setAttribute('aria-disabled', 'false');
        button.addEventListener('click', on_click_closure(method_name));
        button.addEventListener('mouseover', on_mouseover_closure(tooltip));

        var icon_img = document.createElement('img');
        icon_img.src = '_images/' + image + '.png';
        icon_img.srcset = '_images/' + image + '_large.png 2x';
        icon_img.alt = tooltip;
        button.appendChild(icon_img);

        buttonGroup.appendChild(button);
    }

    if (buttonGroup.hasChildNodes()) {
        toolbar.appendChild(buttonGroup);
    }

    var fmt_picker = document.createElement('select');
    fmt_picker.classList = 'mpl-widget';
    toolbar.appendChild(fmt_picker);
    this.format_dropdown = fmt_picker;

    for (var ind in mpl.extensions) {
        var fmt = mpl.extensions[ind];
        var option = document.createElement('option');
        option.selected = fmt === mpl.default_extension;
        option.innerHTML = fmt;
        fmt_picker.appendChild(option);
    }

    var status_bar = document.createElement('span');
    status_bar.classList = 'mpl-message';
    toolbar.appendChild(status_bar);
    this.message = status_bar;
};

mpl.figure.prototype.request_resize = function (x_pixels, y_pixels) {
    // Request matplotlib to resize the figure. Matplotlib will then trigger a resize in the client,
    // which will in turn request a refresh of the image.
    this.send_message('resize', { width: x_pixels, height: y_pixels });
};

mpl.figure.prototype.send_message = function (type, properties) {
    properties['type'] = type;
    properties['figure_id'] = this.id;
    this.ws.send(JSON.stringify(properties));
};

mpl.figure.prototype.send_draw_message = function () {
    if (!this.waiting) {
        this.waiting = true;
        this.ws.send(JSON.stringify({ type: 'draw', figure_id: this.id }));
    }
};

mpl.figure.prototype.handle_save = function (fig, _msg) {
    var format_dropdown = fig.format_dropdown;
    var format = format_dropdown.options[format_dropdown.selectedIndex].value;
    fig.ondownload(fig, format);
};

mpl.figure.prototype.handle_resize = function (fig, msg) {
    var size = msg['size'];
    if (size[0] !== fig.canvas.width || size[1] !== fig.canvas.height) {
        fig._resize_canvas(size[0], size[1], msg['forward']);
        fig.send_message('refresh', {});
    }
};

mpl.figure.prototype.handle_rubberband = function (fig, msg) {
    var x0 = msg['x0'] / fig.ratio;
    var y0 = (fig.canvas.height - msg['y0']) / fig.ratio;
    var x1 = msg['x1'] / fig.ratio;
    var y1 = (fig.canvas.height - msg['y1']) / fig.ratio;
    x0 = Math.floor(x0) + 0.5;
    y0 = Math.floor(y0) + 0.5;
    x1 = Math.floor(x1) + 0.5;
    y1 = Math.floor(y1) + 0.5;
    var min_x = Math.min(x0, x1);
    var min_y = Math.min(y0, y1);
    var width = Math.abs(x1 - x0);
    var height = Math.abs(y1 - y0);

    fig.rubberband_context.clearRect(
        0,
        0,
        fig.canvas.width / fig.ratio,
        fig.canvas.height / fig.ratio
    );

    fig.rubberband_context.strokeRect(min_x, min_y, width, height);
};

mpl.figure.prototype.handle_figure_label = function (fig, msg) {
    // Updates the figure title.
    fig.header.textContent = msg['label'];
};

mpl.figure.prototype.handle_cursor = function (fig, msg) {
    fig.rubberband_canvas.style.cursor = msg['cursor'];
};

mpl.figure.prototype.handle_message = function (fig, msg) {
    fig.message.textContent = msg['message'];
};

mpl.figure.prototype.handle_draw = function (fig, _msg) {
    // Request the server to send over a new figure.
    fig.send_draw_message();
};

mpl.figure.prototype.handle_image_mode = function (fig, msg) {
    fig.image_mode = msg['mode'];
};

mpl.figure.prototype.handle_history_buttons = function (fig, msg) {
    for (var key in msg) {
        if (!(key in fig.buttons)) {
            continue;
        }
        fig.buttons[key].disabled = !msg[key];
        fig.buttons[key].setAttribute('aria-disabled', !msg[key]);
    }
};

mpl.figure.prototype.handle_navigate_mode = function (fig, msg) {
    if (msg['mode'] === 'PAN') {
        fig.buttons['Pan'].classList.add('active');
        fig.buttons['Zoom'].classList.remove('active');
    } else if (msg['mode'] === 'ZOOM') {
        fig.buttons['Pan'].classList.remove('active');
        fig.buttons['Zoom'].classList.add('active');
    } else {
        fig.buttons['Pan'].classList.remove('active');
        fig.buttons['Zoom'].classList.remove('active');
    }
};

mpl.figure.prototype.updated_canvas_event = function () {
    // Called whenever the canvas gets updated.
    this.send_message('ack', {});
};

// A function to construct a web socket function for onmessage handling.
// Called in the figure constructor.
mpl.figure.prototype._make_on_message_function = function (fig) {
    return function socket_on_message(evt) {
        if (evt.data instanceof Blob) {
            var img = evt.data;
            if (img.type !== 'image/png') {
                /* FIXME: We get "Resource interpreted as Image but
                 * transferred with MIME type text/plain:" errors on
                 * Chrome.  But how to set the MIME type?  It doesn't seem
                 * to be part of the websocket stream */
                img.type = 'image/png';
            }

            /* Free the memory for the previous frames */
            if (fig.imageObj.src) {
                (window.URL || window.webkitURL).revokeObjectURL(
                    fig.imageObj.src
                );
            }

            fig.imageObj.src = (window.URL || window.webkitURL).createObjectURL(
                img
            );
            fig.updated_canvas_event();
            fig.waiting = false;
            return;
        } else if (
            typeof evt.data === 'string' &&
            evt.data.slice(0, 21) === 'data:image/png;base64'
        ) {
            fig.imageObj.src = evt.data;
            fig.updated_canvas_event();
            fig.waiting = false;
            return;
        }

        var msg = JSON.parse(evt.data);
        var msg_type = msg['type'];

        // Call the  "handle_{type}" callback, which takes
        // the figure and JSON message as its only arguments.
        try {
            var callback = fig['handle_' + msg_type];
        } catch (e) {
            console.log(
                "No handler for the '" + msg_type + "' message type: ",
                msg
            );
            return;
        }

        if (callback) {
            try {
                // console.log("Handling '" + msg_type + "' message: ", msg);
                callback(fig, msg);
            } catch (e) {
                console.log(
                    "Exception inside the 'handler_" + msg_type + "' callback:",
                    e,
                    e.stack,
                    msg
                );
            }
        }
    };
};

// from https://stackoverflow.com/questions/1114465/getting-mouse-location-in-canvas
mpl.findpos = function (e) {
    //this section is from http://www.quirksmode.org/js/events_properties.html
    var targ;
    if (!e) {
        e = window.event;
    }
    if (e.target) {
        targ = e.target;
    } else if (e.srcElement) {
        targ = e.srcElement;
    }
    if (targ.nodeType === 3) {
        // defeat Safari bug
        targ = targ.parentNode;
    }

    // pageX,Y are the mouse positions relative to the document
    var boundingRect = targ.getBoundingClientRect();
    var x = e.pageX - (boundingRect.left + document.body.scrollLeft);
    var y = e.pageY - (boundingRect.top + document.body.scrollTop);

    return { x: x, y: y };
};

/*
 * return a copy of an object with only non-object keys
 * we need this to avoid circular references
 * https://stackoverflow.com/a/24161582/3208463
 */
function simpleKeys(original) {
    return Object.keys(original).reduce(function (obj, key) {
        if (typeof original[key] !== 'object') {
            obj[key] = original[key];
        }
        return obj;
    }, {});
}

mpl.figure.prototype.mouse_event = function (event, name) {
    var canvas_pos = mpl.findpos(event);

    if (name === 'button_press') {
        this.canvas.focus();
        this.canvas_div.focus();
    }

    var x = canvas_pos.x * this.ratio;
    var y = canvas_pos.y * this.ratio;

    this.send_message(name, {
        x: x,
        y: y,
        button: event.button,
        step: event.step,
        guiEvent: simpleKeys(event),
    });

    /* This prevents the web browser from automatically changing to
     * the text insertion cursor when the button is pressed.  We want
     * to control all of the cursor setting manually through the
     * 'cursor' event from matplotlib */
    event.preventDefault();
    return false;
};

mpl.figure.prototype._key_event_extra = function (_event, _name) {
    // Handle any extra behaviour associated with a key event
};

mpl.figure.prototype.key_event = function (event, name) {
    // Prevent repeat events
    if (name === 'key_press') {
        if (event.key === this._key) {
            return;
        } else {
            this._key = event.key;
        }
    }
    if (name === 'key_release') {
        this._key = null;
    }

    var value = '';
    if (event.ctrlKey && event.key !== 'Control') {
        value += 'ctrl+';
    }
    else if (event.altKey && event.key !== 'Alt') {
        value += 'alt+';
    }
    else if (event.shiftKey && event.key !== 'Shift') {
        value += 'shift+';
    }

    value += 'k' + event.key;

    this._key_event_extra(event, name);

    this.send_message(name, { key: value, guiEvent: simpleKeys(event) });
    return false;
};

mpl.figure.prototype.toolbar_button_onclick = function (name) {
    if (name === 'download') {
        this.handle_save(this, null);
    } else {
        this.send_message('toolbar_button', { name: name });
    }
};

mpl.figure.prototype.toolbar_button_onmouseover = function (tooltip) {
    this.message.textContent = tooltip;
};

///////////////// REMAINING CONTENT GENERATED BY embed_js.py /////////////////
// prettier-ignore
var _JSXTOOLS_RESIZE_OBSERVER=function(A){var t,i=new WeakMap,n=new WeakMap,a=new WeakMap,r=new WeakMap,o=new Set;function s(e){if(!(this instanceof s))throw new TypeError("Constructor requires 'new' operator");i.set(this,e)}function h(){throw new TypeError("Function is not a constructor")}function c(e,t,i,n){e=0 in arguments?Number(arguments[0]):0,t=1 in arguments?Number(arguments[1]):0,i=2 in arguments?Number(arguments[2]):0,n=3 in arguments?Number(arguments[3]):0,this.right=(this.x=this.left=e)+(this.width=i),this.bottom=(this.y=this.top=t)+(this.height=n),Object.freeze(this)}function d(){t=requestAnimationFrame(d);var s=new WeakMap,p=new Set;o.forEach((function(t){r.get(t).forEach((function(i){var r=t instanceof window.SVGElement,o=a.get(t),d=r?0:parseFloat(o.paddingTop),f=r?0:parseFloat(o.paddingRight),l=r?0:parseFloat(o.paddingBottom),u=r?0:parseFloat(o.paddingLeft),g=r?0:parseFloat(o.borderTopWidth),m=r?0:parseFloat(o.borderRightWidth),w=r?0:parseFloat(o.borderBottomWidth),b=u+f,F=d+l,v=(r?0:parseFloat(o.borderLeftWidth))+m,W=g+w,y=r?0:t.offsetHeight-W-t.clientHeight,E=r?0:t.offsetWidth-v-t.clientWidth,R=b+v,z=F+W,M=r?t.width:parseFloat(o.width)-R-E,O=r?t.height:parseFloat(o.height)-z-y;if(n.has(t)){var k=n.get(t);if(k[0]===M&&k[1]===O)return}n.set(t,[M,O]);var S=Object.create(h.prototype);S.target=t,S.contentRect=new c(u,d,M,O),s.has(i)||(s.set(i,[]),p.add(i)),s.get(i).push(S)}))})),p.forEach((function(e){i.get(e).call(e,s.get(e),e)}))}return s.prototype.observe=function(i){if(i instanceof window.Element){r.has(i)||(r.set(i,new Set),o.add(i),a.set(i,window.getComputedStyle(i)));var n=r.get(i);n.has(this)||n.add(this),cancelAnimationFrame(t),t=requestAnimationFrame(d)}},s.prototype.unobserve=function(i){if(i instanceof window.Element&&r.has(i)){var n=r.get(i);n.has(this)&&(n.delete(this),n.size||(r.delete(i),o.delete(i))),n.size||r.delete(i),o.size||cancelAnimationFrame(t)}},A.DOMRectReadOnly=c,A.ResizeObserver=s,A.ResizeObserverEntry=h,A}; // eslint-disable-line
mpl.toolbar_items = [["Home", "Reset original view", "fa fa-home icon-home", "home"], ["Back", "Back to previous view", "fa fa-arrow-left icon-arrow-left", "back"], ["Forward", "Forward to next view", "fa fa-arrow-right icon-arrow-right", "forward"], ["", "", "", ""], ["Pan", "Left button pans, Right button zooms\nx/y fixes axis, CTRL fixes aspect", "fa fa-arrows icon-move", "pan"], ["Zoom", "Zoom to rectangle\nx/y fixes axis", "fa fa-square-o icon-check-empty", "zoom"], ["", "", "", ""], ["Download", "Download plot", "fa fa-floppy-o icon-save", "download"]];

mpl.extensions = ["eps", "jpeg", "pgf", "pdf", "png", "ps", "raw", "svg", "tif"];

mpl.default_extension = "png";/* global mpl */

var comm_websocket_adapter = function (comm) {
    // Create a "websocket"-like object which calls the given IPython comm
    // object with the appropriate methods. Currently this is a non binary
    // socket, so there is still some room for performance tuning.
    var ws = {};

    ws.binaryType = comm.kernel.ws.binaryType;
    ws.readyState = comm.kernel.ws.readyState;
    function updateReadyState(_event) {
        if (comm.kernel.ws) {
            ws.readyState = comm.kernel.ws.readyState;
        } else {
            ws.readyState = 3; // Closed state.
        }
    }
    comm.kernel.ws.addEventListener('open', updateReadyState);
    comm.kernel.ws.addEventListener('close', updateReadyState);
    comm.kernel.ws.addEventListener('error', updateReadyState);

    ws.close = function () {
        comm.close();
    };
    ws.send = function (m) {
        //console.log('sending', m);
        comm.send(m);
    };
    // Register the callback with on_msg.
    comm.on_msg(function (msg) {
        //console.log('receiving', msg['content']['data'], msg);
        var data = msg['content']['data'];
        if (data['blob'] !== undefined) {
            data = {
                data: new Blob(msg['buffers'], { type: data['blob'] }),
            };
        }
        // Pass the mpl event to the overridden (by mpl) onmessage function.
        ws.onmessage(data);
    });
    return ws;
};

mpl.mpl_figure_comm = function (comm, msg) {
    // This is the function which gets called when the mpl process
    // starts-up an IPython Comm through the "matplotlib" channel.

    var id = msg.content.data.id;
    // Get hold of the div created by the display call when the Comm
    // socket was opened in Python.
    var element = document.getElementById(id);
    var ws_proxy = comm_websocket_adapter(comm);

    function ondownload(figure, _format) {
        window.open(figure.canvas.toDataURL());
    }

    var fig = new mpl.figure(id, ws_proxy, ondownload, element);

    // Call onopen now - mpl needs it, as it is assuming we've passed it a real
    // web socket which is closed, not our websocket->open comm proxy.
    ws_proxy.onopen();

    fig.parent_element = element;
    fig.cell_info = mpl.find_output_cell("<div id='" + id + "'></div>");
    if (!fig.cell_info) {
        console.error('Failed to find cell for figure', id, fig);
        return;
    }
    fig.cell_info[0].output_area.element.on(
        'cleared',
        { fig: fig },
        fig._remove_fig_handler
    );
};

mpl.figure.prototype.handle_close = function (fig, msg) {
    var width = fig.canvas.width / fig.ratio;
    fig.cell_info[0].output_area.element.off(
        'cleared',
        fig._remove_fig_handler
    );
    fig.resizeObserverInstance.unobserve(fig.canvas_div);

    // Update the output cell to use the data from the current canvas.
    fig.push_to_output();
    var dataURL = fig.canvas.toDataURL();
    // Re-enable the keyboard manager in IPython - without this line, in FF,
    // the notebook keyboard shortcuts fail.
    IPython.keyboard_manager.enable();
    fig.parent_element.innerHTML =
        '<img src="' + dataURL + '" width="' + width + '">';
    fig.close_ws(fig, msg);
};

mpl.figure.prototype.close_ws = function (fig, msg) {
    fig.send_message('closing', msg);
    // fig.ws.close()
};

mpl.figure.prototype.push_to_output = function (_remove_interactive) {
    // Turn the data on the canvas into data in the output cell.
    var width = this.canvas.width / this.ratio;
    var dataURL = this.canvas.toDataURL();
    this.cell_info[1]['text/html'] =
        '<img src="' + dataURL + '" width="' + width + '">';
};

mpl.figure.prototype.updated_canvas_event = function () {
    // Tell IPython that the notebook contents must change.
    IPython.notebook.set_dirty(true);
    this.send_message('ack', {});
    var fig = this;
    // Wait a second, then push the new image to the DOM so
    // that it is saved nicely (might be nice to debounce this).
    setTimeout(function () {
        fig.push_to_output();
    }, 1000);
};

mpl.figure.prototype._init_toolbar = function () {
    var fig = this;

    var toolbar = document.createElement('div');
    toolbar.classList = 'btn-toolbar';
    this.root.appendChild(toolbar);

    function on_click_closure(name) {
        return function (_event) {
            return fig.toolbar_button_onclick(name);
        };
    }

    function on_mouseover_closure(tooltip) {
        return function (event) {
            if (!event.currentTarget.disabled) {
                return fig.toolbar_button_onmouseover(tooltip);
            }
        };
    }

    fig.buttons = {};
    var buttonGroup = document.createElement('div');
    buttonGroup.classList = 'btn-group';
    var button;
    for (var toolbar_ind in mpl.toolbar_items) {
        var name = mpl.toolbar_items[toolbar_ind][0];
        var tooltip = mpl.toolbar_items[toolbar_ind][1];
        var image = mpl.toolbar_items[toolbar_ind][2];
        var method_name = mpl.toolbar_items[toolbar_ind][3];

        if (!name) {
            /* Instead of a spacer, we start a new button group. */
            if (buttonGroup.hasChildNodes()) {
                toolbar.appendChild(buttonGroup);
            }
            buttonGroup = document.createElement('div');
            buttonGroup.classList = 'btn-group';
            continue;
        }

        button = fig.buttons[name] = document.createElement('button');
        button.classList = 'btn btn-default';
        button.href = '#';
        button.title = name;
        button.innerHTML = '<i class="fa ' + image + ' fa-lg"></i>';
        button.addEventListener('click', on_click_closure(method_name));
        button.addEventListener('mouseover', on_mouseover_closure(tooltip));
        buttonGroup.appendChild(button);
    }

    if (buttonGroup.hasChildNodes()) {
        toolbar.appendChild(buttonGroup);
    }

    // Add the status bar.
    var status_bar = document.createElement('span');
    status_bar.classList = 'mpl-message pull-right';
    toolbar.appendChild(status_bar);
    this.message = status_bar;

    // Add the close button to the window.
    var buttongrp = document.createElement('div');
    buttongrp.classList = 'btn-group inline pull-right';
    button = document.createElement('button');
    button.classList = 'btn btn-mini btn-primary';
    button.href = '#';
    button.title = 'Stop Interaction';
    button.innerHTML = '<i class="fa fa-power-off icon-remove icon-large"></i>';
    button.addEventListener('click', function (_evt) {
        fig.handle_close(fig, {});
    });
    button.addEventListener(
        'mouseover',
        on_mouseover_closure('Stop Interaction')
    );
    buttongrp.appendChild(button);
    var titlebar = this.root.querySelector('.ui-dialog-titlebar');
    titlebar.insertBefore(buttongrp, titlebar.firstChild);
};

mpl.figure.prototype._remove_fig_handler = function (event) {
    var fig = event.data.fig;
    if (event.target !== this) {
        // Ignore bubbled events from children.
        return;
    }
    fig.close_ws(fig, {});
};

mpl.figure.prototype._root_extra_style = function (el) {
    el.style.boxSizing = 'content-box'; // override notebook setting of border-box.
};

mpl.figure.prototype._canvas_extra_style = function (el) {
    // this is important to make the div 'focusable
    el.setAttribute('tabindex', 0);
    // reach out to IPython and tell the keyboard manager to turn it's self
    // off when our div gets focus

    // location in version 3
    if (IPython.notebook.keyboard_manager) {
        IPython.notebook.keyboard_manager.register_events(el);
    } else {
        // location in version 2
        IPython.keyboard_manager.register_events(el);
    }
};

mpl.figure.prototype._key_event_extra = function (event, _name) {
    // Check for shift+enter
    if (event.shiftKey && event.which === 13) {
        this.canvas_div.blur();
        // select the cell after this one
        var index = IPython.notebook.find_cell_index(this.cell_info[0]);
        IPython.notebook.select(index + 1);
    }
};

mpl.figure.prototype.handle_save = function (fig, _msg) {
    fig.ondownload(fig, null);
};

mpl.find_output_cell = function (html_output) {
    // Return the cell and output element which can be found *uniquely* in the notebook.
    // Note - this is a bit hacky, but it is done because the "notebook_saving.Notebook"
    // IPython event is triggered only after the cells have been serialised, which for
    // our purposes (turning an active figure into a static one), is too late.
    var cells = IPython.notebook.get_cells();
    var ncells = cells.length;
    for (var i = 0; i < ncells; i++) {
        var cell = cells[i];
        if (cell.cell_type === 'code') {
            for (var j = 0; j < cell.output_area.outputs.length; j++) {
                var data = cell.output_area.outputs[j];
                if (data.data) {
                    // IPython >= 3 moved mimebundle to data attribute of output
                    data = data.data;
                }
                if (data['text/html'] === html_output) {
                    return [cell, data, j];
                }
            }
        }
    }
};

// Register the function which deals with the matplotlib target/channel.
// The kernel may be null if the page has been refreshed.
if (IPython.notebook.kernel !== null) {
    IPython.notebook.kernel.comm_manager.register_target(
        'matplotlib',
        mpl.mpl_figure_comm
    );
}

</script>
</div>
<div class="cell-output cell-output-display">
<img src="data:image/png;base64,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K+/JJnlcyrhf5K3T+973vuyxaulu3Nddd13t7Wn+mmuuqc2bIFAVSN+t6QdQujHR448/nj2er5rXKa/v5XumzH1THpdO6pfS5yKPTad8jvqrp76pPx15jQT0TY1U2iNNgN4e7dDyUjzzzDORxnQd5Ac/+MHs7uR33HFH9szvMh49zwOcjlDMmTMne0b8qlWrIt3VsjqMGzeuOtmRr+kxYummTek1XYe9devWzGH69OnxgQ98oGNM0jXEixYtipkzZ9bOsEgmnX6fgjfeeCN27NhR2w927dqV7SPpZmiTJk2qpXfaRHrE2sMPPxzpHh8jR46snX1x9tlnx/DhwzuNo9/66psa8+iXGrtUU/VNb0vom6p7RP2rvqneozqnb6pKtOFr5b8nhg4UqFwD2VU5fbur8sO5a9iwYV2V0967KsFF10svvdSBGvVVrhwxTxfhNxzrl+y8uS984QsNXTZv3txxGD/60Y+6Jk+e3FU5atFVeeRaV+WRWR1n0LPCaT9o9NlJ+00nD41MUlr6rjHUC+ib6j2qc/qlqkTjV33TCRd90wmL6pS+qSpR/6pvqvdopznPQa/snQYCBAgQIECAAAECBAgQIDDYAuW9sHawZW2fAAECBAgQIECAAAECBAjkEBCg58CyKAECBAgQIECAAAECBAgQaJaAAL1ZstZLgAABApChJgoAAAKzSURBVAQIECBAgAABAgRyCAjQc2BZlAABAgQIECBAgAABAgQINEtAgN4sWeslQIAAAQIECBAgQIAAAQI5BAToObAsSoAAAQIECBAgQIAAAQIEmiUgQG+WrPUSIECAAAECBAgQIECAAIEcAgL0HFgWJUCAAAECBAgQIECAAAECzRIQoDdL1noJECBAgAABAgQIECBAgEAOAQF6DiyLEiBAgAABAgQIECBAgACBZgkI0Jsla70ECBAgQIAAAQIECBAgQCCHgAA9B5ZFCRAgQIAAAQIECBAgQIBAswQE6M2StV4CBAgQIECAAAECBAgQIJBDQICeA8uiBAgQIECAAAECBAgQIECgWQIC9GbJWi8BAgQIECBAgAABAgQIEMghIEDPgWVRAgQIECBAgAABAgQIECDQLAEBerNkrZcAAQIECBAgQIAAAQIECOQQEKDnwLIoAQIECBAgQIAAAQIECBBoloAAvVmy1kuAAAECBAgQIECAAAECBHIICNBzYFmUAAECBAgQIECAAAECBAg0S0CA3ixZ6yVAgAABAgQIECBAgAABAjkEBOg5sCxKgAABAgQIECBAgAABAgSaJSBAb5as9RIgQIAAAQIECBAgQIAAgRwCAvQcWBYlQIAAAQIECBAgQIAAAQLNEhCgN0vWegkQIECAAAECBAgQIECAQA4BAXoOLIsSIECAAAECBAgQIECAAIFmCQjQmyVrvQQIECBAgAABAgQIECBAIIeAAD0HlkUJECBAgAABAgQIECBAgECzBATozZK1XgIECBAgQIAAAQIECBAgkENAgJ4Dy6IECBAgQIAAAQIECBAgQKBZAgL0ZslaLwECBAgQIECAAAECBAgQyCEgQM+BZVECBAgQIECAAAECBAgQINAsAQF6s2StlwABAgQIECBAgAABAgQI5BD4f/i0AwI1W1B7AAAAAElFTkSuQmCC" width="1000">
</div>
</div>
<p>Final example - we add two more zeros - we do not circle the origin at all: we are adding 360 degree twice for the zeros but at the same time we are subtracting the phase of the two poles.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb11"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="co"># %matplotlib notebook</span></span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a>fig, axs <span class="op">=</span> plt.subplots(<span class="dv">1</span>, <span class="dv">2</span>, figsize<span class="op">=</span>(<span class="dv">10</span>, <span class="dv">5</span>))<span class="op">;</span></span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a>line_0, <span class="op">=</span> axs[<span class="dv">0</span>].plot([])     <span class="co"># A tuple unpacking to unpack the only plot</span></span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true" tabindex="-1"></a>line_1, <span class="op">=</span> axs[<span class="dv">1</span>].plot([])     <span class="co"># A tuple unpacking to unpack the only plot</span></span>
<span id="cb11-5"><a href="#cb11-5" aria-hidden="true" tabindex="-1"></a>axs[<span class="dv">0</span>].grid()</span>
<span id="cb11-6"><a href="#cb11-6" aria-hidden="true" tabindex="-1"></a>axs[<span class="dv">1</span>].grid()</span>
<span id="cb11-7"><a href="#cb11-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-8"><a href="#cb11-8" aria-hidden="true" tabindex="-1"></a>xoff <span class="op">=</span> <span class="op">-</span><span class="fl">0.75</span>  <span class="co"># X-offset of the contour</span></span>
<span id="cb11-9"><a href="#cb11-9" aria-hidden="true" tabindex="-1"></a>yoff <span class="op">=</span> <span class="dv">0</span><span class="op">;</span>     <span class="co"># Y-offset of the contour</span></span>
<span id="cb11-10"><a href="#cb11-10" aria-hidden="true" tabindex="-1"></a>angles <span class="op">=</span> np.linspace(<span class="dv">2</span><span class="op">*</span>np.pi, <span class="dv">0</span>, <span class="dv">160</span>)<span class="op">;</span>  <span class="co"># Generate angles around the circle; 160 is tje Number of points around the circular contour</span></span>
<span id="cb11-11"><a href="#cb11-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-12"><a href="#cb11-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-13"><a href="#cb11-13" aria-hidden="true" tabindex="-1"></a>pt <span class="op">=</span> [np.cos(angles)<span class="op">+</span>xoff, np.sin(angles)<span class="op">+</span>yoff]<span class="op">;</span> </span>
<span id="cb11-14"><a href="#cb11-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-15"><a href="#cb11-15" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> animate_plot(<span class="bu">bin</span>):    </span>
<span id="cb11-16"><a href="#cb11-16" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Set 's' to the next point on the contour</span></span>
<span id="cb11-17"><a href="#cb11-17" aria-hidden="true" tabindex="-1"></a>    s <span class="op">=</span> <span class="bu">complex</span>(pt[<span class="dv">0</span>][<span class="bu">bin</span>], pt[<span class="dv">1</span>][<span class="bu">bin</span>])<span class="op">;</span></span>
<span id="cb11-18"><a href="#cb11-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-19"><a href="#cb11-19" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Plot the next point on the contour in the s-plane    </span></span>
<span id="cb11-20"><a href="#cb11-20" aria-hidden="true" tabindex="-1"></a>    line_0 <span class="op">=</span> axs[<span class="dv">0</span>].plot(np.real(s), np.imag(s), color<span class="op">=</span><span class="st">'red'</span>, marker<span class="op">=</span><span class="st">'.'</span>, markersize<span class="op">=</span><span class="dv">15</span>)<span class="op">;</span></span>
<span id="cb11-21"><a href="#cb11-21" aria-hidden="true" tabindex="-1"></a>    axs[<span class="dv">0</span>].set_title(<span class="st">'S-plane Contour'</span>)<span class="op">;</span></span>
<span id="cb11-22"><a href="#cb11-22" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb11-23"><a href="#cb11-23" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Define the system transfer function</span></span>
<span id="cb11-24"><a href="#cb11-24" aria-hidden="true" tabindex="-1"></a>    <span class="co"># 2 poles and 2 zeros</span></span>
<span id="cb11-25"><a href="#cb11-25" aria-hidden="true" tabindex="-1"></a>    tnf <span class="op">=</span> (s<span class="op">**</span><span class="dv">2</span> <span class="op">+</span> <span class="fl">1.5</span><span class="op">*</span>s <span class="op">+</span> <span class="fl">0.8125</span>)<span class="op">/</span>((s <span class="op">+</span> <span class="dv">1</span>)<span class="op">*</span>(s <span class="op">+</span> <span class="fl">0.8</span>))</span>
<span id="cb11-26"><a href="#cb11-26" aria-hidden="true" tabindex="-1"></a>    axs[<span class="dv">0</span>].plot([<span class="op">-</span><span class="dv">1</span>] , [<span class="dv">0</span>], color<span class="op">=</span><span class="st">'blue'</span>, marker<span class="op">=</span><span class="st">'x'</span>, markersize<span class="op">=</span><span class="dv">10</span>)<span class="op">;</span></span>
<span id="cb11-27"><a href="#cb11-27" aria-hidden="true" tabindex="-1"></a>    axs[<span class="dv">0</span>].plot([<span class="op">-</span><span class="fl">.8</span>], [<span class="dv">0</span>], color<span class="op">=</span><span class="st">'blue'</span>, marker<span class="op">=</span><span class="st">'x'</span>, markersize<span class="op">=</span><span class="dv">10</span>)<span class="op">;</span></span>
<span id="cb11-28"><a href="#cb11-28" aria-hidden="true" tabindex="-1"></a>    axs[<span class="dv">0</span>].plot([<span class="op">-</span><span class="fl">0.75</span>], [<span class="fl">.5</span>], color<span class="op">=</span><span class="st">'blue'</span>, marker<span class="op">=</span><span class="st">'o'</span>, markersize<span class="op">=</span><span class="dv">10</span>)<span class="op">;</span></span>
<span id="cb11-29"><a href="#cb11-29" aria-hidden="true" tabindex="-1"></a>    axs[<span class="dv">0</span>].plot([<span class="op">-</span><span class="fl">0.75</span>], [<span class="op">-</span><span class="fl">.5</span>], color<span class="op">=</span><span class="st">'blue'</span>, marker<span class="op">=</span><span class="st">'o'</span>, markersize<span class="op">=</span><span class="dv">10</span>)<span class="op">;</span></span>
<span id="cb11-30"><a href="#cb11-30" aria-hidden="true" tabindex="-1"></a>    axs[<span class="dv">0</span>].set_xlim([<span class="op">-</span><span class="dv">3</span>, <span class="dv">2</span>])</span>
<span id="cb11-31"><a href="#cb11-31" aria-hidden="true" tabindex="-1"></a>    axs[<span class="dv">0</span>].set_ylim([<span class="op">-</span><span class="dv">2</span>, <span class="dv">2</span>])<span class="op">;</span></span>
<span id="cb11-32"><a href="#cb11-32" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-33"><a href="#cb11-33" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-34"><a href="#cb11-34" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Plot the mapping from the TF in the w-plane    </span></span>
<span id="cb11-35"><a href="#cb11-35" aria-hidden="true" tabindex="-1"></a>    line_1 <span class="op">=</span> axs[<span class="dv">1</span>].plot(np.real(tnf), np.imag(tnf), color<span class="op">=</span><span class="st">'g'</span>, marker<span class="op">=</span><span class="st">'.'</span>, markersize<span class="op">=</span><span class="dv">15</span>)<span class="op">;</span></span>
<span id="cb11-36"><a href="#cb11-36" aria-hidden="true" tabindex="-1"></a>    axs[<span class="dv">1</span>].plot(<span class="dv">0</span>, <span class="dv">0</span>, marker<span class="op">=</span><span class="st">'.'</span>, color<span class="op">=</span><span class="st">'k'</span>, markersize<span class="op">=</span><span class="dv">15</span>)<span class="op">;</span></span>
<span id="cb11-37"><a href="#cb11-37" aria-hidden="true" tabindex="-1"></a>    axs[<span class="dv">1</span>].set_title(<span class="st">'$\Omega$-plane Plot'</span>)<span class="op">;</span>        </span>
<span id="cb11-38"><a href="#cb11-38" aria-hidden="true" tabindex="-1"></a>    axs[<span class="dv">1</span>].set_xlim([<span class="op">-</span><span class="dv">3</span>, <span class="dv">2</span>])</span>
<span id="cb11-39"><a href="#cb11-39" aria-hidden="true" tabindex="-1"></a>    axs[<span class="dv">1</span>].set_ylim([<span class="op">-</span><span class="dv">3</span>, <span class="dv">2</span>])<span class="op">;</span></span>
<span id="cb11-40"><a href="#cb11-40" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-41"><a href="#cb11-41" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> line_0, line_1</span>
<span id="cb11-42"><a href="#cb11-42" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-43"><a href="#cb11-43" aria-hidden="true" tabindex="-1"></a>anim <span class="op">=</span> FuncAnimation(fig, animate_plot, frames<span class="op">=</span><span class="bu">len</span>(angles), interval<span class="op">=</span><span class="dv">20</span>)</span>
<span id="cb11-44"><a href="#cb11-44" aria-hidden="true" tabindex="-1"></a>anim<span class="op">;</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<script type="application/javascript">
/* Put everything inside the global mpl namespace */
/* global mpl */
window.mpl = {};

mpl.get_websocket_type = function () {
    if (typeof WebSocket !== 'undefined') {
        return WebSocket;
    } else if (typeof MozWebSocket !== 'undefined') {
        return MozWebSocket;
    } else {
        alert(
            'Your browser does not have WebSocket support. ' +
                'Please try Chrome, Safari or Firefox ‚â• 6. ' +
                'Firefox 4 and 5 are also supported but you ' +
                'have to enable WebSockets in about:config.'
        );
    }
};

mpl.figure = function (figure_id, websocket, ondownload, parent_element) {
    this.id = figure_id;

    this.ws = websocket;

    this.supports_binary = this.ws.binaryType !== undefined;

    if (!this.supports_binary) {
        var warnings = document.getElementById('mpl-warnings');
        if (warnings) {
            warnings.style.display = 'block';
            warnings.textContent =
                'This browser does not support binary websocket messages. ' +
                'Performance may be slow.';
        }
    }

    this.imageObj = new Image();

    this.context = undefined;
    this.message = undefined;
    this.canvas = undefined;
    this.rubberband_canvas = undefined;
    this.rubberband_context = undefined;
    this.format_dropdown = undefined;

    this.image_mode = 'full';

    this.root = document.createElement('div');
    this.root.setAttribute('style', 'display: inline-block');
    this._root_extra_style(this.root);

    parent_element.appendChild(this.root);

    this._init_header(this);
    this._init_canvas(this);
    this._init_toolbar(this);

    var fig = this;

    this.waiting = false;

    this.ws.onopen = function () {
        fig.send_message('supports_binary', { value: fig.supports_binary });
        fig.send_message('send_image_mode', {});
        if (fig.ratio !== 1) {
            fig.send_message('set_device_pixel_ratio', {
                device_pixel_ratio: fig.ratio,
            });
        }
        fig.send_message('refresh', {});
    };

    this.imageObj.onload = function () {
        if (fig.image_mode === 'full') {
            // Full images could contain transparency (where diff images
            // almost always do), so we need to clear the canvas so that
            // there is no ghosting.
            fig.context.clearRect(0, 0, fig.canvas.width, fig.canvas.height);
        }
        fig.context.drawImage(fig.imageObj, 0, 0);
    };

    this.imageObj.onunload = function () {
        fig.ws.close();
    };

    this.ws.onmessage = this._make_on_message_function(this);

    this.ondownload = ondownload;
};

mpl.figure.prototype._init_header = function () {
    var titlebar = document.createElement('div');
    titlebar.classList =
        'ui-dialog-titlebar ui-widget-header ui-corner-all ui-helper-clearfix';
    var titletext = document.createElement('div');
    titletext.classList = 'ui-dialog-title';
    titletext.setAttribute(
        'style',
        'width: 100%; text-align: center; padding: 3px;'
    );
    titlebar.appendChild(titletext);
    this.root.appendChild(titlebar);
    this.header = titletext;
};

mpl.figure.prototype._canvas_extra_style = function (_canvas_div) {};

mpl.figure.prototype._root_extra_style = function (_canvas_div) {};

mpl.figure.prototype._init_canvas = function () {
    var fig = this;

    var canvas_div = (this.canvas_div = document.createElement('div'));
    canvas_div.setAttribute(
        'style',
        'border: 1px solid #ddd;' +
            'box-sizing: content-box;' +
            'clear: both;' +
            'min-height: 1px;' +
            'min-width: 1px;' +
            'outline: 0;' +
            'overflow: hidden;' +
            'position: relative;' +
            'resize: both;'
    );

    function on_keyboard_event_closure(name) {
        return function (event) {
            return fig.key_event(event, name);
        };
    }

    canvas_div.addEventListener(
        'keydown',
        on_keyboard_event_closure('key_press')
    );
    canvas_div.addEventListener(
        'keyup',
        on_keyboard_event_closure('key_release')
    );

    this._canvas_extra_style(canvas_div);
    this.root.appendChild(canvas_div);

    var canvas = (this.canvas = document.createElement('canvas'));
    canvas.classList.add('mpl-canvas');
    canvas.setAttribute('style', 'box-sizing: content-box;');

    this.context = canvas.getContext('2d');

    var backingStore =
        this.context.backingStorePixelRatio ||
        this.context.webkitBackingStorePixelRatio ||
        this.context.mozBackingStorePixelRatio ||
        this.context.msBackingStorePixelRatio ||
        this.context.oBackingStorePixelRatio ||
        this.context.backingStorePixelRatio ||
        1;

    this.ratio = (window.devicePixelRatio || 1) / backingStore;

    var rubberband_canvas = (this.rubberband_canvas = document.createElement(
        'canvas'
    ));
    rubberband_canvas.setAttribute(
        'style',
        'box-sizing: content-box; position: absolute; left: 0; top: 0; z-index: 1;'
    );

    // Apply a ponyfill if ResizeObserver is not implemented by browser.
    if (this.ResizeObserver === undefined) {
        if (window.ResizeObserver !== undefined) {
            this.ResizeObserver = window.ResizeObserver;
        } else {
            var obs = _JSXTOOLS_RESIZE_OBSERVER({});
            this.ResizeObserver = obs.ResizeObserver;
        }
    }

    this.resizeObserverInstance = new this.ResizeObserver(function (entries) {
        var nentries = entries.length;
        for (var i = 0; i < nentries; i++) {
            var entry = entries[i];
            var width, height;
            if (entry.contentBoxSize) {
                if (entry.contentBoxSize instanceof Array) {
                    // Chrome 84 implements new version of spec.
                    width = entry.contentBoxSize[0].inlineSize;
                    height = entry.contentBoxSize[0].blockSize;
                } else {
                    // Firefox implements old version of spec.
                    width = entry.contentBoxSize.inlineSize;
                    height = entry.contentBoxSize.blockSize;
                }
            } else {
                // Chrome <84 implements even older version of spec.
                width = entry.contentRect.width;
                height = entry.contentRect.height;
            }

            // Keep the size of the canvas and rubber band canvas in sync with
            // the canvas container.
            if (entry.devicePixelContentBoxSize) {
                // Chrome 84 implements new version of spec.
                canvas.setAttribute(
                    'width',
                    entry.devicePixelContentBoxSize[0].inlineSize
                );
                canvas.setAttribute(
                    'height',
                    entry.devicePixelContentBoxSize[0].blockSize
                );
            } else {
                canvas.setAttribute('width', width * fig.ratio);
                canvas.setAttribute('height', height * fig.ratio);
            }
            canvas.setAttribute(
                'style',
                'width: ' + width + 'px; height: ' + height + 'px;'
            );

            rubberband_canvas.setAttribute('width', width);
            rubberband_canvas.setAttribute('height', height);

            // And update the size in Python. We ignore the initial 0/0 size
            // that occurs as the element is placed into the DOM, which should
            // otherwise not happen due to the minimum size styling.
            if (fig.ws.readyState == 1 && width != 0 && height != 0) {
                fig.request_resize(width, height);
            }
        }
    });
    this.resizeObserverInstance.observe(canvas_div);

    function on_mouse_event_closure(name) {
        return function (event) {
            return fig.mouse_event(event, name);
        };
    }

    rubberband_canvas.addEventListener(
        'mousedown',
        on_mouse_event_closure('button_press')
    );
    rubberband_canvas.addEventListener(
        'mouseup',
        on_mouse_event_closure('button_release')
    );
    rubberband_canvas.addEventListener(
        'dblclick',
        on_mouse_event_closure('dblclick')
    );
    // Throttle sequential mouse events to 1 every 20ms.
    rubberband_canvas.addEventListener(
        'mousemove',
        on_mouse_event_closure('motion_notify')
    );

    rubberband_canvas.addEventListener(
        'mouseenter',
        on_mouse_event_closure('figure_enter')
    );
    rubberband_canvas.addEventListener(
        'mouseleave',
        on_mouse_event_closure('figure_leave')
    );

    canvas_div.addEventListener('wheel', function (event) {
        if (event.deltaY < 0) {
            event.step = 1;
        } else {
            event.step = -1;
        }
        on_mouse_event_closure('scroll')(event);
    });

    canvas_div.appendChild(canvas);
    canvas_div.appendChild(rubberband_canvas);

    this.rubberband_context = rubberband_canvas.getContext('2d');
    this.rubberband_context.strokeStyle = '#000000';

    this._resize_canvas = function (width, height, forward) {
        if (forward) {
            canvas_div.style.width = width + 'px';
            canvas_div.style.height = height + 'px';
        }
    };

    // Disable right mouse context menu.
    this.rubberband_canvas.addEventListener('contextmenu', function (_e) {
        event.preventDefault();
        return false;
    });

    function set_focus() {
        canvas.focus();
        canvas_div.focus();
    }

    window.setTimeout(set_focus, 100);
};

mpl.figure.prototype._init_toolbar = function () {
    var fig = this;

    var toolbar = document.createElement('div');
    toolbar.classList = 'mpl-toolbar';
    this.root.appendChild(toolbar);

    function on_click_closure(name) {
        return function (_event) {
            return fig.toolbar_button_onclick(name);
        };
    }

    function on_mouseover_closure(tooltip) {
        return function (event) {
            if (!event.currentTarget.disabled) {
                return fig.toolbar_button_onmouseover(tooltip);
            }
        };
    }

    fig.buttons = {};
    var buttonGroup = document.createElement('div');
    buttonGroup.classList = 'mpl-button-group';
    for (var toolbar_ind in mpl.toolbar_items) {
        var name = mpl.toolbar_items[toolbar_ind][0];
        var tooltip = mpl.toolbar_items[toolbar_ind][1];
        var image = mpl.toolbar_items[toolbar_ind][2];
        var method_name = mpl.toolbar_items[toolbar_ind][3];

        if (!name) {
            /* Instead of a spacer, we start a new button group. */
            if (buttonGroup.hasChildNodes()) {
                toolbar.appendChild(buttonGroup);
            }
            buttonGroup = document.createElement('div');
            buttonGroup.classList = 'mpl-button-group';
            continue;
        }

        var button = (fig.buttons[name] = document.createElement('button'));
        button.classList = 'mpl-widget';
        button.setAttribute('role', 'button');
        button.setAttribute('aria-disabled', 'false');
        button.addEventListener('click', on_click_closure(method_name));
        button.addEventListener('mouseover', on_mouseover_closure(tooltip));

        var icon_img = document.createElement('img');
        icon_img.src = '_images/' + image + '.png';
        icon_img.srcset = '_images/' + image + '_large.png 2x';
        icon_img.alt = tooltip;
        button.appendChild(icon_img);

        buttonGroup.appendChild(button);
    }

    if (buttonGroup.hasChildNodes()) {
        toolbar.appendChild(buttonGroup);
    }

    var fmt_picker = document.createElement('select');
    fmt_picker.classList = 'mpl-widget';
    toolbar.appendChild(fmt_picker);
    this.format_dropdown = fmt_picker;

    for (var ind in mpl.extensions) {
        var fmt = mpl.extensions[ind];
        var option = document.createElement('option');
        option.selected = fmt === mpl.default_extension;
        option.innerHTML = fmt;
        fmt_picker.appendChild(option);
    }

    var status_bar = document.createElement('span');
    status_bar.classList = 'mpl-message';
    toolbar.appendChild(status_bar);
    this.message = status_bar;
};

mpl.figure.prototype.request_resize = function (x_pixels, y_pixels) {
    // Request matplotlib to resize the figure. Matplotlib will then trigger a resize in the client,
    // which will in turn request a refresh of the image.
    this.send_message('resize', { width: x_pixels, height: y_pixels });
};

mpl.figure.prototype.send_message = function (type, properties) {
    properties['type'] = type;
    properties['figure_id'] = this.id;
    this.ws.send(JSON.stringify(properties));
};

mpl.figure.prototype.send_draw_message = function () {
    if (!this.waiting) {
        this.waiting = true;
        this.ws.send(JSON.stringify({ type: 'draw', figure_id: this.id }));
    }
};

mpl.figure.prototype.handle_save = function (fig, _msg) {
    var format_dropdown = fig.format_dropdown;
    var format = format_dropdown.options[format_dropdown.selectedIndex].value;
    fig.ondownload(fig, format);
};

mpl.figure.prototype.handle_resize = function (fig, msg) {
    var size = msg['size'];
    if (size[0] !== fig.canvas.width || size[1] !== fig.canvas.height) {
        fig._resize_canvas(size[0], size[1], msg['forward']);
        fig.send_message('refresh', {});
    }
};

mpl.figure.prototype.handle_rubberband = function (fig, msg) {
    var x0 = msg['x0'] / fig.ratio;
    var y0 = (fig.canvas.height - msg['y0']) / fig.ratio;
    var x1 = msg['x1'] / fig.ratio;
    var y1 = (fig.canvas.height - msg['y1']) / fig.ratio;
    x0 = Math.floor(x0) + 0.5;
    y0 = Math.floor(y0) + 0.5;
    x1 = Math.floor(x1) + 0.5;
    y1 = Math.floor(y1) + 0.5;
    var min_x = Math.min(x0, x1);
    var min_y = Math.min(y0, y1);
    var width = Math.abs(x1 - x0);
    var height = Math.abs(y1 - y0);

    fig.rubberband_context.clearRect(
        0,
        0,
        fig.canvas.width / fig.ratio,
        fig.canvas.height / fig.ratio
    );

    fig.rubberband_context.strokeRect(min_x, min_y, width, height);
};

mpl.figure.prototype.handle_figure_label = function (fig, msg) {
    // Updates the figure title.
    fig.header.textContent = msg['label'];
};

mpl.figure.prototype.handle_cursor = function (fig, msg) {
    fig.rubberband_canvas.style.cursor = msg['cursor'];
};

mpl.figure.prototype.handle_message = function (fig, msg) {
    fig.message.textContent = msg['message'];
};

mpl.figure.prototype.handle_draw = function (fig, _msg) {
    // Request the server to send over a new figure.
    fig.send_draw_message();
};

mpl.figure.prototype.handle_image_mode = function (fig, msg) {
    fig.image_mode = msg['mode'];
};

mpl.figure.prototype.handle_history_buttons = function (fig, msg) {
    for (var key in msg) {
        if (!(key in fig.buttons)) {
            continue;
        }
        fig.buttons[key].disabled = !msg[key];
        fig.buttons[key].setAttribute('aria-disabled', !msg[key]);
    }
};

mpl.figure.prototype.handle_navigate_mode = function (fig, msg) {
    if (msg['mode'] === 'PAN') {
        fig.buttons['Pan'].classList.add('active');
        fig.buttons['Zoom'].classList.remove('active');
    } else if (msg['mode'] === 'ZOOM') {
        fig.buttons['Pan'].classList.remove('active');
        fig.buttons['Zoom'].classList.add('active');
    } else {
        fig.buttons['Pan'].classList.remove('active');
        fig.buttons['Zoom'].classList.remove('active');
    }
};

mpl.figure.prototype.updated_canvas_event = function () {
    // Called whenever the canvas gets updated.
    this.send_message('ack', {});
};

// A function to construct a web socket function for onmessage handling.
// Called in the figure constructor.
mpl.figure.prototype._make_on_message_function = function (fig) {
    return function socket_on_message(evt) {
        if (evt.data instanceof Blob) {
            var img = evt.data;
            if (img.type !== 'image/png') {
                /* FIXME: We get "Resource interpreted as Image but
                 * transferred with MIME type text/plain:" errors on
                 * Chrome.  But how to set the MIME type?  It doesn't seem
                 * to be part of the websocket stream */
                img.type = 'image/png';
            }

            /* Free the memory for the previous frames */
            if (fig.imageObj.src) {
                (window.URL || window.webkitURL).revokeObjectURL(
                    fig.imageObj.src
                );
            }

            fig.imageObj.src = (window.URL || window.webkitURL).createObjectURL(
                img
            );
            fig.updated_canvas_event();
            fig.waiting = false;
            return;
        } else if (
            typeof evt.data === 'string' &&
            evt.data.slice(0, 21) === 'data:image/png;base64'
        ) {
            fig.imageObj.src = evt.data;
            fig.updated_canvas_event();
            fig.waiting = false;
            return;
        }

        var msg = JSON.parse(evt.data);
        var msg_type = msg['type'];

        // Call the  "handle_{type}" callback, which takes
        // the figure and JSON message as its only arguments.
        try {
            var callback = fig['handle_' + msg_type];
        } catch (e) {
            console.log(
                "No handler for the '" + msg_type + "' message type: ",
                msg
            );
            return;
        }

        if (callback) {
            try {
                // console.log("Handling '" + msg_type + "' message: ", msg);
                callback(fig, msg);
            } catch (e) {
                console.log(
                    "Exception inside the 'handler_" + msg_type + "' callback:",
                    e,
                    e.stack,
                    msg
                );
            }
        }
    };
};

// from https://stackoverflow.com/questions/1114465/getting-mouse-location-in-canvas
mpl.findpos = function (e) {
    //this section is from http://www.quirksmode.org/js/events_properties.html
    var targ;
    if (!e) {
        e = window.event;
    }
    if (e.target) {
        targ = e.target;
    } else if (e.srcElement) {
        targ = e.srcElement;
    }
    if (targ.nodeType === 3) {
        // defeat Safari bug
        targ = targ.parentNode;
    }

    // pageX,Y are the mouse positions relative to the document
    var boundingRect = targ.getBoundingClientRect();
    var x = e.pageX - (boundingRect.left + document.body.scrollLeft);
    var y = e.pageY - (boundingRect.top + document.body.scrollTop);

    return { x: x, y: y };
};

/*
 * return a copy of an object with only non-object keys
 * we need this to avoid circular references
 * https://stackoverflow.com/a/24161582/3208463
 */
function simpleKeys(original) {
    return Object.keys(original).reduce(function (obj, key) {
        if (typeof original[key] !== 'object') {
            obj[key] = original[key];
        }
        return obj;
    }, {});
}

mpl.figure.prototype.mouse_event = function (event, name) {
    var canvas_pos = mpl.findpos(event);

    if (name === 'button_press') {
        this.canvas.focus();
        this.canvas_div.focus();
    }

    var x = canvas_pos.x * this.ratio;
    var y = canvas_pos.y * this.ratio;

    this.send_message(name, {
        x: x,
        y: y,
        button: event.button,
        step: event.step,
        guiEvent: simpleKeys(event),
    });

    /* This prevents the web browser from automatically changing to
     * the text insertion cursor when the button is pressed.  We want
     * to control all of the cursor setting manually through the
     * 'cursor' event from matplotlib */
    event.preventDefault();
    return false;
};

mpl.figure.prototype._key_event_extra = function (_event, _name) {
    // Handle any extra behaviour associated with a key event
};

mpl.figure.prototype.key_event = function (event, name) {
    // Prevent repeat events
    if (name === 'key_press') {
        if (event.key === this._key) {
            return;
        } else {
            this._key = event.key;
        }
    }
    if (name === 'key_release') {
        this._key = null;
    }

    var value = '';
    if (event.ctrlKey && event.key !== 'Control') {
        value += 'ctrl+';
    }
    else if (event.altKey && event.key !== 'Alt') {
        value += 'alt+';
    }
    else if (event.shiftKey && event.key !== 'Shift') {
        value += 'shift+';
    }

    value += 'k' + event.key;

    this._key_event_extra(event, name);

    this.send_message(name, { key: value, guiEvent: simpleKeys(event) });
    return false;
};

mpl.figure.prototype.toolbar_button_onclick = function (name) {
    if (name === 'download') {
        this.handle_save(this, null);
    } else {
        this.send_message('toolbar_button', { name: name });
    }
};

mpl.figure.prototype.toolbar_button_onmouseover = function (tooltip) {
    this.message.textContent = tooltip;
};

///////////////// REMAINING CONTENT GENERATED BY embed_js.py /////////////////
// prettier-ignore
var _JSXTOOLS_RESIZE_OBSERVER=function(A){var t,i=new WeakMap,n=new WeakMap,a=new WeakMap,r=new WeakMap,o=new Set;function s(e){if(!(this instanceof s))throw new TypeError("Constructor requires 'new' operator");i.set(this,e)}function h(){throw new TypeError("Function is not a constructor")}function c(e,t,i,n){e=0 in arguments?Number(arguments[0]):0,t=1 in arguments?Number(arguments[1]):0,i=2 in arguments?Number(arguments[2]):0,n=3 in arguments?Number(arguments[3]):0,this.right=(this.x=this.left=e)+(this.width=i),this.bottom=(this.y=this.top=t)+(this.height=n),Object.freeze(this)}function d(){t=requestAnimationFrame(d);var s=new WeakMap,p=new Set;o.forEach((function(t){r.get(t).forEach((function(i){var r=t instanceof window.SVGElement,o=a.get(t),d=r?0:parseFloat(o.paddingTop),f=r?0:parseFloat(o.paddingRight),l=r?0:parseFloat(o.paddingBottom),u=r?0:parseFloat(o.paddingLeft),g=r?0:parseFloat(o.borderTopWidth),m=r?0:parseFloat(o.borderRightWidth),w=r?0:parseFloat(o.borderBottomWidth),b=u+f,F=d+l,v=(r?0:parseFloat(o.borderLeftWidth))+m,W=g+w,y=r?0:t.offsetHeight-W-t.clientHeight,E=r?0:t.offsetWidth-v-t.clientWidth,R=b+v,z=F+W,M=r?t.width:parseFloat(o.width)-R-E,O=r?t.height:parseFloat(o.height)-z-y;if(n.has(t)){var k=n.get(t);if(k[0]===M&&k[1]===O)return}n.set(t,[M,O]);var S=Object.create(h.prototype);S.target=t,S.contentRect=new c(u,d,M,O),s.has(i)||(s.set(i,[]),p.add(i)),s.get(i).push(S)}))})),p.forEach((function(e){i.get(e).call(e,s.get(e),e)}))}return s.prototype.observe=function(i){if(i instanceof window.Element){r.has(i)||(r.set(i,new Set),o.add(i),a.set(i,window.getComputedStyle(i)));var n=r.get(i);n.has(this)||n.add(this),cancelAnimationFrame(t),t=requestAnimationFrame(d)}},s.prototype.unobserve=function(i){if(i instanceof window.Element&&r.has(i)){var n=r.get(i);n.has(this)&&(n.delete(this),n.size||(r.delete(i),o.delete(i))),n.size||r.delete(i),o.size||cancelAnimationFrame(t)}},A.DOMRectReadOnly=c,A.ResizeObserver=s,A.ResizeObserverEntry=h,A}; // eslint-disable-line
mpl.toolbar_items = [["Home", "Reset original view", "fa fa-home icon-home", "home"], ["Back", "Back to previous view", "fa fa-arrow-left icon-arrow-left", "back"], ["Forward", "Forward to next view", "fa fa-arrow-right icon-arrow-right", "forward"], ["", "", "", ""], ["Pan", "Left button pans, Right button zooms\nx/y fixes axis, CTRL fixes aspect", "fa fa-arrows icon-move", "pan"], ["Zoom", "Zoom to rectangle\nx/y fixes axis", "fa fa-square-o icon-check-empty", "zoom"], ["", "", "", ""], ["Download", "Download plot", "fa fa-floppy-o icon-save", "download"]];

mpl.extensions = ["eps", "jpeg", "pgf", "pdf", "png", "ps", "raw", "svg", "tif"];

mpl.default_extension = "png";/* global mpl */

var comm_websocket_adapter = function (comm) {
    // Create a "websocket"-like object which calls the given IPython comm
    // object with the appropriate methods. Currently this is a non binary
    // socket, so there is still some room for performance tuning.
    var ws = {};

    ws.binaryType = comm.kernel.ws.binaryType;
    ws.readyState = comm.kernel.ws.readyState;
    function updateReadyState(_event) {
        if (comm.kernel.ws) {
            ws.readyState = comm.kernel.ws.readyState;
        } else {
            ws.readyState = 3; // Closed state.
        }
    }
    comm.kernel.ws.addEventListener('open', updateReadyState);
    comm.kernel.ws.addEventListener('close', updateReadyState);
    comm.kernel.ws.addEventListener('error', updateReadyState);

    ws.close = function () {
        comm.close();
    };
    ws.send = function (m) {
        //console.log('sending', m);
        comm.send(m);
    };
    // Register the callback with on_msg.
    comm.on_msg(function (msg) {
        //console.log('receiving', msg['content']['data'], msg);
        var data = msg['content']['data'];
        if (data['blob'] !== undefined) {
            data = {
                data: new Blob(msg['buffers'], { type: data['blob'] }),
            };
        }
        // Pass the mpl event to the overridden (by mpl) onmessage function.
        ws.onmessage(data);
    });
    return ws;
};

mpl.mpl_figure_comm = function (comm, msg) {
    // This is the function which gets called when the mpl process
    // starts-up an IPython Comm through the "matplotlib" channel.

    var id = msg.content.data.id;
    // Get hold of the div created by the display call when the Comm
    // socket was opened in Python.
    var element = document.getElementById(id);
    var ws_proxy = comm_websocket_adapter(comm);

    function ondownload(figure, _format) {
        window.open(figure.canvas.toDataURL());
    }

    var fig = new mpl.figure(id, ws_proxy, ondownload, element);

    // Call onopen now - mpl needs it, as it is assuming we've passed it a real
    // web socket which is closed, not our websocket->open comm proxy.
    ws_proxy.onopen();

    fig.parent_element = element;
    fig.cell_info = mpl.find_output_cell("<div id='" + id + "'></div>");
    if (!fig.cell_info) {
        console.error('Failed to find cell for figure', id, fig);
        return;
    }
    fig.cell_info[0].output_area.element.on(
        'cleared',
        { fig: fig },
        fig._remove_fig_handler
    );
};

mpl.figure.prototype.handle_close = function (fig, msg) {
    var width = fig.canvas.width / fig.ratio;
    fig.cell_info[0].output_area.element.off(
        'cleared',
        fig._remove_fig_handler
    );
    fig.resizeObserverInstance.unobserve(fig.canvas_div);

    // Update the output cell to use the data from the current canvas.
    fig.push_to_output();
    var dataURL = fig.canvas.toDataURL();
    // Re-enable the keyboard manager in IPython - without this line, in FF,
    // the notebook keyboard shortcuts fail.
    IPython.keyboard_manager.enable();
    fig.parent_element.innerHTML =
        '<img src="' + dataURL + '" width="' + width + '">';
    fig.close_ws(fig, msg);
};

mpl.figure.prototype.close_ws = function (fig, msg) {
    fig.send_message('closing', msg);
    // fig.ws.close()
};

mpl.figure.prototype.push_to_output = function (_remove_interactive) {
    // Turn the data on the canvas into data in the output cell.
    var width = this.canvas.width / this.ratio;
    var dataURL = this.canvas.toDataURL();
    this.cell_info[1]['text/html'] =
        '<img src="' + dataURL + '" width="' + width + '">';
};

mpl.figure.prototype.updated_canvas_event = function () {
    // Tell IPython that the notebook contents must change.
    IPython.notebook.set_dirty(true);
    this.send_message('ack', {});
    var fig = this;
    // Wait a second, then push the new image to the DOM so
    // that it is saved nicely (might be nice to debounce this).
    setTimeout(function () {
        fig.push_to_output();
    }, 1000);
};

mpl.figure.prototype._init_toolbar = function () {
    var fig = this;

    var toolbar = document.createElement('div');
    toolbar.classList = 'btn-toolbar';
    this.root.appendChild(toolbar);

    function on_click_closure(name) {
        return function (_event) {
            return fig.toolbar_button_onclick(name);
        };
    }

    function on_mouseover_closure(tooltip) {
        return function (event) {
            if (!event.currentTarget.disabled) {
                return fig.toolbar_button_onmouseover(tooltip);
            }
        };
    }

    fig.buttons = {};
    var buttonGroup = document.createElement('div');
    buttonGroup.classList = 'btn-group';
    var button;
    for (var toolbar_ind in mpl.toolbar_items) {
        var name = mpl.toolbar_items[toolbar_ind][0];
        var tooltip = mpl.toolbar_items[toolbar_ind][1];
        var image = mpl.toolbar_items[toolbar_ind][2];
        var method_name = mpl.toolbar_items[toolbar_ind][3];

        if (!name) {
            /* Instead of a spacer, we start a new button group. */
            if (buttonGroup.hasChildNodes()) {
                toolbar.appendChild(buttonGroup);
            }
            buttonGroup = document.createElement('div');
            buttonGroup.classList = 'btn-group';
            continue;
        }

        button = fig.buttons[name] = document.createElement('button');
        button.classList = 'btn btn-default';
        button.href = '#';
        button.title = name;
        button.innerHTML = '<i class="fa ' + image + ' fa-lg"></i>';
        button.addEventListener('click', on_click_closure(method_name));
        button.addEventListener('mouseover', on_mouseover_closure(tooltip));
        buttonGroup.appendChild(button);
    }

    if (buttonGroup.hasChildNodes()) {
        toolbar.appendChild(buttonGroup);
    }

    // Add the status bar.
    var status_bar = document.createElement('span');
    status_bar.classList = 'mpl-message pull-right';
    toolbar.appendChild(status_bar);
    this.message = status_bar;

    // Add the close button to the window.
    var buttongrp = document.createElement('div');
    buttongrp.classList = 'btn-group inline pull-right';
    button = document.createElement('button');
    button.classList = 'btn btn-mini btn-primary';
    button.href = '#';
    button.title = 'Stop Interaction';
    button.innerHTML = '<i class="fa fa-power-off icon-remove icon-large"></i>';
    button.addEventListener('click', function (_evt) {
        fig.handle_close(fig, {});
    });
    button.addEventListener(
        'mouseover',
        on_mouseover_closure('Stop Interaction')
    );
    buttongrp.appendChild(button);
    var titlebar = this.root.querySelector('.ui-dialog-titlebar');
    titlebar.insertBefore(buttongrp, titlebar.firstChild);
};

mpl.figure.prototype._remove_fig_handler = function (event) {
    var fig = event.data.fig;
    if (event.target !== this) {
        // Ignore bubbled events from children.
        return;
    }
    fig.close_ws(fig, {});
};

mpl.figure.prototype._root_extra_style = function (el) {
    el.style.boxSizing = 'content-box'; // override notebook setting of border-box.
};

mpl.figure.prototype._canvas_extra_style = function (el) {
    // this is important to make the div 'focusable
    el.setAttribute('tabindex', 0);
    // reach out to IPython and tell the keyboard manager to turn it's self
    // off when our div gets focus

    // location in version 3
    if (IPython.notebook.keyboard_manager) {
        IPython.notebook.keyboard_manager.register_events(el);
    } else {
        // location in version 2
        IPython.keyboard_manager.register_events(el);
    }
};

mpl.figure.prototype._key_event_extra = function (event, _name) {
    // Check for shift+enter
    if (event.shiftKey && event.which === 13) {
        this.canvas_div.blur();
        // select the cell after this one
        var index = IPython.notebook.find_cell_index(this.cell_info[0]);
        IPython.notebook.select(index + 1);
    }
};

mpl.figure.prototype.handle_save = function (fig, _msg) {
    fig.ondownload(fig, null);
};

mpl.find_output_cell = function (html_output) {
    // Return the cell and output element which can be found *uniquely* in the notebook.
    // Note - this is a bit hacky, but it is done because the "notebook_saving.Notebook"
    // IPython event is triggered only after the cells have been serialised, which for
    // our purposes (turning an active figure into a static one), is too late.
    var cells = IPython.notebook.get_cells();
    var ncells = cells.length;
    for (var i = 0; i < ncells; i++) {
        var cell = cells[i];
        if (cell.cell_type === 'code') {
            for (var j = 0; j < cell.output_area.outputs.length; j++) {
                var data = cell.output_area.outputs[j];
                if (data.data) {
                    // IPython >= 3 moved mimebundle to data attribute of output
                    data = data.data;
                }
                if (data['text/html'] === html_output) {
                    return [cell, data, j];
                }
            }
        }
    }
};

// Register the function which deals with the matplotlib target/channel.
// The kernel may be null if the page has been refreshed.
if (IPython.notebook.kernel !== null) {
    IPython.notebook.kernel.comm_manager.register_target(
        'matplotlib',
        mpl.mpl_figure_comm
    );
}

</script>
</div>
<div class="cell-output cell-output-display">
<img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAA+gAAAH0CAYAAACuKActAAAAAXNSR0IArs4c6QAAAERlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAA6ABAAMAAAABAAEAAKACAAQAAAABAAAD6KADAAQAAAABAAAB9AAAAADw81QvAABAAElEQVR4AezdDXwU1bn48SeEEIhgFSgBlFdfKShyoQooSLRBocXX6xWtior2j0i9Sqkt2irYKr1WLbUCaoWiUnvtvVYrBStpDaCCLQgU7QUqCKISjLxogGASwv7nmTjLvu/MJtmdl9/xs+68nJk553uWzD47Z87khYwkJAQQQAABBBBAAAEEEEAAAQQQyKlAi5wenYMjgAACCCCAAAIIIIAAAggggIApQIDOBwEBBBBAAAEEEEAAAQQQQAABFwgQoLugESgCAggggAACCCCAAAIIIIAAAgTofAYQQAABBBBAAAEEEEAAAQQQcIEAAboLGoEiIIAAAggggAACCCCAAAIIIECAzmcAAQQQQAABBBBAAAEEEEAAARcIEKC7oBEoAgIIIIAAAggggAACCCCAAAIE6HwGEEAAAQQQQAABBBBAAAEEEHCBAAG6CxqBIiCAAAIIIIAAAggggAACCCBAgM5nAAEEEEAAAQQQQAABBBBAAAEXCBCgu6ARKAICCCCAAAIIIIAAAggggAACBOh8BhBAAAEEEEAAAQQQQAABBBBwgQABugsagSIggAACCCCAAAIIIIAAAgggQIDOZwABBBBAAAEEEEAAAQQQQAABFwgQoLugESgCAggggAACCCCAAAIIIIAAAgTofAYQQAABBBBAAAEEEEAAAQQQcIEAAboLGoEiIIAAAggggAACCCCAAAIIIECAzmcAAQQQQAABBBBAAAEEEEAAARcIEKC7oBEoAgIIIIAAAggggAACCCCAAAIE6HwGEEAAAQQQQAABBBBAAAEEEHCBAAG6CxqBIiCAAAIIIIAAAggggAACCCBAgM5nAAEEEEAAAQQQQAABBBBAAAEXCBCgu6ARKAICCCCAAAIIIIAAAggggAACBOh8BhBAAAEEEEAAAQQQQAABBBBwgQABugsagSIggAACCCCAAAIIIIAAAgggQIDOZwABBBBAAAEEEEAAAQQQQAABFwgQoLugESgCAggggAACCCCAAAIIIIAAAgTofAYQQAABBBBA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" width="1000">
</div>
</div>
<hr>
</section>
<section id="cauchys-argument-principle-1" class="level4">
<h4 class="anchored" data-anchor-id="cauchys-argument-principle-1">Cauchy‚Äôs argument principle</h4>
<blockquote class="blockquote">
<ul>
<li>We can tell the relative difference between the number of poles and zeros inside of a contour by counting how many time the plot circles the origin and in which direction</li>
</ul>
</blockquote>
<hr>
<div class="cell">
<div class="sourceCode cell-code" id="cb12"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a><span class="co"># %matplotlib notebook</span></span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a>fig, axs <span class="op">=</span> plt.subplots(<span class="dv">1</span>, <span class="dv">2</span>, figsize<span class="op">=</span>(<span class="dv">10</span>, <span class="dv">5</span>))<span class="op">;</span></span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a>line_0, <span class="op">=</span> axs[<span class="dv">0</span>].plot([])     <span class="co"># A tuple unpacking to unpack the only plot</span></span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true" tabindex="-1"></a>line_1, <span class="op">=</span> axs[<span class="dv">1</span>].plot([])     <span class="co"># A tuple unpacking to unpack the only plot</span></span>
<span id="cb12-5"><a href="#cb12-5" aria-hidden="true" tabindex="-1"></a>axs[<span class="dv">0</span>].grid()</span>
<span id="cb12-6"><a href="#cb12-6" aria-hidden="true" tabindex="-1"></a>axs[<span class="dv">1</span>].grid()</span>
<span id="cb12-7"><a href="#cb12-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-8"><a href="#cb12-8" aria-hidden="true" tabindex="-1"></a>xoff <span class="op">=</span> <span class="fl">1.5</span>  <span class="co"># X-offset of the contour</span></span>
<span id="cb12-9"><a href="#cb12-9" aria-hidden="true" tabindex="-1"></a>yoff <span class="op">=</span> <span class="dv">0</span><span class="op">;</span>     <span class="co"># Y-offset of the contour</span></span>
<span id="cb12-10"><a href="#cb12-10" aria-hidden="true" tabindex="-1"></a>angles <span class="op">=</span> np.linspace(<span class="dv">2</span><span class="op">*</span>np.pi, <span class="dv">0</span>, <span class="dv">160</span>)<span class="op">;</span>  <span class="co"># Generate angles around the circle; 160 is tje Number of points around the circular contour</span></span>
<span id="cb12-11"><a href="#cb12-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-12"><a href="#cb12-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-13"><a href="#cb12-13" aria-hidden="true" tabindex="-1"></a>pt <span class="op">=</span> [np.cos(angles)<span class="op">+</span>xoff, np.sin(angles)<span class="op">+</span>yoff]<span class="op">;</span> </span>
<span id="cb12-14"><a href="#cb12-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-15"><a href="#cb12-15" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> animate_plot(<span class="bu">bin</span>):    </span>
<span id="cb12-16"><a href="#cb12-16" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Set 's' to the next point on the contour</span></span>
<span id="cb12-17"><a href="#cb12-17" aria-hidden="true" tabindex="-1"></a>    s <span class="op">=</span> <span class="bu">complex</span>(pt[<span class="dv">0</span>][<span class="bu">bin</span>], pt[<span class="dv">1</span>][<span class="bu">bin</span>])<span class="op">;</span></span>
<span id="cb12-18"><a href="#cb12-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-19"><a href="#cb12-19" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Plot the next point on the contour in the s-plane    </span></span>
<span id="cb12-20"><a href="#cb12-20" aria-hidden="true" tabindex="-1"></a>    line_0 <span class="op">=</span> axs[<span class="dv">0</span>].plot(np.real(s), np.imag(s), color<span class="op">=</span><span class="st">'red'</span>, marker<span class="op">=</span><span class="st">'.'</span>, markersize<span class="op">=</span><span class="dv">15</span>)<span class="op">;</span></span>
<span id="cb12-21"><a href="#cb12-21" aria-hidden="true" tabindex="-1"></a>    axs[<span class="dv">0</span>].set_title(<span class="st">'S-plane Contour'</span>)<span class="op">;</span></span>
<span id="cb12-22"><a href="#cb12-22" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb12-23"><a href="#cb12-23" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Define the system transfer function    </span></span>
<span id="cb12-24"><a href="#cb12-24" aria-hidden="true" tabindex="-1"></a>    tnf <span class="op">=</span> (s<span class="op">-</span><span class="dv">1</span>)<span class="op">*</span>(s<span class="op">-</span><span class="fl">1.5</span>)<span class="op">/</span>(s<span class="op">-</span><span class="fl">1.7</span>)</span>
<span id="cb12-25"><a href="#cb12-25" aria-hidden="true" tabindex="-1"></a><span class="co">#     axs[0].plot([1.7] , [0], color='blue', marker='x', markersize=10);</span></span>
<span id="cb12-26"><a href="#cb12-26" aria-hidden="true" tabindex="-1"></a><span class="co">#     axs[0].plot([1], [0], color='blue', marker='o', markersize=10);</span></span>
<span id="cb12-27"><a href="#cb12-27" aria-hidden="true" tabindex="-1"></a><span class="co">#     axs[0].plot([1.5], [0], color='blue', marker='o', markersize=10);</span></span>
<span id="cb12-28"><a href="#cb12-28" aria-hidden="true" tabindex="-1"></a>    axs[<span class="dv">0</span>].set_xlim([<span class="op">-</span><span class="dv">1</span>, <span class="dv">4</span>])</span>
<span id="cb12-29"><a href="#cb12-29" aria-hidden="true" tabindex="-1"></a>    axs[<span class="dv">0</span>].set_ylim([<span class="op">-</span><span class="dv">2</span>, <span class="dv">2</span>])<span class="op">;</span></span>
<span id="cb12-30"><a href="#cb12-30" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-31"><a href="#cb12-31" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-32"><a href="#cb12-32" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Plot the mapping from the TF in the w-plane    </span></span>
<span id="cb12-33"><a href="#cb12-33" aria-hidden="true" tabindex="-1"></a>    line_1 <span class="op">=</span> axs[<span class="dv">1</span>].plot(np.real(tnf), np.imag(tnf), color<span class="op">=</span><span class="st">'g'</span>, marker<span class="op">=</span><span class="st">'.'</span>, markersize<span class="op">=</span><span class="dv">15</span>)<span class="op">;</span></span>
<span id="cb12-34"><a href="#cb12-34" aria-hidden="true" tabindex="-1"></a>    axs[<span class="dv">1</span>].plot(<span class="dv">0</span>, <span class="dv">0</span>, marker<span class="op">=</span><span class="st">'.'</span>, color<span class="op">=</span><span class="st">'k'</span>, markersize<span class="op">=</span><span class="dv">15</span>)<span class="op">;</span></span>
<span id="cb12-35"><a href="#cb12-35" aria-hidden="true" tabindex="-1"></a>    axs[<span class="dv">1</span>].set_title(<span class="st">'$\Omega$-plane Plot'</span>)<span class="op">;</span>        </span>
<span id="cb12-36"><a href="#cb12-36" aria-hidden="true" tabindex="-1"></a>    axs[<span class="dv">1</span>].set_xlim([<span class="op">-</span><span class="fl">2.5</span>, <span class="fl">2.5</span>])</span>
<span id="cb12-37"><a href="#cb12-37" aria-hidden="true" tabindex="-1"></a>    axs[<span class="dv">1</span>].set_ylim([<span class="op">-</span><span class="fl">2.5</span>, <span class="fl">2.5</span>])<span class="op">;</span></span>
<span id="cb12-38"><a href="#cb12-38" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-39"><a href="#cb12-39" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> line_0, line_1</span>
<span id="cb12-40"><a href="#cb12-40" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-41"><a href="#cb12-41" aria-hidden="true" tabindex="-1"></a>anim <span class="op">=</span> FuncAnimation(fig, animate_plot, frames<span class="op">=</span><span class="bu">len</span>(angles), interval<span class="op">=</span><span class="dv">20</span>)</span>
<span id="cb12-42"><a href="#cb12-42" aria-hidden="true" tabindex="-1"></a>anim<span class="op">;</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<script type="application/javascript">
/* Put everything inside the global mpl namespace */
/* global mpl */
window.mpl = {};

mpl.get_websocket_type = function () {
    if (typeof WebSocket !== 'undefined') {
        return WebSocket;
    } else if (typeof MozWebSocket !== 'undefined') {
        return MozWebSocket;
    } else {
        alert(
            'Your browser does not have WebSocket support. ' +
                'Please try Chrome, Safari or Firefox ‚â• 6. ' +
                'Firefox 4 and 5 are also supported but you ' +
                'have to enable WebSockets in about:config.'
        );
    }
};

mpl.figure = function (figure_id, websocket, ondownload, parent_element) {
    this.id = figure_id;

    this.ws = websocket;

    this.supports_binary = this.ws.binaryType !== undefined;

    if (!this.supports_binary) {
        var warnings = document.getElementById('mpl-warnings');
        if (warnings) {
            warnings.style.display = 'block';
            warnings.textContent =
                'This browser does not support binary websocket messages. ' +
                'Performance may be slow.';
        }
    }

    this.imageObj = new Image();

    this.context = undefined;
    this.message = undefined;
    this.canvas = undefined;
    this.rubberband_canvas = undefined;
    this.rubberband_context = undefined;
    this.format_dropdown = undefined;

    this.image_mode = 'full';

    this.root = document.createElement('div');
    this.root.setAttribute('style', 'display: inline-block');
    this._root_extra_style(this.root);

    parent_element.appendChild(this.root);

    this._init_header(this);
    this._init_canvas(this);
    this._init_toolbar(this);

    var fig = this;

    this.waiting = false;

    this.ws.onopen = function () {
        fig.send_message('supports_binary', { value: fig.supports_binary });
        fig.send_message('send_image_mode', {});
        if (fig.ratio !== 1) {
            fig.send_message('set_device_pixel_ratio', {
                device_pixel_ratio: fig.ratio,
            });
        }
        fig.send_message('refresh', {});
    };

    this.imageObj.onload = function () {
        if (fig.image_mode === 'full') {
            // Full images could contain transparency (where diff images
            // almost always do), so we need to clear the canvas so that
            // there is no ghosting.
            fig.context.clearRect(0, 0, fig.canvas.width, fig.canvas.height);
        }
        fig.context.drawImage(fig.imageObj, 0, 0);
    };

    this.imageObj.onunload = function () {
        fig.ws.close();
    };

    this.ws.onmessage = this._make_on_message_function(this);

    this.ondownload = ondownload;
};

mpl.figure.prototype._init_header = function () {
    var titlebar = document.createElement('div');
    titlebar.classList =
        'ui-dialog-titlebar ui-widget-header ui-corner-all ui-helper-clearfix';
    var titletext = document.createElement('div');
    titletext.classList = 'ui-dialog-title';
    titletext.setAttribute(
        'style',
        'width: 100%; text-align: center; padding: 3px;'
    );
    titlebar.appendChild(titletext);
    this.root.appendChild(titlebar);
    this.header = titletext;
};

mpl.figure.prototype._canvas_extra_style = function (_canvas_div) {};

mpl.figure.prototype._root_extra_style = function (_canvas_div) {};

mpl.figure.prototype._init_canvas = function () {
    var fig = this;

    var canvas_div = (this.canvas_div = document.createElement('div'));
    canvas_div.setAttribute(
        'style',
        'border: 1px solid #ddd;' +
            'box-sizing: content-box;' +
            'clear: both;' +
            'min-height: 1px;' +
            'min-width: 1px;' +
            'outline: 0;' +
            'overflow: hidden;' +
            'position: relative;' +
            'resize: both;'
    );

    function on_keyboard_event_closure(name) {
        return function (event) {
            return fig.key_event(event, name);
        };
    }

    canvas_div.addEventListener(
        'keydown',
        on_keyboard_event_closure('key_press')
    );
    canvas_div.addEventListener(
        'keyup',
        on_keyboard_event_closure('key_release')
    );

    this._canvas_extra_style(canvas_div);
    this.root.appendChild(canvas_div);

    var canvas = (this.canvas = document.createElement('canvas'));
    canvas.classList.add('mpl-canvas');
    canvas.setAttribute('style', 'box-sizing: content-box;');

    this.context = canvas.getContext('2d');

    var backingStore =
        this.context.backingStorePixelRatio ||
        this.context.webkitBackingStorePixelRatio ||
        this.context.mozBackingStorePixelRatio ||
        this.context.msBackingStorePixelRatio ||
        this.context.oBackingStorePixelRatio ||
        this.context.backingStorePixelRatio ||
        1;

    this.ratio = (window.devicePixelRatio || 1) / backingStore;

    var rubberband_canvas = (this.rubberband_canvas = document.createElement(
        'canvas'
    ));
    rubberband_canvas.setAttribute(
        'style',
        'box-sizing: content-box; position: absolute; left: 0; top: 0; z-index: 1;'
    );

    // Apply a ponyfill if ResizeObserver is not implemented by browser.
    if (this.ResizeObserver === undefined) {
        if (window.ResizeObserver !== undefined) {
            this.ResizeObserver = window.ResizeObserver;
        } else {
            var obs = _JSXTOOLS_RESIZE_OBSERVER({});
            this.ResizeObserver = obs.ResizeObserver;
        }
    }

    this.resizeObserverInstance = new this.ResizeObserver(function (entries) {
        var nentries = entries.length;
        for (var i = 0; i < nentries; i++) {
            var entry = entries[i];
            var width, height;
            if (entry.contentBoxSize) {
                if (entry.contentBoxSize instanceof Array) {
                    // Chrome 84 implements new version of spec.
                    width = entry.contentBoxSize[0].inlineSize;
                    height = entry.contentBoxSize[0].blockSize;
                } else {
                    // Firefox implements old version of spec.
                    width = entry.contentBoxSize.inlineSize;
                    height = entry.contentBoxSize.blockSize;
                }
            } else {
                // Chrome <84 implements even older version of spec.
                width = entry.contentRect.width;
                height = entry.contentRect.height;
            }

            // Keep the size of the canvas and rubber band canvas in sync with
            // the canvas container.
            if (entry.devicePixelContentBoxSize) {
                // Chrome 84 implements new version of spec.
                canvas.setAttribute(
                    'width',
                    entry.devicePixelContentBoxSize[0].inlineSize
                );
                canvas.setAttribute(
                    'height',
                    entry.devicePixelContentBoxSize[0].blockSize
                );
            } else {
                canvas.setAttribute('width', width * fig.ratio);
                canvas.setAttribute('height', height * fig.ratio);
            }
            canvas.setAttribute(
                'style',
                'width: ' + width + 'px; height: ' + height + 'px;'
            );

            rubberband_canvas.setAttribute('width', width);
            rubberband_canvas.setAttribute('height', height);

            // And update the size in Python. We ignore the initial 0/0 size
            // that occurs as the element is placed into the DOM, which should
            // otherwise not happen due to the minimum size styling.
            if (fig.ws.readyState == 1 && width != 0 && height != 0) {
                fig.request_resize(width, height);
            }
        }
    });
    this.resizeObserverInstance.observe(canvas_div);

    function on_mouse_event_closure(name) {
        return function (event) {
            return fig.mouse_event(event, name);
        };
    }

    rubberband_canvas.addEventListener(
        'mousedown',
        on_mouse_event_closure('button_press')
    );
    rubberband_canvas.addEventListener(
        'mouseup',
        on_mouse_event_closure('button_release')
    );
    rubberband_canvas.addEventListener(
        'dblclick',
        on_mouse_event_closure('dblclick')
    );
    // Throttle sequential mouse events to 1 every 20ms.
    rubberband_canvas.addEventListener(
        'mousemove',
        on_mouse_event_closure('motion_notify')
    );

    rubberband_canvas.addEventListener(
        'mouseenter',
        on_mouse_event_closure('figure_enter')
    );
    rubberband_canvas.addEventListener(
        'mouseleave',
        on_mouse_event_closure('figure_leave')
    );

    canvas_div.addEventListener('wheel', function (event) {
        if (event.deltaY < 0) {
            event.step = 1;
        } else {
            event.step = -1;
        }
        on_mouse_event_closure('scroll')(event);
    });

    canvas_div.appendChild(canvas);
    canvas_div.appendChild(rubberband_canvas);

    this.rubberband_context = rubberband_canvas.getContext('2d');
    this.rubberband_context.strokeStyle = '#000000';

    this._resize_canvas = function (width, height, forward) {
        if (forward) {
            canvas_div.style.width = width + 'px';
            canvas_div.style.height = height + 'px';
        }
    };

    // Disable right mouse context menu.
    this.rubberband_canvas.addEventListener('contextmenu', function (_e) {
        event.preventDefault();
        return false;
    });

    function set_focus() {
        canvas.focus();
        canvas_div.focus();
    }

    window.setTimeout(set_focus, 100);
};

mpl.figure.prototype._init_toolbar = function () {
    var fig = this;

    var toolbar = document.createElement('div');
    toolbar.classList = 'mpl-toolbar';
    this.root.appendChild(toolbar);

    function on_click_closure(name) {
        return function (_event) {
            return fig.toolbar_button_onclick(name);
        };
    }

    function on_mouseover_closure(tooltip) {
        return function (event) {
            if (!event.currentTarget.disabled) {
                return fig.toolbar_button_onmouseover(tooltip);
            }
        };
    }

    fig.buttons = {};
    var buttonGroup = document.createElement('div');
    buttonGroup.classList = 'mpl-button-group';
    for (var toolbar_ind in mpl.toolbar_items) {
        var name = mpl.toolbar_items[toolbar_ind][0];
        var tooltip = mpl.toolbar_items[toolbar_ind][1];
        var image = mpl.toolbar_items[toolbar_ind][2];
        var method_name = mpl.toolbar_items[toolbar_ind][3];

        if (!name) {
            /* Instead of a spacer, we start a new button group. */
            if (buttonGroup.hasChildNodes()) {
                toolbar.appendChild(buttonGroup);
            }
            buttonGroup = document.createElement('div');
            buttonGroup.classList = 'mpl-button-group';
            continue;
        }

        var button = (fig.buttons[name] = document.createElement('button'));
        button.classList = 'mpl-widget';
        button.setAttribute('role', 'button');
        button.setAttribute('aria-disabled', 'false');
        button.addEventListener('click', on_click_closure(method_name));
        button.addEventListener('mouseover', on_mouseover_closure(tooltip));

        var icon_img = document.createElement('img');
        icon_img.src = '_images/' + image + '.png';
        icon_img.srcset = '_images/' + image + '_large.png 2x';
        icon_img.alt = tooltip;
        button.appendChild(icon_img);

        buttonGroup.appendChild(button);
    }

    if (buttonGroup.hasChildNodes()) {
        toolbar.appendChild(buttonGroup);
    }

    var fmt_picker = document.createElement('select');
    fmt_picker.classList = 'mpl-widget';
    toolbar.appendChild(fmt_picker);
    this.format_dropdown = fmt_picker;

    for (var ind in mpl.extensions) {
        var fmt = mpl.extensions[ind];
        var option = document.createElement('option');
        option.selected = fmt === mpl.default_extension;
        option.innerHTML = fmt;
        fmt_picker.appendChild(option);
    }

    var status_bar = document.createElement('span');
    status_bar.classList = 'mpl-message';
    toolbar.appendChild(status_bar);
    this.message = status_bar;
};

mpl.figure.prototype.request_resize = function (x_pixels, y_pixels) {
    // Request matplotlib to resize the figure. Matplotlib will then trigger a resize in the client,
    // which will in turn request a refresh of the image.
    this.send_message('resize', { width: x_pixels, height: y_pixels });
};

mpl.figure.prototype.send_message = function (type, properties) {
    properties['type'] = type;
    properties['figure_id'] = this.id;
    this.ws.send(JSON.stringify(properties));
};

mpl.figure.prototype.send_draw_message = function () {
    if (!this.waiting) {
        this.waiting = true;
        this.ws.send(JSON.stringify({ type: 'draw', figure_id: this.id }));
    }
};

mpl.figure.prototype.handle_save = function (fig, _msg) {
    var format_dropdown = fig.format_dropdown;
    var format = format_dropdown.options[format_dropdown.selectedIndex].value;
    fig.ondownload(fig, format);
};

mpl.figure.prototype.handle_resize = function (fig, msg) {
    var size = msg['size'];
    if (size[0] !== fig.canvas.width || size[1] !== fig.canvas.height) {
        fig._resize_canvas(size[0], size[1], msg['forward']);
        fig.send_message('refresh', {});
    }
};

mpl.figure.prototype.handle_rubberband = function (fig, msg) {
    var x0 = msg['x0'] / fig.ratio;
    var y0 = (fig.canvas.height - msg['y0']) / fig.ratio;
    var x1 = msg['x1'] / fig.ratio;
    var y1 = (fig.canvas.height - msg['y1']) / fig.ratio;
    x0 = Math.floor(x0) + 0.5;
    y0 = Math.floor(y0) + 0.5;
    x1 = Math.floor(x1) + 0.5;
    y1 = Math.floor(y1) + 0.5;
    var min_x = Math.min(x0, x1);
    var min_y = Math.min(y0, y1);
    var width = Math.abs(x1 - x0);
    var height = Math.abs(y1 - y0);

    fig.rubberband_context.clearRect(
        0,
        0,
        fig.canvas.width / fig.ratio,
        fig.canvas.height / fig.ratio
    );

    fig.rubberband_context.strokeRect(min_x, min_y, width, height);
};

mpl.figure.prototype.handle_figure_label = function (fig, msg) {
    // Updates the figure title.
    fig.header.textContent = msg['label'];
};

mpl.figure.prototype.handle_cursor = function (fig, msg) {
    fig.rubberband_canvas.style.cursor = msg['cursor'];
};

mpl.figure.prototype.handle_message = function (fig, msg) {
    fig.message.textContent = msg['message'];
};

mpl.figure.prototype.handle_draw = function (fig, _msg) {
    // Request the server to send over a new figure.
    fig.send_draw_message();
};

mpl.figure.prototype.handle_image_mode = function (fig, msg) {
    fig.image_mode = msg['mode'];
};

mpl.figure.prototype.handle_history_buttons = function (fig, msg) {
    for (var key in msg) {
        if (!(key in fig.buttons)) {
            continue;
        }
        fig.buttons[key].disabled = !msg[key];
        fig.buttons[key].setAttribute('aria-disabled', !msg[key]);
    }
};

mpl.figure.prototype.handle_navigate_mode = function (fig, msg) {
    if (msg['mode'] === 'PAN') {
        fig.buttons['Pan'].classList.add('active');
        fig.buttons['Zoom'].classList.remove('active');
    } else if (msg['mode'] === 'ZOOM') {
        fig.buttons['Pan'].classList.remove('active');
        fig.buttons['Zoom'].classList.add('active');
    } else {
        fig.buttons['Pan'].classList.remove('active');
        fig.buttons['Zoom'].classList.remove('active');
    }
};

mpl.figure.prototype.updated_canvas_event = function () {
    // Called whenever the canvas gets updated.
    this.send_message('ack', {});
};

// A function to construct a web socket function for onmessage handling.
// Called in the figure constructor.
mpl.figure.prototype._make_on_message_function = function (fig) {
    return function socket_on_message(evt) {
        if (evt.data instanceof Blob) {
            var img = evt.data;
            if (img.type !== 'image/png') {
                /* FIXME: We get "Resource interpreted as Image but
                 * transferred with MIME type text/plain:" errors on
                 * Chrome.  But how to set the MIME type?  It doesn't seem
                 * to be part of the websocket stream */
                img.type = 'image/png';
            }

            /* Free the memory for the previous frames */
            if (fig.imageObj.src) {
                (window.URL || window.webkitURL).revokeObjectURL(
                    fig.imageObj.src
                );
            }

            fig.imageObj.src = (window.URL || window.webkitURL).createObjectURL(
                img
            );
            fig.updated_canvas_event();
            fig.waiting = false;
            return;
        } else if (
            typeof evt.data === 'string' &&
            evt.data.slice(0, 21) === 'data:image/png;base64'
        ) {
            fig.imageObj.src = evt.data;
            fig.updated_canvas_event();
            fig.waiting = false;
            return;
        }

        var msg = JSON.parse(evt.data);
        var msg_type = msg['type'];

        // Call the  "handle_{type}" callback, which takes
        // the figure and JSON message as its only arguments.
        try {
            var callback = fig['handle_' + msg_type];
        } catch (e) {
            console.log(
                "No handler for the '" + msg_type + "' message type: ",
                msg
            );
            return;
        }

        if (callback) {
            try {
                // console.log("Handling '" + msg_type + "' message: ", msg);
                callback(fig, msg);
            } catch (e) {
                console.log(
                    "Exception inside the 'handler_" + msg_type + "' callback:",
                    e,
                    e.stack,
                    msg
                );
            }
        }
    };
};

// from https://stackoverflow.com/questions/1114465/getting-mouse-location-in-canvas
mpl.findpos = function (e) {
    //this section is from http://www.quirksmode.org/js/events_properties.html
    var targ;
    if (!e) {
        e = window.event;
    }
    if (e.target) {
        targ = e.target;
    } else if (e.srcElement) {
        targ = e.srcElement;
    }
    if (targ.nodeType === 3) {
        // defeat Safari bug
        targ = targ.parentNode;
    }

    // pageX,Y are the mouse positions relative to the document
    var boundingRect = targ.getBoundingClientRect();
    var x = e.pageX - (boundingRect.left + document.body.scrollLeft);
    var y = e.pageY - (boundingRect.top + document.body.scrollTop);

    return { x: x, y: y };
};

/*
 * return a copy of an object with only non-object keys
 * we need this to avoid circular references
 * https://stackoverflow.com/a/24161582/3208463
 */
function simpleKeys(original) {
    return Object.keys(original).reduce(function (obj, key) {
        if (typeof original[key] !== 'object') {
            obj[key] = original[key];
        }
        return obj;
    }, {});
}

mpl.figure.prototype.mouse_event = function (event, name) {
    var canvas_pos = mpl.findpos(event);

    if (name === 'button_press') {
        this.canvas.focus();
        this.canvas_div.focus();
    }

    var x = canvas_pos.x * this.ratio;
    var y = canvas_pos.y * this.ratio;

    this.send_message(name, {
        x: x,
        y: y,
        button: event.button,
        step: event.step,
        guiEvent: simpleKeys(event),
    });

    /* This prevents the web browser from automatically changing to
     * the text insertion cursor when the button is pressed.  We want
     * to control all of the cursor setting manually through the
     * 'cursor' event from matplotlib */
    event.preventDefault();
    return false;
};

mpl.figure.prototype._key_event_extra = function (_event, _name) {
    // Handle any extra behaviour associated with a key event
};

mpl.figure.prototype.key_event = function (event, name) {
    // Prevent repeat events
    if (name === 'key_press') {
        if (event.key === this._key) {
            return;
        } else {
            this._key = event.key;
        }
    }
    if (name === 'key_release') {
        this._key = null;
    }

    var value = '';
    if (event.ctrlKey && event.key !== 'Control') {
        value += 'ctrl+';
    }
    else if (event.altKey && event.key !== 'Alt') {
        value += 'alt+';
    }
    else if (event.shiftKey && event.key !== 'Shift') {
        value += 'shift+';
    }

    value += 'k' + event.key;

    this._key_event_extra(event, name);

    this.send_message(name, { key: value, guiEvent: simpleKeys(event) });
    return false;
};

mpl.figure.prototype.toolbar_button_onclick = function (name) {
    if (name === 'download') {
        this.handle_save(this, null);
    } else {
        this.send_message('toolbar_button', { name: name });
    }
};

mpl.figure.prototype.toolbar_button_onmouseover = function (tooltip) {
    this.message.textContent = tooltip;
};

///////////////// REMAINING CONTENT GENERATED BY embed_js.py /////////////////
// prettier-ignore
var _JSXTOOLS_RESIZE_OBSERVER=function(A){var t,i=new WeakMap,n=new WeakMap,a=new WeakMap,r=new WeakMap,o=new Set;function s(e){if(!(this instanceof s))throw new TypeError("Constructor requires 'new' operator");i.set(this,e)}function h(){throw new TypeError("Function is not a constructor")}function c(e,t,i,n){e=0 in arguments?Number(arguments[0]):0,t=1 in arguments?Number(arguments[1]):0,i=2 in arguments?Number(arguments[2]):0,n=3 in arguments?Number(arguments[3]):0,this.right=(this.x=this.left=e)+(this.width=i),this.bottom=(this.y=this.top=t)+(this.height=n),Object.freeze(this)}function d(){t=requestAnimationFrame(d);var s=new WeakMap,p=new Set;o.forEach((function(t){r.get(t).forEach((function(i){var r=t instanceof window.SVGElement,o=a.get(t),d=r?0:parseFloat(o.paddingTop),f=r?0:parseFloat(o.paddingRight),l=r?0:parseFloat(o.paddingBottom),u=r?0:parseFloat(o.paddingLeft),g=r?0:parseFloat(o.borderTopWidth),m=r?0:parseFloat(o.borderRightWidth),w=r?0:parseFloat(o.borderBottomWidth),b=u+f,F=d+l,v=(r?0:parseFloat(o.borderLeftWidth))+m,W=g+w,y=r?0:t.offsetHeight-W-t.clientHeight,E=r?0:t.offsetWidth-v-t.clientWidth,R=b+v,z=F+W,M=r?t.width:parseFloat(o.width)-R-E,O=r?t.height:parseFloat(o.height)-z-y;if(n.has(t)){var k=n.get(t);if(k[0]===M&&k[1]===O)return}n.set(t,[M,O]);var S=Object.create(h.prototype);S.target=t,S.contentRect=new c(u,d,M,O),s.has(i)||(s.set(i,[]),p.add(i)),s.get(i).push(S)}))})),p.forEach((function(e){i.get(e).call(e,s.get(e),e)}))}return s.prototype.observe=function(i){if(i instanceof window.Element){r.has(i)||(r.set(i,new Set),o.add(i),a.set(i,window.getComputedStyle(i)));var n=r.get(i);n.has(this)||n.add(this),cancelAnimationFrame(t),t=requestAnimationFrame(d)}},s.prototype.unobserve=function(i){if(i instanceof window.Element&&r.has(i)){var n=r.get(i);n.has(this)&&(n.delete(this),n.size||(r.delete(i),o.delete(i))),n.size||r.delete(i),o.size||cancelAnimationFrame(t)}},A.DOMRectReadOnly=c,A.ResizeObserver=s,A.ResizeObserverEntry=h,A}; // eslint-disable-line
mpl.toolbar_items = [["Home", "Reset original view", "fa fa-home icon-home", "home"], ["Back", "Back to previous view", "fa fa-arrow-left icon-arrow-left", "back"], ["Forward", "Forward to next view", "fa fa-arrow-right icon-arrow-right", "forward"], ["", "", "", ""], ["Pan", "Left button pans, Right button zooms\nx/y fixes axis, CTRL fixes aspect", "fa fa-arrows icon-move", "pan"], ["Zoom", "Zoom to rectangle\nx/y fixes axis", "fa fa-square-o icon-check-empty", "zoom"], ["", "", "", ""], ["Download", "Download plot", "fa fa-floppy-o icon-save", "download"]];

mpl.extensions = ["eps", "jpeg", "pgf", "pdf", "png", "ps", "raw", "svg", "tif"];

mpl.default_extension = "png";/* global mpl */

var comm_websocket_adapter = function (comm) {
    // Create a "websocket"-like object which calls the given IPython comm
    // object with the appropriate methods. Currently this is a non binary
    // socket, so there is still some room for performance tuning.
    var ws = {};

    ws.binaryType = comm.kernel.ws.binaryType;
    ws.readyState = comm.kernel.ws.readyState;
    function updateReadyState(_event) {
        if (comm.kernel.ws) {
            ws.readyState = comm.kernel.ws.readyState;
        } else {
            ws.readyState = 3; // Closed state.
        }
    }
    comm.kernel.ws.addEventListener('open', updateReadyState);
    comm.kernel.ws.addEventListener('close', updateReadyState);
    comm.kernel.ws.addEventListener('error', updateReadyState);

    ws.close = function () {
        comm.close();
    };
    ws.send = function (m) {
        //console.log('sending', m);
        comm.send(m);
    };
    // Register the callback with on_msg.
    comm.on_msg(function (msg) {
        //console.log('receiving', msg['content']['data'], msg);
        var data = msg['content']['data'];
        if (data['blob'] !== undefined) {
            data = {
                data: new Blob(msg['buffers'], { type: data['blob'] }),
            };
        }
        // Pass the mpl event to the overridden (by mpl) onmessage function.
        ws.onmessage(data);
    });
    return ws;
};

mpl.mpl_figure_comm = function (comm, msg) {
    // This is the function which gets called when the mpl process
    // starts-up an IPython Comm through the "matplotlib" channel.

    var id = msg.content.data.id;
    // Get hold of the div created by the display call when the Comm
    // socket was opened in Python.
    var element = document.getElementById(id);
    var ws_proxy = comm_websocket_adapter(comm);

    function ondownload(figure, _format) {
        window.open(figure.canvas.toDataURL());
    }

    var fig = new mpl.figure(id, ws_proxy, ondownload, element);

    // Call onopen now - mpl needs it, as it is assuming we've passed it a real
    // web socket which is closed, not our websocket->open comm proxy.
    ws_proxy.onopen();

    fig.parent_element = element;
    fig.cell_info = mpl.find_output_cell("<div id='" + id + "'></div>");
    if (!fig.cell_info) {
        console.error('Failed to find cell for figure', id, fig);
        return;
    }
    fig.cell_info[0].output_area.element.on(
        'cleared',
        { fig: fig },
        fig._remove_fig_handler
    );
};

mpl.figure.prototype.handle_close = function (fig, msg) {
    var width = fig.canvas.width / fig.ratio;
    fig.cell_info[0].output_area.element.off(
        'cleared',
        fig._remove_fig_handler
    );
    fig.resizeObserverInstance.unobserve(fig.canvas_div);

    // Update the output cell to use the data from the current canvas.
    fig.push_to_output();
    var dataURL = fig.canvas.toDataURL();
    // Re-enable the keyboard manager in IPython - without this line, in FF,
    // the notebook keyboard shortcuts fail.
    IPython.keyboard_manager.enable();
    fig.parent_element.innerHTML =
        '<img src="' + dataURL + '" width="' + width + '">';
    fig.close_ws(fig, msg);
};

mpl.figure.prototype.close_ws = function (fig, msg) {
    fig.send_message('closing', msg);
    // fig.ws.close()
};

mpl.figure.prototype.push_to_output = function (_remove_interactive) {
    // Turn the data on the canvas into data in the output cell.
    var width = this.canvas.width / this.ratio;
    var dataURL = this.canvas.toDataURL();
    this.cell_info[1]['text/html'] =
        '<img src="' + dataURL + '" width="' + width + '">';
};

mpl.figure.prototype.updated_canvas_event = function () {
    // Tell IPython that the notebook contents must change.
    IPython.notebook.set_dirty(true);
    this.send_message('ack', {});
    var fig = this;
    // Wait a second, then push the new image to the DOM so
    // that it is saved nicely (might be nice to debounce this).
    setTimeout(function () {
        fig.push_to_output();
    }, 1000);
};

mpl.figure.prototype._init_toolbar = function () {
    var fig = this;

    var toolbar = document.createElement('div');
    toolbar.classList = 'btn-toolbar';
    this.root.appendChild(toolbar);

    function on_click_closure(name) {
        return function (_event) {
            return fig.toolbar_button_onclick(name);
        };
    }

    function on_mouseover_closure(tooltip) {
        return function (event) {
            if (!event.currentTarget.disabled) {
                return fig.toolbar_button_onmouseover(tooltip);
            }
        };
    }

    fig.buttons = {};
    var buttonGroup = document.createElement('div');
    buttonGroup.classList = 'btn-group';
    var button;
    for (var toolbar_ind in mpl.toolbar_items) {
        var name = mpl.toolbar_items[toolbar_ind][0];
        var tooltip = mpl.toolbar_items[toolbar_ind][1];
        var image = mpl.toolbar_items[toolbar_ind][2];
        var method_name = mpl.toolbar_items[toolbar_ind][3];

        if (!name) {
            /* Instead of a spacer, we start a new button group. */
            if (buttonGroup.hasChildNodes()) {
                toolbar.appendChild(buttonGroup);
            }
            buttonGroup = document.createElement('div');
            buttonGroup.classList = 'btn-group';
            continue;
        }

        button = fig.buttons[name] = document.createElement('button');
        button.classList = 'btn btn-default';
        button.href = '#';
        button.title = name;
        button.innerHTML = '<i class="fa ' + image + ' fa-lg"></i>';
        button.addEventListener('click', on_click_closure(method_name));
        button.addEventListener('mouseover', on_mouseover_closure(tooltip));
        buttonGroup.appendChild(button);
    }

    if (buttonGroup.hasChildNodes()) {
        toolbar.appendChild(buttonGroup);
    }

    // Add the status bar.
    var status_bar = document.createElement('span');
    status_bar.classList = 'mpl-message pull-right';
    toolbar.appendChild(status_bar);
    this.message = status_bar;

    // Add the close button to the window.
    var buttongrp = document.createElement('div');
    buttongrp.classList = 'btn-group inline pull-right';
    button = document.createElement('button');
    button.classList = 'btn btn-mini btn-primary';
    button.href = '#';
    button.title = 'Stop Interaction';
    button.innerHTML = '<i class="fa fa-power-off icon-remove icon-large"></i>';
    button.addEventListener('click', function (_evt) {
        fig.handle_close(fig, {});
    });
    button.addEventListener(
        'mouseover',
        on_mouseover_closure('Stop Interaction')
    );
    buttongrp.appendChild(button);
    var titlebar = this.root.querySelector('.ui-dialog-titlebar');
    titlebar.insertBefore(buttongrp, titlebar.firstChild);
};

mpl.figure.prototype._remove_fig_handler = function (event) {
    var fig = event.data.fig;
    if (event.target !== this) {
        // Ignore bubbled events from children.
        return;
    }
    fig.close_ws(fig, {});
};

mpl.figure.prototype._root_extra_style = function (el) {
    el.style.boxSizing = 'content-box'; // override notebook setting of border-box.
};

mpl.figure.prototype._canvas_extra_style = function (el) {
    // this is important to make the div 'focusable
    el.setAttribute('tabindex', 0);
    // reach out to IPython and tell the keyboard manager to turn it's self
    // off when our div gets focus

    // location in version 3
    if (IPython.notebook.keyboard_manager) {
        IPython.notebook.keyboard_manager.register_events(el);
    } else {
        // location in version 2
        IPython.keyboard_manager.register_events(el);
    }
};

mpl.figure.prototype._key_event_extra = function (event, _name) {
    // Check for shift+enter
    if (event.shiftKey && event.which === 13) {
        this.canvas_div.blur();
        // select the cell after this one
        var index = IPython.notebook.find_cell_index(this.cell_info[0]);
        IPython.notebook.select(index + 1);
    }
};

mpl.figure.prototype.handle_save = function (fig, _msg) {
    fig.ondownload(fig, null);
};

mpl.find_output_cell = function (html_output) {
    // Return the cell and output element which can be found *uniquely* in the notebook.
    // Note - this is a bit hacky, but it is done because the "notebook_saving.Notebook"
    // IPython event is triggered only after the cells have been serialised, which for
    // our purposes (turning an active figure into a static one), is too late.
    var cells = IPython.notebook.get_cells();
    var ncells = cells.length;
    for (var i = 0; i < ncells; i++) {
        var cell = cells[i];
        if (cell.cell_type === 'code') {
            for (var j = 0; j < cell.output_area.outputs.length; j++) {
                var data = cell.output_area.outputs[j];
                if (data.data) {
                    // IPython >= 3 moved mimebundle to data attribute of output
                    data = data.data;
                }
                if (data['text/html'] === html_output) {
                    return [cell, data, j];
                }
            }
        }
    }
};

// Register the function which deals with the matplotlib target/channel.
// The kernel may be null if the page has been refreshed.
if (IPython.notebook.kernel !== null) {
    IPython.notebook.kernel.comm_manager.register_target(
        'matplotlib',
        mpl.mpl_figure_comm
    );
}

</script>
</div>
<div class="cell-output cell-output-display">
<img src="data:image/png;base64,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T00BRHvavHlzHDhwIBtPf26//fZ4880347bbbotXX301pkyZEuvWrYuhQ4fWlzFCoJQCtWA9BcPpR6j2/TZ2747YujXi2Wcjnnoqov2MkKal9KNA++UL8bOfpTstNm01CiZAgAABAgQIECBQRECAXkSvwHtXr14daegtpRvAdUypFz3diC4NEoF+K5CC9fZr1TulWtC+b19EujFbevLAmjV9PzU+Xc7Rfuf1+NznIgYNivZftCJGjIj25xO+dRf2Tis2QYAAAQIECBAgQKA8AgL08rSFmhCorkBe0N5+bXin3vb2y0Fi3LiI/0u3cGtPKfiu3WVdIH7CxF8CBAgQIECAAIF+LSBA79fNp/IEznCBvMD9DN9km0eAAAECBAgQIFBdgbOru+m2nAABAgQIECBAgAABAgQIlEdAgF6etlATAgQIECBAgAABAgQIEKiwgAC9wo1v0wkQIECAAAECBAgQIECgPAIC9PK0hZoQIECAAAECBAgQIECAQIUFBOgVbnybToAAAQIECBAgQIAAAQLlERCgl6ct1IQAAQIECBAgQIAAAQIEKiwgQK9w49t0AgQIECBAgAABAgQIECiPgAC9PG2hJgQIECBAgAABAgQIECBQYQEBeoUb36YTIECAAAECBAgQIECAQHkEBOjlaQs1IUCAAAECBAgQIECAAIEKCwjQK9z4Np0AAQIECBAgQIAAAQIEyiMgQC9PW6gJAQIECBAgQIAAAQIECFRYQIBe4ca36QQIECBAgAABAgQIECBQHgEBennaQk0IECBAgAABAgQIECBAoMICAvQKN75NJ0CAAAECBAgQIECAAIHyCAjQy9MWakKAAAECBAgQIECAAAECFRYQoFe48W06AQIECBAgQIAAAQIECJRHQIBenrZQEwIECBAgQIAAAQIECBCosIAAvcKNb9MJECBAgAABAgQIECBAoDwCAvTytIWaECBAgAABAgQIECBAgECFBQToFW58m06AAAECBAgQIECAAAEC5REQoJenLdSEAAECBAgQIECAAAECBCosIECvcOPbdAIECBAgQIAAAQIECBAoj4AAvTxtoSYECBAgQIAAAQIECBAgUGEBAXqFG9+mEyBAgAABAgQIECBAgEB5BATo5WkLNSFAgAABAgQIECBAgACBCgsI0Cvc+DadAAECBAgQIECAAAECBMojIEAvT1uoCQECBAgQIECAAAECBAhUWECAXuHGt+kECBAgQIAAAQIECBAgUB4BAXp52kJNCBAgQIAAAQIECBAgQKDCAgL0Cje+TSdAgAABAgQIECBAgACB8ggI0MvTFmpCgAABAgQIECBAgAABAhUWEKBXuPFtOgECBAgQIECAAAECBAiUR0CAXp62UBMCBAgQIECAAAECBAgQqLCAAL3CjW/TCRAgQIAAAQIECBAgQKA8AgL0FrXFPffcE1dddVUMGTIkhg8f3lAt5syZE2eddVan4aMf/WhD77UQAQIECBAgQIAAAQIECJRbQIDeovY5cuRIzJo1K2699dY+1WDmzJnx73//uz787ne/69P7LUyAAAECBAgQIECAAAEC5RR4RzmrdebXavHixdlGrl69uk8bO3DgwBg1alSf3mNhAgQIECBAgAABAgQIECi/gB708rdRpxo+/vjjccEFF8Rll10Wt9xyS7z00kud5psgQIAAAQIECBAgQIAAgf4poAe9H7Xbtddem50WP378+Ni2bVt8+9vfjmuuuSaefvrpSD3reenw4cORhlo6ePBgNnr06NFIg3RCoGZRe+XylkDNpPb61pxqj9U8aq/V1ui89TWT2mvnudWd4lHdtrflBAgQIECgUQEBeqNSDSy3aNGiqJ263tPiGzZsiMmTJ/c0u9f8z372s/X5l19+eVZOCtZ/+9vfxo033lif13FkyZIluXV67LHHshvUdVzWeMT69esx9CDAJh+GS75LymXT2ebQoUOdM0wRIECAAAECBLoICNC7gBSZnDdvXsyePbvXIiZMmNDr/L7MfM973hMpQP/nP//Z49vuuOOOWLBgQX1+6kEfO3ZsTJs2Lc4///x6ftVHUs9WCiamT58eAwYMqDpHp+1n04mjPsGlTtFthE03kizjlVdeyZ8hlwABAgQIECDwPwEB+incFUaOHBlpOF0pHezt3LkzUqDeU0qnvued/p6CUIFodzUu3U1qOWxqEp1fuXT26DjFpqNG+MztzGGKAAECBAgQyBFwk7gclNORtWPHjnjuuecivR47diwbT9Ovv/56ffUTJ06MtWvXZtMp/5vf/GY89dRTsX379kg3i7vuuuuyHwRuuOGG+nuMECBAgAABAgQIECBAgED/FNCD3qJ2u+uuu+Lhhx+ur/2KK67IxtO14VOnTs3GN2/eHAcOHMjGzznnnHj++efjkUceif3792e95uk09UcffTSGDh2aLeMPAQIECBAgQIAAAQIECPRfAQF6i9ouPf88Db2ltra2+uzBgwfHH//4x/q0EQIECBAg0GqBdEbXd77znfjTn/4Ue/bsidGjR8fnP//5WLhwYZx77rmtrp71EyBAgACBficgQO93TabCBAgQIECgHAKbNm2K48ePx8qVK+PSSy+NjRs3xi233BJvvPFGLF26tByVVAsCBAgQINCPBATo/aixVJUAAQIECJRJYObMmZGGWrr44osjXZ61YsUKAXoNxSsBAgQIEOiDgJvE9QHLogQIECBAgEDvAuneKSNGjOh9IXMJECBAgACBXAE96LksMgkQIECAAIG+CmzdujWWL18ey5Yt6/Wthw8fjjTU0sGDB7PRo0ePRhpamWrrr722si5lWnfNo/Zaprq1ui41k9prq+tTlvXXPGqvZalXGepRM6m9trJOZahDK7e/jOsWoJexVdSJAAECBAi0UGDRokWxePHiXmuwYcOGmDx5cn2Z3bt3Z6e7z5o1K+bOnVvPzxtZsmRJbvnr1q2LIUOG5L3ltOetX7/+tK+zP6yQS8+txCbfhku+S8otg82hQ4d6rqA5LREQoLeE3UoJECBAgEB5BebNmxezZ8/utYITJkyoz0/BeXr055VXXhkPPfRQPb+nkTvuuCMWLFhQn5160MeOHRszZsyIYcOG1fNbMZJ6k9JB8/Tp02PAgAGtqEIp18ml52Zhk2/DJd8l5ZbJpnYGU8+1Ned0CwjQT7e49REgQIAAgZILjBw5MtLQSNq1a1cWnE+aNClWrVoVZ5998tvbDBw4MNLQNaWAuCxBcZnq0tWpldNcetZnk2/DJd8l5ZbBJtVBKpeAAL1c7aE2BAgQIECg3wiknvOpU6fGuHHjsru27927t173UaNG1ceNECBAgAABAo0JCNAbc7IUAQIECBAg0EUgXTO+ZcuWbBgzZkynuW1tbZ2mTRAgQIAAAQInFzj5eWgnL8MSBAgQIECAQAUF5syZEykQzxsqyGGTCRAgQIBAYQEBemFCBRAgQIAAAQIECBAgQIAAgeICAvTihkogQIAAAQIECBAgQIAAAQKFBQTohQkVQIAAAQIECBAgQIAAAQIEigsI0IsbKoEAAQIECBAgQIAAAQIECBQWEKAXJlQAAQIECBAgQIAAAQIECBAoLiBAL26oBAIECBAgQIAAAQIECBAgUFhAgF6YUAEECBAgQIAAAQIECBAgQKC4gAC9uKESCBAgQIAAAQIECBAgQIBAYQEBemFCBRAgQIAAAQIECBAgQIAAgeICAvTihkogQIAAAQIECBAgQIAAAQKFBQTohQkVQIAAAQIECBAgQIAAAQIEigsI0IsbKoEAAQIECBAgQIAAAQIECBQWEKAXJlQAAQIECBAgQIAAAQIECBAoLiBAL26oBAIECBAgQIAAAQIECBAgUFhAgF6YUAEECBAgQIAAAQIECBAgQKC4gAC9uKESCBAgQIAAAQIECBAgQIBAYQEBemFCBRAgQIAAAQIECBAgQIAAgeICAvTihkogQIAAAQIECBAgQIAAAQKFBQTohQkVQIAAAQIECBAgQIAAAQIEigsI0IsbKoEAAQIECBAgQIAAAQIECBQWEKAXJlQAAQIECBAgQIAAAQIECBAoLiBAL26oBAIECBAgQIAAAQIECBAgUFhAgF6YUAEECBAgQIAAAQIECBAgQKC4gAC9uKESCBAgQIAAAQIECBAgQIBAYQEBemFCBRAgQIAAAQIECBAgQIAAgeICAvTihkogQIAAAQIECBAgQIAAAQKFBQTohQkVQIAAAQIECBAgQIAAAQIEigsI0Isb9rmE7du3x8033xwXXXRRDB48OC655JK4++6748iRI72W1dbWFosWLYrRo0dn75s6dWq88MILvb7HTAIECBAgQIAAAQIECBDoHwIC9Ba006ZNm+L48eOxcuXKLMC+77774sEHH4w777yz19r84Ac/iB/96EfxwAMPxIYNG2LUqFExffr0eO2113p9n5kECBAgQIAAAQIECBAgUH6Bd5S/imdeDWfOnBlpqKWLL744Nm/eHCtWrIilS5fWsju9pt7z+++/PxYuXBg33nhjNu/hhx+OCy+8MNasWRNf+cpXOi1vggABAgQIECBAgAABAgT6l4Ae9JK014EDB2LEiBE91mbbtm2xZ8+emDFjRn2ZgQMHxtVXXx1PPvlkPc8IAQIECBAgQIAAAQIECPRPAT3oJWi3rVu3xvLly2PZsmU91iYF5ymlHvOOKU3/61//6pjVafzw4cORhlpKPwSktG/fvlqW13aBo0ePxqFDh+KVV16JAQMGMOkgwKYDRodRLh0wuoyy6QLyv8na5246I0rqLFAzOXjwYOcZLZiq7b+pLr4P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VTYBAgQIECBAgAABAgQIEGhQQIDeIJTFCBAgQIAAAQIECBAgQIBAMwUE6M3UVTYBAgQIECBAgAABAgQIEGhQQIDeIJTFCBAgQIAAAQIECBAgQIBAMwUE6M3UVTYBAgQIECBAgAABAgQIEGhQQIDeIJTFCBAgQIAAAQIECBAgQIBAMwUE6M3UVTYBAgQIECBAgAABAgQIEGhQQIDeIJTFCBAgQIAAAQIECBAgQIBAMwUE6M3UVTYBAgQIECBAgAABAgQIEGhQQIDeIJTFCBAgQIAAAQIECBAgQIBAMwUE6M3UVTYBAgQIECBAgAABAgQIEGhQQIDeIJTFCBAgQIAAAQIECBAgQIBAMwUE6M3UVTYBAgQIECBAgAABAgQIEGhQQIDeIJTFCBAgQIAAAQIECBAgQIBAMwUE6M3UVTYBAgQIECBAgAABAgQIEGhQQIDeIJTFCBAgQIAAAQIECBAgQIBAMwUE6M3UVTYBAgQIECBAgAABAgQIEGhQQIDeIJTFCBAgQIAAAQIECBAgQIBAMwUE6M3UVTYBAgQIECBAgAABAgQIEGhQQIDeIJTFCBAgQIAAAQIECBAgQIBAMwUE6M3UVTYBAgQIECBAgAABAgQIEGhQ4P8BNEAcIhUA9j4AAAAASUVORK5CYII=" width="1000">
</div>
</div>
<p><strong>Question:</strong> - Given the contour in red above, and the corresponding clockwise mapping in green, - what can you tell about the number of poles and zeros inside the red contour?</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb13"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Uncomment the following line to see the solution</span></span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a><span class="op">!</span>cat answers<span class="op">/</span>solution_nyquist_1</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>
* Circles the origin once in the clockwise direction, so there must be one more zero than poles inside the contour

* It is important to note that we can only tell about the relative difference between poles and zeros</code></pre>
</div>
</div>
<p>Let‚Äôs see another example:</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb15"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a><span class="co"># %matplotlib notebook</span></span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a>fig, axs <span class="op">=</span> plt.subplots(<span class="dv">1</span>, <span class="dv">2</span>, figsize<span class="op">=</span>(<span class="dv">10</span>, <span class="dv">5</span>))<span class="op">;</span></span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true" tabindex="-1"></a>line_0, <span class="op">=</span> axs[<span class="dv">0</span>].plot([])     <span class="co"># A tuple unpacking to unpack the only plot</span></span>
<span id="cb15-4"><a href="#cb15-4" aria-hidden="true" tabindex="-1"></a>line_1, <span class="op">=</span> axs[<span class="dv">1</span>].plot([])     <span class="co"># A tuple unpacking to unpack the only plot</span></span>
<span id="cb15-5"><a href="#cb15-5" aria-hidden="true" tabindex="-1"></a>axs[<span class="dv">0</span>].grid()</span>
<span id="cb15-6"><a href="#cb15-6" aria-hidden="true" tabindex="-1"></a>axs[<span class="dv">1</span>].grid()</span>
<span id="cb15-7"><a href="#cb15-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-8"><a href="#cb15-8" aria-hidden="true" tabindex="-1"></a>xoff <span class="op">=</span> <span class="op">-</span><span class="dv">1</span>  <span class="co"># X-offset of the contour</span></span>
<span id="cb15-9"><a href="#cb15-9" aria-hidden="true" tabindex="-1"></a>yoff <span class="op">=</span> <span class="dv">0</span><span class="op">;</span>     <span class="co"># Y-offset of the contour</span></span>
<span id="cb15-10"><a href="#cb15-10" aria-hidden="true" tabindex="-1"></a>angles <span class="op">=</span> np.linspace(<span class="dv">2</span><span class="op">*</span>np.pi, <span class="dv">0</span>, <span class="dv">160</span>)<span class="op">;</span>  <span class="co"># Generate angles around the circle; 160 is tje Number of points around the circular contour</span></span>
<span id="cb15-11"><a href="#cb15-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-12"><a href="#cb15-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-13"><a href="#cb15-13" aria-hidden="true" tabindex="-1"></a>pt <span class="op">=</span> [<span class="dv">2</span><span class="op">*</span>np.cos(angles)<span class="op">+</span>xoff, <span class="dv">2</span><span class="op">*</span>np.sin(angles)<span class="op">+</span>yoff]<span class="op">;</span> </span>
<span id="cb15-14"><a href="#cb15-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-15"><a href="#cb15-15" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> animate_plot(<span class="bu">bin</span>):    </span>
<span id="cb15-16"><a href="#cb15-16" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Set 's' to the next point on the contour</span></span>
<span id="cb15-17"><a href="#cb15-17" aria-hidden="true" tabindex="-1"></a>    s <span class="op">=</span> <span class="bu">complex</span>(pt[<span class="dv">0</span>][<span class="bu">bin</span>], pt[<span class="dv">1</span>][<span class="bu">bin</span>])<span class="op">;</span></span>
<span id="cb15-18"><a href="#cb15-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-19"><a href="#cb15-19" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Plot the next point on the contour in the s-plane    </span></span>
<span id="cb15-20"><a href="#cb15-20" aria-hidden="true" tabindex="-1"></a>    line_0 <span class="op">=</span> axs[<span class="dv">0</span>].plot(np.real(s), np.imag(s), color<span class="op">=</span><span class="st">'red'</span>, marker<span class="op">=</span><span class="st">'.'</span>, markersize<span class="op">=</span><span class="dv">15</span>)<span class="op">;</span></span>
<span id="cb15-21"><a href="#cb15-21" aria-hidden="true" tabindex="-1"></a>    axs[<span class="dv">0</span>].set_title(<span class="st">'S-plane Contour'</span>)<span class="op">;</span></span>
<span id="cb15-22"><a href="#cb15-22" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb15-23"><a href="#cb15-23" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Define the system transfer function</span></span>
<span id="cb15-24"><a href="#cb15-24" aria-hidden="true" tabindex="-1"></a>    tnf <span class="op">=</span> (s<span class="op">+</span><span class="dv">1</span>)<span class="op">/</span>((s<span class="op">+</span><span class="fl">1.7</span>)<span class="op">*</span>(s<span class="op">+</span><span class="fl">2.8</span>)<span class="op">*</span>(s<span class="op">+</span><span class="dv">2</span>))</span>
<span id="cb15-25"><a href="#cb15-25" aria-hidden="true" tabindex="-1"></a>    axs[<span class="dv">0</span>].set_xlim([<span class="op">-</span><span class="dv">4</span>, <span class="dv">4</span>])</span>
<span id="cb15-26"><a href="#cb15-26" aria-hidden="true" tabindex="-1"></a>    axs[<span class="dv">0</span>].set_ylim([<span class="op">-</span><span class="dv">2</span>, <span class="dv">2</span>])<span class="op">;</span></span>
<span id="cb15-27"><a href="#cb15-27" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-28"><a href="#cb15-28" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Plot the mapping from the TF in the w-plane    </span></span>
<span id="cb15-29"><a href="#cb15-29" aria-hidden="true" tabindex="-1"></a>    line_1 <span class="op">=</span> axs[<span class="dv">1</span>].plot(np.real(tnf), np.imag(tnf), color<span class="op">=</span><span class="st">'g'</span>, marker<span class="op">=</span><span class="st">'.'</span>, markersize<span class="op">=</span><span class="dv">15</span>)<span class="op">;</span></span>
<span id="cb15-30"><a href="#cb15-30" aria-hidden="true" tabindex="-1"></a>    axs[<span class="dv">1</span>].plot(<span class="dv">0</span>, <span class="dv">0</span>, marker<span class="op">=</span><span class="st">'.'</span>, color<span class="op">=</span><span class="st">'k'</span>, markersize<span class="op">=</span><span class="dv">15</span>)<span class="op">;</span></span>
<span id="cb15-31"><a href="#cb15-31" aria-hidden="true" tabindex="-1"></a>    axs[<span class="dv">1</span>].set_title(<span class="st">'$\Omega$-plane Plot'</span>)<span class="op">;</span>        </span>
<span id="cb15-32"><a href="#cb15-32" aria-hidden="true" tabindex="-1"></a>    axs[<span class="dv">1</span>].set_xlim([<span class="op">-</span><span class="dv">5</span>, <span class="dv">10</span>])</span>
<span id="cb15-33"><a href="#cb15-33" aria-hidden="true" tabindex="-1"></a>    axs[<span class="dv">1</span>].set_ylim([<span class="op">-</span><span class="dv">10</span>, <span class="dv">10</span>])<span class="op">;</span></span>
<span id="cb15-34"><a href="#cb15-34" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-35"><a href="#cb15-35" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> line_0, line_1</span>
<span id="cb15-36"><a href="#cb15-36" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-37"><a href="#cb15-37" aria-hidden="true" tabindex="-1"></a>anim <span class="op">=</span> FuncAnimation(fig, animate_plot, frames<span class="op">=</span><span class="bu">len</span>(angles), interval<span class="op">=</span><span class="dv">20</span>)</span>
<span id="cb15-38"><a href="#cb15-38" aria-hidden="true" tabindex="-1"></a>anim<span class="op">;</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<script type="application/javascript">
/* Put everything inside the global mpl namespace */
/* global mpl */
window.mpl = {};

mpl.get_websocket_type = function () {
    if (typeof WebSocket !== 'undefined') {
        return WebSocket;
    } else if (typeof MozWebSocket !== 'undefined') {
        return MozWebSocket;
    } else {
        alert(
            'Your browser does not have WebSocket support. ' +
                'Please try Chrome, Safari or Firefox ‚â• 6. ' +
                'Firefox 4 and 5 are also supported but you ' +
                'have to enable WebSockets in about:config.'
        );
    }
};

mpl.figure = function (figure_id, websocket, ondownload, parent_element) {
    this.id = figure_id;

    this.ws = websocket;

    this.supports_binary = this.ws.binaryType !== undefined;

    if (!this.supports_binary) {
        var warnings = document.getElementById('mpl-warnings');
        if (warnings) {
            warnings.style.display = 'block';
            warnings.textContent =
                'This browser does not support binary websocket messages. ' +
                'Performance may be slow.';
        }
    }

    this.imageObj = new Image();

    this.context = undefined;
    this.message = undefined;
    this.canvas = undefined;
    this.rubberband_canvas = undefined;
    this.rubberband_context = undefined;
    this.format_dropdown = undefined;

    this.image_mode = 'full';

    this.root = document.createElement('div');
    this.root.setAttribute('style', 'display: inline-block');
    this._root_extra_style(this.root);

    parent_element.appendChild(this.root);

    this._init_header(this);
    this._init_canvas(this);
    this._init_toolbar(this);

    var fig = this;

    this.waiting = false;

    this.ws.onopen = function () {
        fig.send_message('supports_binary', { value: fig.supports_binary });
        fig.send_message('send_image_mode', {});
        if (fig.ratio !== 1) {
            fig.send_message('set_device_pixel_ratio', {
                device_pixel_ratio: fig.ratio,
            });
        }
        fig.send_message('refresh', {});
    };

    this.imageObj.onload = function () {
        if (fig.image_mode === 'full') {
            // Full images could contain transparency (where diff images
            // almost always do), so we need to clear the canvas so that
            // there is no ghosting.
            fig.context.clearRect(0, 0, fig.canvas.width, fig.canvas.height);
        }
        fig.context.drawImage(fig.imageObj, 0, 0);
    };

    this.imageObj.onunload = function () {
        fig.ws.close();
    };

    this.ws.onmessage = this._make_on_message_function(this);

    this.ondownload = ondownload;
};

mpl.figure.prototype._init_header = function () {
    var titlebar = document.createElement('div');
    titlebar.classList =
        'ui-dialog-titlebar ui-widget-header ui-corner-all ui-helper-clearfix';
    var titletext = document.createElement('div');
    titletext.classList = 'ui-dialog-title';
    titletext.setAttribute(
        'style',
        'width: 100%; text-align: center; padding: 3px;'
    );
    titlebar.appendChild(titletext);
    this.root.appendChild(titlebar);
    this.header = titletext;
};

mpl.figure.prototype._canvas_extra_style = function (_canvas_div) {};

mpl.figure.prototype._root_extra_style = function (_canvas_div) {};

mpl.figure.prototype._init_canvas = function () {
    var fig = this;

    var canvas_div = (this.canvas_div = document.createElement('div'));
    canvas_div.setAttribute(
        'style',
        'border: 1px solid #ddd;' +
            'box-sizing: content-box;' +
            'clear: both;' +
            'min-height: 1px;' +
            'min-width: 1px;' +
            'outline: 0;' +
            'overflow: hidden;' +
            'position: relative;' +
            'resize: both;'
    );

    function on_keyboard_event_closure(name) {
        return function (event) {
            return fig.key_event(event, name);
        };
    }

    canvas_div.addEventListener(
        'keydown',
        on_keyboard_event_closure('key_press')
    );
    canvas_div.addEventListener(
        'keyup',
        on_keyboard_event_closure('key_release')
    );

    this._canvas_extra_style(canvas_div);
    this.root.appendChild(canvas_div);

    var canvas = (this.canvas = document.createElement('canvas'));
    canvas.classList.add('mpl-canvas');
    canvas.setAttribute('style', 'box-sizing: content-box;');

    this.context = canvas.getContext('2d');

    var backingStore =
        this.context.backingStorePixelRatio ||
        this.context.webkitBackingStorePixelRatio ||
        this.context.mozBackingStorePixelRatio ||
        this.context.msBackingStorePixelRatio ||
        this.context.oBackingStorePixelRatio ||
        this.context.backingStorePixelRatio ||
        1;

    this.ratio = (window.devicePixelRatio || 1) / backingStore;

    var rubberband_canvas = (this.rubberband_canvas = document.createElement(
        'canvas'
    ));
    rubberband_canvas.setAttribute(
        'style',
        'box-sizing: content-box; position: absolute; left: 0; top: 0; z-index: 1;'
    );

    // Apply a ponyfill if ResizeObserver is not implemented by browser.
    if (this.ResizeObserver === undefined) {
        if (window.ResizeObserver !== undefined) {
            this.ResizeObserver = window.ResizeObserver;
        } else {
            var obs = _JSXTOOLS_RESIZE_OBSERVER({});
            this.ResizeObserver = obs.ResizeObserver;
        }
    }

    this.resizeObserverInstance = new this.ResizeObserver(function (entries) {
        var nentries = entries.length;
        for (var i = 0; i < nentries; i++) {
            var entry = entries[i];
            var width, height;
            if (entry.contentBoxSize) {
                if (entry.contentBoxSize instanceof Array) {
                    // Chrome 84 implements new version of spec.
                    width = entry.contentBoxSize[0].inlineSize;
                    height = entry.contentBoxSize[0].blockSize;
                } else {
                    // Firefox implements old version of spec.
                    width = entry.contentBoxSize.inlineSize;
                    height = entry.contentBoxSize.blockSize;
                }
            } else {
                // Chrome <84 implements even older version of spec.
                width = entry.contentRect.width;
                height = entry.contentRect.height;
            }

            // Keep the size of the canvas and rubber band canvas in sync with
            // the canvas container.
            if (entry.devicePixelContentBoxSize) {
                // Chrome 84 implements new version of spec.
                canvas.setAttribute(
                    'width',
                    entry.devicePixelContentBoxSize[0].inlineSize
                );
                canvas.setAttribute(
                    'height',
                    entry.devicePixelContentBoxSize[0].blockSize
                );
            } else {
                canvas.setAttribute('width', width * fig.ratio);
                canvas.setAttribute('height', height * fig.ratio);
            }
            canvas.setAttribute(
                'style',
                'width: ' + width + 'px; height: ' + height + 'px;'
            );

            rubberband_canvas.setAttribute('width', width);
            rubberband_canvas.setAttribute('height', height);

            // And update the size in Python. We ignore the initial 0/0 size
            // that occurs as the element is placed into the DOM, which should
            // otherwise not happen due to the minimum size styling.
            if (fig.ws.readyState == 1 && width != 0 && height != 0) {
                fig.request_resize(width, height);
            }
        }
    });
    this.resizeObserverInstance.observe(canvas_div);

    function on_mouse_event_closure(name) {
        return function (event) {
            return fig.mouse_event(event, name);
        };
    }

    rubberband_canvas.addEventListener(
        'mousedown',
        on_mouse_event_closure('button_press')
    );
    rubberband_canvas.addEventListener(
        'mouseup',
        on_mouse_event_closure('button_release')
    );
    rubberband_canvas.addEventListener(
        'dblclick',
        on_mouse_event_closure('dblclick')
    );
    // Throttle sequential mouse events to 1 every 20ms.
    rubberband_canvas.addEventListener(
        'mousemove',
        on_mouse_event_closure('motion_notify')
    );

    rubberband_canvas.addEventListener(
        'mouseenter',
        on_mouse_event_closure('figure_enter')
    );
    rubberband_canvas.addEventListener(
        'mouseleave',
        on_mouse_event_closure('figure_leave')
    );

    canvas_div.addEventListener('wheel', function (event) {
        if (event.deltaY < 0) {
            event.step = 1;
        } else {
            event.step = -1;
        }
        on_mouse_event_closure('scroll')(event);
    });

    canvas_div.appendChild(canvas);
    canvas_div.appendChild(rubberband_canvas);

    this.rubberband_context = rubberband_canvas.getContext('2d');
    this.rubberband_context.strokeStyle = '#000000';

    this._resize_canvas = function (width, height, forward) {
        if (forward) {
            canvas_div.style.width = width + 'px';
            canvas_div.style.height = height + 'px';
        }
    };

    // Disable right mouse context menu.
    this.rubberband_canvas.addEventListener('contextmenu', function (_e) {
        event.preventDefault();
        return false;
    });

    function set_focus() {
        canvas.focus();
        canvas_div.focus();
    }

    window.setTimeout(set_focus, 100);
};

mpl.figure.prototype._init_toolbar = function () {
    var fig = this;

    var toolbar = document.createElement('div');
    toolbar.classList = 'mpl-toolbar';
    this.root.appendChild(toolbar);

    function on_click_closure(name) {
        return function (_event) {
            return fig.toolbar_button_onclick(name);
        };
    }

    function on_mouseover_closure(tooltip) {
        return function (event) {
            if (!event.currentTarget.disabled) {
                return fig.toolbar_button_onmouseover(tooltip);
            }
        };
    }

    fig.buttons = {};
    var buttonGroup = document.createElement('div');
    buttonGroup.classList = 'mpl-button-group';
    for (var toolbar_ind in mpl.toolbar_items) {
        var name = mpl.toolbar_items[toolbar_ind][0];
        var tooltip = mpl.toolbar_items[toolbar_ind][1];
        var image = mpl.toolbar_items[toolbar_ind][2];
        var method_name = mpl.toolbar_items[toolbar_ind][3];

        if (!name) {
            /* Instead of a spacer, we start a new button group. */
            if (buttonGroup.hasChildNodes()) {
                toolbar.appendChild(buttonGroup);
            }
            buttonGroup = document.createElement('div');
            buttonGroup.classList = 'mpl-button-group';
            continue;
        }

        var button = (fig.buttons[name] = document.createElement('button'));
        button.classList = 'mpl-widget';
        button.setAttribute('role', 'button');
        button.setAttribute('aria-disabled', 'false');
        button.addEventListener('click', on_click_closure(method_name));
        button.addEventListener('mouseover', on_mouseover_closure(tooltip));

        var icon_img = document.createElement('img');
        icon_img.src = '_images/' + image + '.png';
        icon_img.srcset = '_images/' + image + '_large.png 2x';
        icon_img.alt = tooltip;
        button.appendChild(icon_img);

        buttonGroup.appendChild(button);
    }

    if (buttonGroup.hasChildNodes()) {
        toolbar.appendChild(buttonGroup);
    }

    var fmt_picker = document.createElement('select');
    fmt_picker.classList = 'mpl-widget';
    toolbar.appendChild(fmt_picker);
    this.format_dropdown = fmt_picker;

    for (var ind in mpl.extensions) {
        var fmt = mpl.extensions[ind];
        var option = document.createElement('option');
        option.selected = fmt === mpl.default_extension;
        option.innerHTML = fmt;
        fmt_picker.appendChild(option);
    }

    var status_bar = document.createElement('span');
    status_bar.classList = 'mpl-message';
    toolbar.appendChild(status_bar);
    this.message = status_bar;
};

mpl.figure.prototype.request_resize = function (x_pixels, y_pixels) {
    // Request matplotlib to resize the figure. Matplotlib will then trigger a resize in the client,
    // which will in turn request a refresh of the image.
    this.send_message('resize', { width: x_pixels, height: y_pixels });
};

mpl.figure.prototype.send_message = function (type, properties) {
    properties['type'] = type;
    properties['figure_id'] = this.id;
    this.ws.send(JSON.stringify(properties));
};

mpl.figure.prototype.send_draw_message = function () {
    if (!this.waiting) {
        this.waiting = true;
        this.ws.send(JSON.stringify({ type: 'draw', figure_id: this.id }));
    }
};

mpl.figure.prototype.handle_save = function (fig, _msg) {
    var format_dropdown = fig.format_dropdown;
    var format = format_dropdown.options[format_dropdown.selectedIndex].value;
    fig.ondownload(fig, format);
};

mpl.figure.prototype.handle_resize = function (fig, msg) {
    var size = msg['size'];
    if (size[0] !== fig.canvas.width || size[1] !== fig.canvas.height) {
        fig._resize_canvas(size[0], size[1], msg['forward']);
        fig.send_message('refresh', {});
    }
};

mpl.figure.prototype.handle_rubberband = function (fig, msg) {
    var x0 = msg['x0'] / fig.ratio;
    var y0 = (fig.canvas.height - msg['y0']) / fig.ratio;
    var x1 = msg['x1'] / fig.ratio;
    var y1 = (fig.canvas.height - msg['y1']) / fig.ratio;
    x0 = Math.floor(x0) + 0.5;
    y0 = Math.floor(y0) + 0.5;
    x1 = Math.floor(x1) + 0.5;
    y1 = Math.floor(y1) + 0.5;
    var min_x = Math.min(x0, x1);
    var min_y = Math.min(y0, y1);
    var width = Math.abs(x1 - x0);
    var height = Math.abs(y1 - y0);

    fig.rubberband_context.clearRect(
        0,
        0,
        fig.canvas.width / fig.ratio,
        fig.canvas.height / fig.ratio
    );

    fig.rubberband_context.strokeRect(min_x, min_y, width, height);
};

mpl.figure.prototype.handle_figure_label = function (fig, msg) {
    // Updates the figure title.
    fig.header.textContent = msg['label'];
};

mpl.figure.prototype.handle_cursor = function (fig, msg) {
    fig.rubberband_canvas.style.cursor = msg['cursor'];
};

mpl.figure.prototype.handle_message = function (fig, msg) {
    fig.message.textContent = msg['message'];
};

mpl.figure.prototype.handle_draw = function (fig, _msg) {
    // Request the server to send over a new figure.
    fig.send_draw_message();
};

mpl.figure.prototype.handle_image_mode = function (fig, msg) {
    fig.image_mode = msg['mode'];
};

mpl.figure.prototype.handle_history_buttons = function (fig, msg) {
    for (var key in msg) {
        if (!(key in fig.buttons)) {
            continue;
        }
        fig.buttons[key].disabled = !msg[key];
        fig.buttons[key].setAttribute('aria-disabled', !msg[key]);
    }
};

mpl.figure.prototype.handle_navigate_mode = function (fig, msg) {
    if (msg['mode'] === 'PAN') {
        fig.buttons['Pan'].classList.add('active');
        fig.buttons['Zoom'].classList.remove('active');
    } else if (msg['mode'] === 'ZOOM') {
        fig.buttons['Pan'].classList.remove('active');
        fig.buttons['Zoom'].classList.add('active');
    } else {
        fig.buttons['Pan'].classList.remove('active');
        fig.buttons['Zoom'].classList.remove('active');
    }
};

mpl.figure.prototype.updated_canvas_event = function () {
    // Called whenever the canvas gets updated.
    this.send_message('ack', {});
};

// A function to construct a web socket function for onmessage handling.
// Called in the figure constructor.
mpl.figure.prototype._make_on_message_function = function (fig) {
    return function socket_on_message(evt) {
        if (evt.data instanceof Blob) {
            var img = evt.data;
            if (img.type !== 'image/png') {
                /* FIXME: We get "Resource interpreted as Image but
                 * transferred with MIME type text/plain:" errors on
                 * Chrome.  But how to set the MIME type?  It doesn't seem
                 * to be part of the websocket stream */
                img.type = 'image/png';
            }

            /* Free the memory for the previous frames */
            if (fig.imageObj.src) {
                (window.URL || window.webkitURL).revokeObjectURL(
                    fig.imageObj.src
                );
            }

            fig.imageObj.src = (window.URL || window.webkitURL).createObjectURL(
                img
            );
            fig.updated_canvas_event();
            fig.waiting = false;
            return;
        } else if (
            typeof evt.data === 'string' &&
            evt.data.slice(0, 21) === 'data:image/png;base64'
        ) {
            fig.imageObj.src = evt.data;
            fig.updated_canvas_event();
            fig.waiting = false;
            return;
        }

        var msg = JSON.parse(evt.data);
        var msg_type = msg['type'];

        // Call the  "handle_{type}" callback, which takes
        // the figure and JSON message as its only arguments.
        try {
            var callback = fig['handle_' + msg_type];
        } catch (e) {
            console.log(
                "No handler for the '" + msg_type + "' message type: ",
                msg
            );
            return;
        }

        if (callback) {
            try {
                // console.log("Handling '" + msg_type + "' message: ", msg);
                callback(fig, msg);
            } catch (e) {
                console.log(
                    "Exception inside the 'handler_" + msg_type + "' callback:",
                    e,
                    e.stack,
                    msg
                );
            }
        }
    };
};

// from https://stackoverflow.com/questions/1114465/getting-mouse-location-in-canvas
mpl.findpos = function (e) {
    //this section is from http://www.quirksmode.org/js/events_properties.html
    var targ;
    if (!e) {
        e = window.event;
    }
    if (e.target) {
        targ = e.target;
    } else if (e.srcElement) {
        targ = e.srcElement;
    }
    if (targ.nodeType === 3) {
        // defeat Safari bug
        targ = targ.parentNode;
    }

    // pageX,Y are the mouse positions relative to the document
    var boundingRect = targ.getBoundingClientRect();
    var x = e.pageX - (boundingRect.left + document.body.scrollLeft);
    var y = e.pageY - (boundingRect.top + document.body.scrollTop);

    return { x: x, y: y };
};

/*
 * return a copy of an object with only non-object keys
 * we need this to avoid circular references
 * https://stackoverflow.com/a/24161582/3208463
 */
function simpleKeys(original) {
    return Object.keys(original).reduce(function (obj, key) {
        if (typeof original[key] !== 'object') {
            obj[key] = original[key];
        }
        return obj;
    }, {});
}

mpl.figure.prototype.mouse_event = function (event, name) {
    var canvas_pos = mpl.findpos(event);

    if (name === 'button_press') {
        this.canvas.focus();
        this.canvas_div.focus();
    }

    var x = canvas_pos.x * this.ratio;
    var y = canvas_pos.y * this.ratio;

    this.send_message(name, {
        x: x,
        y: y,
        button: event.button,
        step: event.step,
        guiEvent: simpleKeys(event),
    });

    /* This prevents the web browser from automatically changing to
     * the text insertion cursor when the button is pressed.  We want
     * to control all of the cursor setting manually through the
     * 'cursor' event from matplotlib */
    event.preventDefault();
    return false;
};

mpl.figure.prototype._key_event_extra = function (_event, _name) {
    // Handle any extra behaviour associated with a key event
};

mpl.figure.prototype.key_event = function (event, name) {
    // Prevent repeat events
    if (name === 'key_press') {
        if (event.key === this._key) {
            return;
        } else {
            this._key = event.key;
        }
    }
    if (name === 'key_release') {
        this._key = null;
    }

    var value = '';
    if (event.ctrlKey && event.key !== 'Control') {
        value += 'ctrl+';
    }
    else if (event.altKey && event.key !== 'Alt') {
        value += 'alt+';
    }
    else if (event.shiftKey && event.key !== 'Shift') {
        value += 'shift+';
    }

    value += 'k' + event.key;

    this._key_event_extra(event, name);

    this.send_message(name, { key: value, guiEvent: simpleKeys(event) });
    return false;
};

mpl.figure.prototype.toolbar_button_onclick = function (name) {
    if (name === 'download') {
        this.handle_save(this, null);
    } else {
        this.send_message('toolbar_button', { name: name });
    }
};

mpl.figure.prototype.toolbar_button_onmouseover = function (tooltip) {
    this.message.textContent = tooltip;
};

///////////////// REMAINING CONTENT GENERATED BY embed_js.py /////////////////
// prettier-ignore
var _JSXTOOLS_RESIZE_OBSERVER=function(A){var t,i=new WeakMap,n=new WeakMap,a=new WeakMap,r=new WeakMap,o=new Set;function s(e){if(!(this instanceof s))throw new TypeError("Constructor requires 'new' operator");i.set(this,e)}function h(){throw new TypeError("Function is not a constructor")}function c(e,t,i,n){e=0 in arguments?Number(arguments[0]):0,t=1 in arguments?Number(arguments[1]):0,i=2 in arguments?Number(arguments[2]):0,n=3 in arguments?Number(arguments[3]):0,this.right=(this.x=this.left=e)+(this.width=i),this.bottom=(this.y=this.top=t)+(this.height=n),Object.freeze(this)}function d(){t=requestAnimationFrame(d);var s=new WeakMap,p=new Set;o.forEach((function(t){r.get(t).forEach((function(i){var r=t instanceof window.SVGElement,o=a.get(t),d=r?0:parseFloat(o.paddingTop),f=r?0:parseFloat(o.paddingRight),l=r?0:parseFloat(o.paddingBottom),u=r?0:parseFloat(o.paddingLeft),g=r?0:parseFloat(o.borderTopWidth),m=r?0:parseFloat(o.borderRightWidth),w=r?0:parseFloat(o.borderBottomWidth),b=u+f,F=d+l,v=(r?0:parseFloat(o.borderLeftWidth))+m,W=g+w,y=r?0:t.offsetHeight-W-t.clientHeight,E=r?0:t.offsetWidth-v-t.clientWidth,R=b+v,z=F+W,M=r?t.width:parseFloat(o.width)-R-E,O=r?t.height:parseFloat(o.height)-z-y;if(n.has(t)){var k=n.get(t);if(k[0]===M&&k[1]===O)return}n.set(t,[M,O]);var S=Object.create(h.prototype);S.target=t,S.contentRect=new c(u,d,M,O),s.has(i)||(s.set(i,[]),p.add(i)),s.get(i).push(S)}))})),p.forEach((function(e){i.get(e).call(e,s.get(e),e)}))}return s.prototype.observe=function(i){if(i instanceof window.Element){r.has(i)||(r.set(i,new Set),o.add(i),a.set(i,window.getComputedStyle(i)));var n=r.get(i);n.has(this)||n.add(this),cancelAnimationFrame(t),t=requestAnimationFrame(d)}},s.prototype.unobserve=function(i){if(i instanceof window.Element&&r.has(i)){var n=r.get(i);n.has(this)&&(n.delete(this),n.size||(r.delete(i),o.delete(i))),n.size||r.delete(i),o.size||cancelAnimationFrame(t)}},A.DOMRectReadOnly=c,A.ResizeObserver=s,A.ResizeObserverEntry=h,A}; // eslint-disable-line
mpl.toolbar_items = [["Home", "Reset original view", "fa fa-home icon-home", "home"], ["Back", "Back to previous view", "fa fa-arrow-left icon-arrow-left", "back"], ["Forward", "Forward to next view", "fa fa-arrow-right icon-arrow-right", "forward"], ["", "", "", ""], ["Pan", "Left button pans, Right button zooms\nx/y fixes axis, CTRL fixes aspect", "fa fa-arrows icon-move", "pan"], ["Zoom", "Zoom to rectangle\nx/y fixes axis", "fa fa-square-o icon-check-empty", "zoom"], ["", "", "", ""], ["Download", "Download plot", "fa fa-floppy-o icon-save", "download"]];

mpl.extensions = ["eps", "jpeg", "pgf", "pdf", "png", "ps", "raw", "svg", "tif"];

mpl.default_extension = "png";/* global mpl */

var comm_websocket_adapter = function (comm) {
    // Create a "websocket"-like object which calls the given IPython comm
    // object with the appropriate methods. Currently this is a non binary
    // socket, so there is still some room for performance tuning.
    var ws = {};

    ws.binaryType = comm.kernel.ws.binaryType;
    ws.readyState = comm.kernel.ws.readyState;
    function updateReadyState(_event) {
        if (comm.kernel.ws) {
            ws.readyState = comm.kernel.ws.readyState;
        } else {
            ws.readyState = 3; // Closed state.
        }
    }
    comm.kernel.ws.addEventListener('open', updateReadyState);
    comm.kernel.ws.addEventListener('close', updateReadyState);
    comm.kernel.ws.addEventListener('error', updateReadyState);

    ws.close = function () {
        comm.close();
    };
    ws.send = function (m) {
        //console.log('sending', m);
        comm.send(m);
    };
    // Register the callback with on_msg.
    comm.on_msg(function (msg) {
        //console.log('receiving', msg['content']['data'], msg);
        var data = msg['content']['data'];
        if (data['blob'] !== undefined) {
            data = {
                data: new Blob(msg['buffers'], { type: data['blob'] }),
            };
        }
        // Pass the mpl event to the overridden (by mpl) onmessage function.
        ws.onmessage(data);
    });
    return ws;
};

mpl.mpl_figure_comm = function (comm, msg) {
    // This is the function which gets called when the mpl process
    // starts-up an IPython Comm through the "matplotlib" channel.

    var id = msg.content.data.id;
    // Get hold of the div created by the display call when the Comm
    // socket was opened in Python.
    var element = document.getElementById(id);
    var ws_proxy = comm_websocket_adapter(comm);

    function ondownload(figure, _format) {
        window.open(figure.canvas.toDataURL());
    }

    var fig = new mpl.figure(id, ws_proxy, ondownload, element);

    // Call onopen now - mpl needs it, as it is assuming we've passed it a real
    // web socket which is closed, not our websocket->open comm proxy.
    ws_proxy.onopen();

    fig.parent_element = element;
    fig.cell_info = mpl.find_output_cell("<div id='" + id + "'></div>");
    if (!fig.cell_info) {
        console.error('Failed to find cell for figure', id, fig);
        return;
    }
    fig.cell_info[0].output_area.element.on(
        'cleared',
        { fig: fig },
        fig._remove_fig_handler
    );
};

mpl.figure.prototype.handle_close = function (fig, msg) {
    var width = fig.canvas.width / fig.ratio;
    fig.cell_info[0].output_area.element.off(
        'cleared',
        fig._remove_fig_handler
    );
    fig.resizeObserverInstance.unobserve(fig.canvas_div);

    // Update the output cell to use the data from the current canvas.
    fig.push_to_output();
    var dataURL = fig.canvas.toDataURL();
    // Re-enable the keyboard manager in IPython - without this line, in FF,
    // the notebook keyboard shortcuts fail.
    IPython.keyboard_manager.enable();
    fig.parent_element.innerHTML =
        '<img src="' + dataURL + '" width="' + width + '">';
    fig.close_ws(fig, msg);
};

mpl.figure.prototype.close_ws = function (fig, msg) {
    fig.send_message('closing', msg);
    // fig.ws.close()
};

mpl.figure.prototype.push_to_output = function (_remove_interactive) {
    // Turn the data on the canvas into data in the output cell.
    var width = this.canvas.width / this.ratio;
    var dataURL = this.canvas.toDataURL();
    this.cell_info[1]['text/html'] =
        '<img src="' + dataURL + '" width="' + width + '">';
};

mpl.figure.prototype.updated_canvas_event = function () {
    // Tell IPython that the notebook contents must change.
    IPython.notebook.set_dirty(true);
    this.send_message('ack', {});
    var fig = this;
    // Wait a second, then push the new image to the DOM so
    // that it is saved nicely (might be nice to debounce this).
    setTimeout(function () {
        fig.push_to_output();
    }, 1000);
};

mpl.figure.prototype._init_toolbar = function () {
    var fig = this;

    var toolbar = document.createElement('div');
    toolbar.classList = 'btn-toolbar';
    this.root.appendChild(toolbar);

    function on_click_closure(name) {
        return function (_event) {
            return fig.toolbar_button_onclick(name);
        };
    }

    function on_mouseover_closure(tooltip) {
        return function (event) {
            if (!event.currentTarget.disabled) {
                return fig.toolbar_button_onmouseover(tooltip);
            }
        };
    }

    fig.buttons = {};
    var buttonGroup = document.createElement('div');
    buttonGroup.classList = 'btn-group';
    var button;
    for (var toolbar_ind in mpl.toolbar_items) {
        var name = mpl.toolbar_items[toolbar_ind][0];
        var tooltip = mpl.toolbar_items[toolbar_ind][1];
        var image = mpl.toolbar_items[toolbar_ind][2];
        var method_name = mpl.toolbar_items[toolbar_ind][3];

        if (!name) {
            /* Instead of a spacer, we start a new button group. */
            if (buttonGroup.hasChildNodes()) {
                toolbar.appendChild(buttonGroup);
            }
            buttonGroup = document.createElement('div');
            buttonGroup.classList = 'btn-group';
            continue;
        }

        button = fig.buttons[name] = document.createElement('button');
        button.classList = 'btn btn-default';
        button.href = '#';
        button.title = name;
        button.innerHTML = '<i class="fa ' + image + ' fa-lg"></i>';
        button.addEventListener('click', on_click_closure(method_name));
        button.addEventListener('mouseover', on_mouseover_closure(tooltip));
        buttonGroup.appendChild(button);
    }

    if (buttonGroup.hasChildNodes()) {
        toolbar.appendChild(buttonGroup);
    }

    // Add the status bar.
    var status_bar = document.createElement('span');
    status_bar.classList = 'mpl-message pull-right';
    toolbar.appendChild(status_bar);
    this.message = status_bar;

    // Add the close button to the window.
    var buttongrp = document.createElement('div');
    buttongrp.classList = 'btn-group inline pull-right';
    button = document.createElement('button');
    button.classList = 'btn btn-mini btn-primary';
    button.href = '#';
    button.title = 'Stop Interaction';
    button.innerHTML = '<i class="fa fa-power-off icon-remove icon-large"></i>';
    button.addEventListener('click', function (_evt) {
        fig.handle_close(fig, {});
    });
    button.addEventListener(
        'mouseover',
        on_mouseover_closure('Stop Interaction')
    );
    buttongrp.appendChild(button);
    var titlebar = this.root.querySelector('.ui-dialog-titlebar');
    titlebar.insertBefore(buttongrp, titlebar.firstChild);
};

mpl.figure.prototype._remove_fig_handler = function (event) {
    var fig = event.data.fig;
    if (event.target !== this) {
        // Ignore bubbled events from children.
        return;
    }
    fig.close_ws(fig, {});
};

mpl.figure.prototype._root_extra_style = function (el) {
    el.style.boxSizing = 'content-box'; // override notebook setting of border-box.
};

mpl.figure.prototype._canvas_extra_style = function (el) {
    // this is important to make the div 'focusable
    el.setAttribute('tabindex', 0);
    // reach out to IPython and tell the keyboard manager to turn it's self
    // off when our div gets focus

    // location in version 3
    if (IPython.notebook.keyboard_manager) {
        IPython.notebook.keyboard_manager.register_events(el);
    } else {
        // location in version 2
        IPython.keyboard_manager.register_events(el);
    }
};

mpl.figure.prototype._key_event_extra = function (event, _name) {
    // Check for shift+enter
    if (event.shiftKey && event.which === 13) {
        this.canvas_div.blur();
        // select the cell after this one
        var index = IPython.notebook.find_cell_index(this.cell_info[0]);
        IPython.notebook.select(index + 1);
    }
};

mpl.figure.prototype.handle_save = function (fig, _msg) {
    fig.ondownload(fig, null);
};

mpl.find_output_cell = function (html_output) {
    // Return the cell and output element which can be found *uniquely* in the notebook.
    // Note - this is a bit hacky, but it is done because the "notebook_saving.Notebook"
    // IPython event is triggered only after the cells have been serialised, which for
    // our purposes (turning an active figure into a static one), is too late.
    var cells = IPython.notebook.get_cells();
    var ncells = cells.length;
    for (var i = 0; i < ncells; i++) {
        var cell = cells[i];
        if (cell.cell_type === 'code') {
            for (var j = 0; j < cell.output_area.outputs.length; j++) {
                var data = cell.output_area.outputs[j];
                if (data.data) {
                    // IPython >= 3 moved mimebundle to data attribute of output
                    data = data.data;
                }
                if (data['text/html'] === html_output) {
                    return [cell, data, j];
                }
            }
        }
    }
};

// Register the function which deals with the matplotlib target/channel.
// The kernel may be null if the page has been refreshed.
if (IPython.notebook.kernel !== null) {
    IPython.notebook.kernel.comm_manager.register_target(
        'matplotlib',
        mpl.mpl_figure_comm
    );
}

</script>
</div>
<div class="cell-output cell-output-display">
<img src="data:image/png;base64,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" width="1000">
</div>
</div>
<p><strong>Question:</strong> - Given the contour in red above, and the corresponding counterclockwise mapping in green, - what can you tell about the number of poles and zeros inside the red contour?</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb16"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Uncomment the following line to see the solution</span></span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true" tabindex="-1"></a><span class="op">!</span>cat answers<span class="op">/</span>solution_nyquist_2</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>
* Circles the origin twice in the counter-clockwise direction, so there must be two more poles than zeros inside the contour.</code></pre>
</div>
</div>
</section>
</section>
<section id="the-nyquist-plot" class="level3">
<h3 class="anchored" data-anchor-id="the-nyquist-plot">The Nyquist plot</h3>
<ul>
<li><p>We can now apply the Cauchy‚Äôs principle argument</p></li>
<li><p>We would like to know if there are zeros of <span class="math inline">\(1+GH\)</span> in the right half plane (in which case the system is unstable)</p></li>
<li><p>We need a contour that includes the entire right half plane:</p>
<ul>
<li>includes the entire imaginary axis</li>
<li>goes up until <span class="math inline">\(+j\omega\)</span></li>
<li>sweeps around at <span class="math inline">\(\infty\)</span> to enclose the entire RHP</li>
<li>goes back to the imaginary axis at <span class="math inline">\(-j\omega\)</span> and up to 0</li>
</ul></li>
</ul>


<img src="img/nyquist-contour-100.png" alt="nyquist-contour" style="height: 400px;">


<ul>
<li><p>This is called the <strong>Nyquist contour</strong></p></li>
<li><p>Note that it avoids the poles on the imaginary axis</p></li>
<li><p>Mapping the Nyquist contour on the <span class="math inline">\(\Omega\)</span>-plane we obtain the <strong>Nyquist plot</strong></p>
<ul>
<li>To draw it, we need to plug in each single point along the <span class="math inline">\(j\omega\)</span> axis and all the points at <span class="math inline">\(\infty\)</span> in the right half plane</li>
<li>We need to repeat the steps we saw before. Will see how to do this in a moment.</li>
</ul></li>
<li><p>If we take <span class="math inline">\(1+GH\)</span> to map the Nyquist contour (in the s-plane) to the Nyquist plot (in the <span class="math inline">\(\Omega\)</span>-plane)</p></li>
<li><p>We can see how many times the origin is circled and in which direction</p></li>
<li><p>Determine how many more poles or zeros are inside the contour.</p></li>
<li><p>We could directly analyse <span class="math inline">\(1+GH\)</span> (i.e., plot the Nyquist plot of <span class="math inline">\(GH\)</span> and then shift the plot by 1).</p></li>
<li><p>Or which is simpler:</p>
<ul>
<li>plot <span class="math inline">\(GH\)</span> and shift the origin to the left by 1: we can look at how many circling of the point <span class="math inline">\(-1+0j\)</span> the plot of <span class="math inline">\(GH\)</span> does.</li>
</ul></li>
</ul>
<p><strong>Steps:</strong></p>
<ul>
<li>Take the open loop transfer function <span class="math inline">\(GH\)</span></li>
<li>Plot the Nyquist plot of <span class="math inline">\(GH\)</span> (plug in all the points along the Nyquist contour)</li>
<li>Count the number of times the point <span class="math inline">\(-1\)</span> is encircled and in which direction</li>
<li>Determine the relative number of poles and zeros inside the nyquist contour.</li>
</ul>
<p><strong>Note</strong> - The Nyquist method tells us about the relative number of poles and zeros - To know exactly how many zeros of <span class="math inline">\(1+GH\)</span> we have in the RHP, we need to know how many poles we have in the RHP - We typically know how many poles <span class="math inline">\(1+GH\)</span> has in the RHP: they are the same as those of the open loop <span class="math inline">\(GH\)</span> system (and we usually know those)</p>
<p>Let‚Äôs see why:</p>
<ul>
<li><p>The open loop system is: <span class="math display">\[
GH = \frac{N_G}{D_G}\frac{N_H}{D_H}
\]</span></p></li>
<li><p>And: <span class="math display">\[
1+GH = 1+\frac{N_G}{D_G}\frac{N_H}{D_H} = \frac{D_G D_H + N_G N_H}{D_G D_H}
\]</span></p></li>
</ul>
<p>We can know state the famous Nyquist equation:</p>
<p>Therefore: <span class="math display">\[
Z = N + P
\]</span></p>
<p>where - <span class="math inline">\(Z\)</span> is the number of zeros in the right half plane (or poles in closed loop) - <span class="math inline">\(N\)</span> is the number of clockwise encirclements of -1 - <span class="math inline">\(P\)</span> is the number of open loop right half plane poles</p>
<p><strong>Note:</strong> - <span class="math inline">\(N\)</span> is the number of encirclement of -1 clock wise. - It is an algebric quantity - If we have counter clockwise encirclements we need to invert its sign</p>
</section>
<section id="open-loop-stable" class="level3">
<h3 class="anchored" data-anchor-id="open-loop-stable">Open loop stable</h3>
<ul>
<li>When <span class="math inline">\(P=0\)</span> (open loop system is stable)</li>
<li><span class="math inline">\(Z=N \Rightarrow N=0\)</span> or no encirclements of the point <span class="math inline">\(-1\)</span> to have a stable closed loop system (for stability <span class="math inline">\(Z=0\)</span>).</li>
<li>This is the condition most often encountered</li>
</ul>
</section>
<section id="open-loop-unstable" class="level3">
<h3 class="anchored" data-anchor-id="open-loop-unstable">Open loop unstable</h3>
<ul>
<li>In order to guarantee that there are no zeros (roots) in the right half plane, you need to have exactly 1 counter-clockwise (CCW) encirclement of the point -1 for each open loop pole in the right half plane:</li>
</ul>
<p><span class="math display">\[
P = -N
\]</span></p>
<p><strong>Note</strong> - To know how many zeros of <span class="math inline">\(1+GH\)</span> (roots ot the numerator) are in the right half plane - We must know the unstable open loop poles of <span class="math inline">\(GH\)</span> - Some information on the open loop system is needed</p>
<p><strong>Comments</strong> - With the Nyquist plot we can anaylse the stability of a system with an <strong>unstable</strong> open loop plant. - We cannot use Bode plots to analyse the stability of closed loop systems when the open loop is unstable. We might obtain a wrong answer.</p>
<ul>
<li>Bode plots are easy to sketch, but not as powerful to analyse the system stability.</li>
</ul>
<hr>
</section>
</section>
<section id="estimating-nyquist-plots" class="level2">
<h2 class="anchored" data-anchor-id="estimating-nyquist-plots">Estimating Nyquist Plots</h2>
<p>Given a transfer function:</p>
<p><span class="math display">\[
G(s) = \frac{1}{s^2+3s+2}
\]</span></p>
<p>with poles: <span class="math inline">\(s=-1, s=-2\)</span></p>


<img src="img/nyquist-sketch.png" alt="nyquist-sketch2" style="height: 400px;">


<ul>
<li>We can select a point on the contour, plug it into the transfer function and calculate the result:</li>
</ul>
<p><span class="math display">\[
G(s) = \frac{1}{s^2+3s+2}
\Rightarrow
\frac{1}{(2j)^2+3\cdot(2j)+2} = \frac{1}{-4+2 + 6j} =  \frac{1}{-2 + 6j} \frac{-2 - 6j}{-2 - 6j} = \frac{-2 - 6j}{40} = -0.05 - 0.15j
\]</span></p>
<ul>
<li>This would give us one point in the <span class="math inline">\(\Omega\)</span>-plane</li>
<li>We can do it for every single point in the <span class="math inline">\(s\)</span>-plane‚Ä¶</li>
</ul>
<p>We can identify two main pieces of the Nyquist contour:</p>
<ul>
<li><ol type="1">
<li><em>The imaginary axis</em> (the <span class="math inline">\(j\omega\)</span> line), with <span class="math inline">\(\omega \in [-\infty, +\infty]\)</span>.</li>
</ol>
<p>We can then replace <span class="math inline">\(s=j\omega\)</span> in the transfer function to calculate it.</p>
<p>Given the symmetry of poles and zeros about the real axis, the negative portion is just the reflection of the positive portion of the axis.</p>
<p>We only need to calculate positive frequencies.</p></li>
<li><ol start="2" type="1">
<li><em>The rest of the countour</em>: starts at <span class="math inline">\(+\infty\)</span> on the imaginary axis, goes all around to get to <span class="math inline">\(+\infty\)</span> on the real axis and then goes back to <span class="math inline">\(-\infty\)</span> on the imaginary axis.</li>
</ol>
<p><strong>For strictly proper (order of denominator &gt; order of the numerator) or proper systems (order of denominator = order of numerator), this entire segment (which is infinitely long) maps to a single point in the <span class="math inline">\(\Omega\)</span>-plane</strong>.</p>
<p>All physically realisable systems are of these two types‚Ä¶</p></li>
</ul>
<p>Remember that: - the phase in the <span class="math inline">\(\Omega\)</span>-plane is: <span class="math display">\[
\angle P_\Omega = \sum \angle \text{zeros} - \sum \angle poles
\]</span></p>
<ul>
<li><p>the gain in the <span class="math inline">\(\Omega\)</span>-plane is: <span class="math display">\[
| P_\Omega | = \frac{ K \prod | \text{zeros} |}{\prod |\text{poles}|}
\]</span></p></li>
<li><p><strong>Case 1 - strictly proper:</strong></p>
<p>For a point at infinity the gain goes to zero (since we have more poles than zeros, we are dividing by infinity).</p>
<p>So any point in the contour maps to the origin in the <span class="math inline">\(\Omega\)</span>-plane.</p>
<p>Phase is not very important, because the point is always the same (as the s-point moves the phase change but the point is still the same).</p></li>
<li><p><strong>Case 2 - proper:</strong></p>
<p>For a point at infinity the gain is a finite real number (refer to the expressions above on phase and gain)</p>


<p><img src="img/nyquist_case-2.png" alt="nyquist-case-2" style="height: 400px;"></p>


<ul>
<li>The Phase is very important to determine where on the line the point is:
<ul>
<li>angle of a pole or of a zero when the point is at infinity is the same: the phase is 0 degree.</li>
</ul></li>
<li>The entire segment maps to a non-zero positive real number.</li>
</ul></li>
</ul>
<p><strong>To conclude</strong></p>
<ul>
<li>Since the entire case 2) is mapped to a single point, that means that we can simply use the point at <span class="math inline">\(+\infty\)</span> on the positive <span class="math inline">\(j\omega\)</span> axis,</li>
<li>Due to symmetry of poles and zeros about the real axis, we also do not need to worry of the negative <span class="math inline">\(\omega\)</span>,</li>
<li>We need to only study and plot the positive <span class="math inline">\(\omega\)</span></li>
</ul>
<section id="steps-to-plot-a-nyquist-plot" class="level3">
<h3 class="anchored" data-anchor-id="steps-to-plot-a-nyquist-plot">Steps to plot a Nyquist plot</h3>
<ul>
<li><ol type="1">
<li>Set <span class="math inline">\(s=j\omega\)</span> in the transfer function</li>
</ol></li>
<li><ol start="2" type="1">
<li>Sweep <span class="math inline">\(\omega \in [0, \infty]\)</span> and plot the resulting complex numbers</li>
</ol></li>
<li><ol start="3" type="1">
<li>Draw the reflection about the real axis to account for negative <span class="math inline">\(\omega\)</span></li>
</ol></li>
<li>Note that the Nyquist contour is traced in the <strong>clock-wise</strong> direction (by convention)</li>
</ul>
<p>Key is step #2:</p>
<ul>
<li>For simple transfer functions there are only four points that we need to solve for
<ul>
<li><ol type="1">
<li><span class="math inline">\(|G|\)</span> and <span class="math inline">\(\angle G\)</span> at <span class="math inline">\(\omega=0\)</span> (start of the plot)</li>
</ol></li>
<li><ol start="2" type="1">
<li><span class="math inline">\(|G|\)</span> and <span class="math inline">\(\angle G\)</span> at <span class="math inline">\(\omega=\infty\)</span> (mid point of the plot)</li>
</ol></li>
<li><ol start="3" type="1">
<li>Intersections with the imaginary axis</li>
</ol></li>
<li><ol start="4" type="1">
<li>Intersections with the real axis</li>
</ol></li>
</ul></li>
</ul>
<p>Having these points is typically enough if we are interested in the stability only. From these points we can deduce the rest of the diagram.</p>
<p>For more complex transfer functions, steps 3 and 4 might become complicated. In those cases, it is probably simpler to use the <code>Python Control Library</code> or MATLAB.</p>
<p>Example:</p>
<p><span class="math display">\[
G(s) = \frac{1}{s^2+3s+2}
\]</span></p>
<ul>
<li><ol type="1">
<li><span class="math inline">\(\frac{1}{(j\omega)^2+3(j\omega)+2} |_{\omega=0}=\frac{1}{2}\)</span>, <span class="math inline">\(\angle =0\)</span></li>
</ol></li>
<li><ol start="2" type="1">
<li><span class="math inline">\(\frac{1}{(j\omega)^2+3(j\omega)+2} |_{\omega=\infty}=\frac{1}{\infty}=0\)</span> (strictly proper transfer function), <span class="math inline">\(\angle =-180\)</span></li>
</ol>
<ul>
<li>note that for this transfer function, when we analyse the point <span class="math inline">\(\omega = \infty\)</span>, the phase is <span class="math inline">\(e^{-j2\theta}\)</span>, <span class="math inline">\(\theta=\pi/2\)</span>. This is easy to see if we look at the original transfer function and substitute the generic point: <span class="math inline">\(s=Re^{j\theta}\)</span> and we note that <span class="math inline">\(s^2\)</span> dominates the espression.</li>
</ul></li>
</ul>
<p>To do steps 3 and 4 and find the intersections, it is easier to convert our <span class="math inline">\(G(s)|_{s=j\omega}\)</span> to a <span class="math inline">\(x+jy\)</span> vector to explicit the real and imaginary components:</p>
<p><span class="math display">\[
\frac{1}{(j\omega)^2+3(j\omega)+2} = \frac{1}{(2-\omega^2) + 3\omega j} \frac{(2-\omega^2) - 3\omega j}{(2-\omega^2) - 3\omega j} = \frac{(2-\omega^2) - 3\omega j}{(2-\omega^2)^2 + 9\omega^2}
\]</span></p>
<ul>
<li><ol start="3" type="1">
<li>To calculate the imaginary intercept: set the real part to 0 and find the <span class="math inline">\(\omega\)</span> to use in the imaginary part:</li>
</ol></li>
</ul>
<p><span class="math display">\[
\frac{(2-\omega^2) }{(2-\omega^2)^2 + 9\omega^2} = 0 \Rightarrow \omega=\sqrt{2} \;\;\Rightarrow \;\;\frac{-3\sqrt{2}}{2\cdot9} = -\frac{\sqrt{2}}{6} \approx -0.236
\]</span></p>
<ul>
<li><ol start="4" type="1">
<li>To calculate the real intercept: set the imaginary part to 0 and find the <span class="math inline">\(\omega\)</span> to use in the real part:</li>
</ol></li>
</ul>
<p><span class="math display">\[
\frac{- 3\omega j}{(2-\omega^2)^2 + 9\omega^2} = 0 \Rightarrow \omega=0\; \text{,}\; \omega=\infty
\]</span></p>
<p>We found points <span class="math inline">\(\omega=0\; \text{,}\; \omega=\infty\)</span> already in points 1 and 2.</p>
<p>It means that the plot only crosses the real axis at the start and at the mid point of the plot.</p>


<img src="img/nyquist-sketch-example-drawn-1.png" alt="nyquist-sketch-example" style="height: 400px;">


<ul>
<li>The bottom part is the polar plot of the frequency response</li>
</ul>
<p>We can plot it in Python and verify:</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb18"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a>sys <span class="op">=</span> control.tf([<span class="dv">1</span>], [<span class="dv">1</span>, <span class="dv">3</span>, <span class="dv">2</span>])</span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-3"><a href="#cb18-3" aria-hidden="true" tabindex="-1"></a>fig <span class="op">=</span> plt.figure(figsize<span class="op">=</span>(<span class="dv">10</span>, <span class="dv">5</span>))</span>
<span id="cb18-4"><a href="#cb18-4" aria-hidden="true" tabindex="-1"></a>control.nyquist_plot(sys)<span class="op">;</span></span>
<span id="cb18-5"><a href="#cb18-5" aria-hidden="true" tabindex="-1"></a>plt.legend([<span class="st">'sys'</span>], loc<span class="op">=</span><span class="st">'upper right'</span>)<span class="op">;</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<p><img src="11_Nyquist_stability_criterion_files/figure-html/cell-18-output-1.png" class="img-fluid"></p>
</div>
</div>
<p><strong>Question</strong> - Is the system stable?</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb19"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Uncomment the following line to see the solution</span></span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true" tabindex="-1"></a><span class="op">!</span>cat answers<span class="op">/</span>solution_nyquist_3</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>
* Yes. The closed loop system is stable
* No open loop unstable poles (open loop poles are s=-1, s=-2)
* There are no encirclements of the point -1</code></pre>
</div>
</div>
<p><strong>Comments</strong> - This method does not tell us the exact plot - It is enough to verify the stability of the system</p>


<img src="img/nyquist-sketch-example-drawn-2.png" alt="nyquist-sketch-example" style="height: 400px;">


</section>
<section id="poles-on-the-imaginary-axis" class="level3">
<h3 class="anchored" data-anchor-id="poles-on-the-imaginary-axis">Poles on the imaginary axis</h3>
<p>Let‚Äôs consider a pole at the origin:</p>
<p><span class="math display">\[
G(s) = \frac{1}{s}
\]</span></p>
<ul>
<li>As we move closer to the pole:
<ul>
<li>The phase initially is the same (90 deg, see Figure below as the cyan marker goes to 0)</li>
<li>The magnitude gets smaller <span class="math inline">\(\Rightarrow\)</span> the magnitude in the <span class="math inline">\(\Omega-plane\)</span> tends to <span class="math inline">\(\infty\)</span></li>
<li>When we are right at the pole: the gain is 0, the phase is undefined</li>
</ul></li>
</ul>


<img src="img/nyquist-sketch-imaginary-poles-arrow.png" alt="nyquist-sketch-imaginary-poles" style="height: 400px;">


<ul>
<li>We cannot use the original Nyquist contour with poles on the imaginary axis.</li>
<li>We modify the contour a bit to avoid the poles on the imaginary axis</li>
<li>We need to move it as little as possible so that we only remove the imaginary poles but nothing else</li>
<li>This makes it possible to calculate the phase</li>
</ul>


<img src="img/nyquist-contour.png" alt="nyquist-contour" style="height: 400px;">


<p>Going back to our original transfer function <span class="math inline">\(\Large \frac{1}{s}\)</span>, when we modify the contour is clear that: - Gain is still infinity (we are still dividing by a very small number) - Phase clearly sweeps between <span class="math inline">\([-90, 90]\)</span> - We can now plot the Nyquist plot</p>
<ul>
<li>We can evaluate gain and phase at 3 key s-points:
<ul>
<li>at <span class="math inline">\(w=0\)</span>: gain is <span class="math inline">\(\infty\)</span>, phase is 0</li>
<li>as we loop around the pole: gain is <span class="math inline">\(\infty\)</span>, phase goes from <span class="math inline">\(0\)</span> to <span class="math inline">\(-90\)</span> deg.</li>
</ul></li>
</ul>

<table style="margin: 0 auto" rules="none">
<tbody><tr>
<td>
<img src="img/nyquist-sketch-imaginary-poles-2.png" alt="nyquist-sketch-imaginary-poles-2" style="width: 350px;">
</td>
<td>
<img src="img/nyquist-pole-at-origin-1.png" alt="nyquist-pole-at-origin" style="width: 350px;">
</td>
</tr>

</tbody></table>
<ul>
<li>And then reflect the Nyquist plot around the real-axis</li>
</ul>
<p>Let‚Äôs see what the Python Control Library tells us:</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb21"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true" tabindex="-1"></a><span class="co"># We define our transfer function 1/s</span></span>
<span id="cb21-2"><a href="#cb21-2" aria-hidden="true" tabindex="-1"></a>sys <span class="op">=</span> control.tf([<span class="dv">1</span>], [<span class="dv">1</span>, <span class="dv">0</span>])</span>
<span id="cb21-3"><a href="#cb21-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-4"><a href="#cb21-4" aria-hidden="true" tabindex="-1"></a><span class="co"># Create the figure</span></span>
<span id="cb21-5"><a href="#cb21-5" aria-hidden="true" tabindex="-1"></a>fig <span class="op">=</span> plt.figure(figsize<span class="op">=</span>(<span class="dv">10</span>, <span class="dv">5</span>))</span>
<span id="cb21-6"><a href="#cb21-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-7"><a href="#cb21-7" aria-hidden="true" tabindex="-1"></a><span class="co"># Call nyquist_plot</span></span>
<span id="cb21-8"><a href="#cb21-8" aria-hidden="true" tabindex="-1"></a>control.nyquist_plot(sys)<span class="op">;</span></span>
<span id="cb21-9"><a href="#cb21-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-10"><a href="#cb21-10" aria-hidden="true" tabindex="-1"></a><span class="co"># Add a legend</span></span>
<span id="cb21-11"><a href="#cb21-11" aria-hidden="true" tabindex="-1"></a>plt.legend([<span class="st">'sys'</span>], loc<span class="op">=</span><span class="st">'upper right'</span>)<span class="op">;</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<p><img src="11_Nyquist_stability_criterion_files/figure-html/cell-20-output-1.png" class="img-fluid"></p>
</div>
</div>
<p>For this system, with can conclude: - No OL poles in the RHP and no encirclement of the point -1, so the closed loop system is stable. - Python control library does not really do a good job to represent it so we need to be careful when interpreting the plot.</p>
<ul>
<li><strong>Question:</strong>
<ul>
<li>what happens if instead we modified the contour in the other direction?</li>
</ul></li>
</ul>

<table style="margin: 0 auto" rules="none">
<tbody><tr>
<td>
<img src="img/nyquist-axis-2.png" alt="nyquist-axis-2-omega" style="width: 350px;">
</td>
<td>
<img src="img/nyquist-axis-2-omega.png" alt="nyquist-axis-2-omega" style="width: 350px;">
</td>
</tr>

</tbody></table>
<ul>
<li>The system is stable:
<ul>
<li>One open loop pole inside the contour</li>
<li>The Nyquist plot encircles the -1 point once in the CCW direction</li>
<li>Hence no closed loop poles in the RHP</li>
</ul></li>
</ul>
<p><strong>Open Loop zeros on the imaginary axis?</strong></p>
<ul>
<li><p>The gain is zero</p></li>
<li><p>Phase not defined</p></li>
<li><p>However since the gain is zero this is not a problem: the point is at the origin of the <span class="math inline">\(\Omega\)</span>-plane and phase does not change that.</p></li>
<li><p>We could modify the contour but we would get the same result just as if we did not modify the countor: we can simply proceed with the normal Nyquist contour.</p></li>
</ul>
</section>
<section id="nyquist-plot-final-comments" class="level3">
<h3 class="anchored" data-anchor-id="nyquist-plot-final-comments">Nyquist plot: final comments</h3>
<ul>
<li><p>Nyquist plot is really useful when the Open Loop plant has poles or zeros in the RHP</p></li>
<li><p>Some systems have poles that are barely unstable</p>
<ul>
<li>Bode plots are difficult to read in these cases</li>
<li>Nyquist instead provides a much clearer answer</li>
</ul></li>
<li><p>Try to compare Bode plots and Nyquist plots when one pole of your system is slightly unstable</p></li>
</ul>
<p>Let‚Äôs use, for example the following transfer function</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb22"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true" tabindex="-1"></a>sys_u <span class="op">=</span> control.tf([<span class="fl">3.553e-15</span>, <span class="op">-</span><span class="fl">0.1642</span>, <span class="op">-</span><span class="fl">0.1243</span>, <span class="op">-</span><span class="fl">0.00161</span>, <span class="fl">9.121e-17</span>],</span>
<span id="cb22-2"><a href="#cb22-2" aria-hidden="true" tabindex="-1"></a>                 [<span class="dv">1</span>, <span class="fl">1.825</span>, <span class="fl">2.941</span>, <span class="fl">0.03508</span>, <span class="fl">0.01522</span>, <span class="op">-</span><span class="fl">1.245e-15</span>])</span>
<span id="cb22-3"><a href="#cb22-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-4"><a href="#cb22-4" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(sys_u)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>
 3.553e-15 s^4 - 0.1642 s^3 - 0.1243 s^2 - 0.00161 s + 9.121e-17
-----------------------------------------------------------------
s^5 + 1.825 s^4 + 2.941 s^3 + 0.03508 s^2 + 0.01522 s - 1.245e-15
</code></pre>
</div>
</div>
<p>We would like to improve its performance using unitary feedback.</p>
<p>We can note that the open loop system is unstable, because there is a change in sign in the characteristic equation.</p>
<p>And then we can also verify it with Python:</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb24"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb24-1"><a href="#cb24-1" aria-hidden="true" tabindex="-1"></a>np.roots([<span class="dv">1</span>, <span class="fl">1.825</span>, <span class="fl">2.941</span>, <span class="fl">0.03508</span>, <span class="fl">0.01522</span>, <span class="op">-</span><span class="fl">0.1245e-15</span>])</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<pre><code>array([-9.08114038e-01+1.44747521j, -9.08114038e-01-1.44747521j,
       -4.38596244e-03+0.0720649j , -4.38596244e-03-0.0720649j ,
        8.18002628e-15+0.j        ])</code></pre>
</div>
</div>
<p>Let‚Äôs plot the Bode diagrams.</p>
<p>The Python Control Library does not handle well the very small numbers at the numerator of this example (<code>Badly conditioned filter coefficients</code>), while MATLAB does.</p>
<p>The figure below reports results obtained in MATLAB:</p>

<table style="margin: 0 auto" rules="none">
<tbody><tr>
<td>
<img src="img/matlab_bode.png" alt="matlab-bode" style="width: 700px;">
</td>
</tr>

</tbody></table>
<p>And we can also show the Nyquist plot:</p>

<table style="margin: 0 auto" rules="none">
<tbody><tr>
<td>
<img src="img/matlab_nyquist.png" alt="matlab-nyquist" style="width: 700px;">
</td>
</tr>

</tbody></table>
<ul>
<li>There are two CW encirclements of -1</li>
<li>One OL unstable pole</li>
<li>A closed loop system with unitary feedback would have 3 unstable poles.</li>
</ul>


</section>
</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "Óßã";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    target: function(trigger) {
      return trigger.previousElementSibling;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
  function tippyHover(el, contentFn) {
    const config = {
      allowHTML: true,
      content: contentFn,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start'
    };
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      return note.innerHTML;
    });
  }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->



</body></html>